#+STARTUP: showall indent hidestars


* Chapter 3
** Page 55

Функция принимает параметр x. Проверяет, является ли он ячейкой.
Если да, то вызывает фнкцию compr, котораяпринимает 3 параметра:
последний повстречавшийся элемент, число его повторений и
остаток списка. Если же X ячейкой не является, мы просто
вернем его.


#+BEGIN_SRC lisp

  (defun compress (x)
    (if (consp x)
        (compr (car x) 1 (cdr x))
        x))

#+END_SRC


Функция compr должна вернуть нам сжатое продставление списка.
Сначала проверяем, не пустой ли остаток нашего списка (lst).
Если пустой, то вызываем n-elts, которая сожмет наш список. Если
lst не пустой, то мы берем первый элемент списка и записываем его
в локальную переменную next. Смотрим, одинаков ли первый элемент
списка и переменная. Если да, то рекурсивно вызываем compr,
инкрементировав n и в качестве lst подставив его остаток.
Если next и первый элемент списка не равны, то вызываем n-elts и
результат записываем в новый список. А потом снова рекурсивно
вызываем compr, чтоб проверить остальные элементы списка.

#+BEGIN_SRC lisp

  (defun compr (elt n lst)
    (if (null lst)
        (list (n-elts elt n))
        (let ((next (car lst)))
          (if (eql next elt)
              (compr elt (+ n 1) (cdr lst))
              (cons (n-elts elt n)
                    (compr next 1 (cdr lst)))))))

#+END_SRC

Функция n-elts проверяет, встретился ли элемент более одного раза.
Если да, то формируется новый список, который показыаает
сколько раз встретился элемент. Если элемент встретился один или
менее раз, то мы просто его возвращаем.

#+BEGIN_SRC lisp

  (defun n-elts (elt n)
    (if (> n 1)
        (list n elt)
        elt))
#+END_SRC
** Page 56

Досмотреть. Какая-то ерунда получилась.

Функция uncompress превращает сжатый список в исходный. Параметр:
список.
Сначала проверяем, не пустой ли список. Если пустой, возвращаем nil.
Если нет, загружаем первый элемент списка в переменную elt и
рекурсивно вызываем фунцию с остатком списка, а rest предоставит нам
остаток от остатка списка (cdr(cdr lst)).
Если elt ячейка, то вызываем list-of с elt (сколько раз повторяется
элемент?) и rest - остаток списка. Apply вернет результат вызова
функции, а append склеит результат в один список. Если же elt не
является ячейкой, то мы создадим новый список.


#+BEGIN_SRC lisp

  (defun uncompress (lst)
    (if (null lst)
        nil
        (let ((elt (car lst))
              (rest (uncompress (cdr lst))))
          (if (consp elt)
              (append (apply #’list-of elt)
                      rest)
              (cons elt rest)))))

#+END_SRC

Функция list-of формирует список. Если n ноль, то мы возвращаем nil,
в противном случае рекурсивно вызываем функцию и формируем новый
список.

#+BEGIN_SRC lisp

  (defun list-of (n elt)
    (if (zerop n)
        nil
        (cons elt (list-of (- n 1) elt))))

#+END_SRC

** Page 67

Функция должна выдать нам пару для key в заданном ассоциативном
списке (списке из точечных пар).

#+BEGIN_SRC lisp

(defun our-assoc (key alist)
(and (consp alist)
(let ((pair (car alist)))
(if (eql key (car pair))
pair
(our-assoc key (cdr alist))))))

#+END_SRC

Если alist - это ячейка, тогда мы присваиваем локальной переменной
pair первую пару списка. Если key = первому элементу списка, то
возвращаем пару. Если нет, то рекурсивно вызываем функцию с key
и остатком списка. Если список кончится, а мы ничего не нашли,
вернем nil.



** Page 68
Функция должна найти крайтчайший путь к элементу.
shortest-path принимает 3 аргумента: начальную и конченую точки,
саму сеть. Она передает функции bfs конечную точку, начальную
точку, представленную в виде списка (зачем 2 раза оборачивать?) и
саму сеть.
#+BEGIN_SRC lisp

  (defun shortest-path (start end net)
    (bfs end (list (list start)) net))

#+END_SRC

Bfs принимает 3 аргумента: конечную точку, "очередь" и саму сеть.
Затем мы проверяем, является очередь пустым списком. Если да,
возвращаем nil. Если нет, то записываем первый элемент очереди в
переменную path. А первый элемент path - в переменную node.
Видимо, первый элемент queue должен быть списоком или хотя бы
точечной парой. Затем мы проверям, равны ли node и end.
Если равны, то возвращаем элементы path в обратном порядке, чтоб
показать, через какие узлы надо пройти для достижения цели.
Если нет, то рекурсивно вызываем bfs c конечной точкой,
склеенным списком, состоящим из остатка queue и результата
вызова new_paths (новая очередь/путь), и сетью.

#+BEGIN_SRC lisp

  (defun bfs (end queue net)
(format t " BFS end ~a queue ~a  net ~a ~&" end queue net)
(if (null queue)
        nil
        (let ((path (car queue)))
          (let ((node (car path)))
(format t " BFS path ~a ~& " path)
            (if (eql node end)
                (format t " reverse path ~a ~&" (reverse path))
                (bfs end
                     (append (cdr queue)
                             (new-paths path node net))
                     net))))))

#+END_SRC

new-paths принимает три аргумента: путь, узел и саму сеть.
Дальше к каждому элементу списка (какого?) будет применено
(cons n path), где n - это результат от (cdr (assoc node net)).
Assoc ищет в ассоциативных списках пару, где встречается ключ.
Затем возьмем cdr от полученного списка, потому что пройденный
узел нам уже не интересует, и к остатку писка применим функцию
внутри mapcar. То есть возьмем каждый элемент полученного списка,
подставим его вместо n и присоединим его к path.

Так мы получим новый путь, а вернее сказать, новую очередь для
функции bfs.
#+BEGIN_SRC lisp

  (defun new-paths (path node net)
(format t " NEW-PATHS path ~a node  ~a  net ~a ~&" path node net)
    (mapcar #'(lambda (n)
                (cons n path))
              (cdr (assoc node net))))
#+END_SRC
* Chapter 4
** page 76

Функция реализует бинарный  поиск в отсортированном
одномерном массиве (векторе)

Функция bin-search принимает два аргумента:
искомый объект и массив (вектор)
Устанавливаем длину массива в len. Если длина массива != 0,
то вызываем функцию finder, передаем ей объект, массив, начальную
и конечную точки поиска.

#+BEGIN_SRC lisp

  (defun bin-search (obj vec)
    (let ((len (length vec)))
      (and (not (zerop len))
           (finder obj vec 0 (- len 1)))))

#+END_SRC

Вычитаем из конечной точки начальную, записываем результат в
range. Если range = 0, то проверяем, равен ли объект элементу
массива. Если да, то возвращаем объект. Если нет - значит, во
всем массиве ничего не нашлось. Данная ветка может сработать,
если поиск сократился до одного элемента.

В случае, если range != 0, то мы получаем середину (mid).
Получаем элемент вектора, соответствующий mid и записываем его в
obj2. Если искомый объект меньше, чем середина, то мы "сдвигаемся
влево", вызывая finder с (mid - 1) вместо конечной точки.
В противном случае мы проверям, больше ли объект середины. Если
да, то "сдвигаемся вправо", вызывает finder c (mid + 1) вмето
начальной точки. В противном случае возвращаем сам объект, т.к.
если он не больше и не меньше средины, значит, сереина = объект.

#+BEGIN_SRC lisp

(defun finder (obj vec start end)
    (let ((range (- end start)))
      (if (zerop range)
          (if (eql obj (aref vec start))
              obj
              nil)
          (let ((mid (+ start (round (/ range 2)))))
            (let ((obj2 (aref vec mid)))
              (if (< obj obj2)
                  (finder obj vec start (- mid 1))
                  (if (> obj obj2)
                      (finder obj vec (+ mid 1) end)
                      obj)))))))

#+END_SRC
** page 83

Функция tokens разберет нашу строку на знаки. Знаками считается
все, из чего может состоять строка: буквы, цифры, знаки
препинания и т.д.

Принимает строку, ключ и начальную точку.
Проверяем первый символ сроки на соответствие ключу. Если первый
символ найден, то ищем второй.
Когда нашли второй элемент (каким образом?), вызываем cons.
Cons содеинит нам строку от первого элемента до второго и
выхов tokens со вторым элементом в качестве начальной точки.
Если рекурсивный вызов ничего не дал, возвращаем nil.

Таким образом мы полчим все символы, удовлетворяющие условию.
#+BEGIN_SRC lisp

  (defun tokens (str test start)
    (let ((p1 (position-if test str :start start)))
      (if p1
          (let ((p2 (position-if #’(lambda (c)
                                     (not (funcall test c)))
                                   str :start p1)))
            (cons (subseq str p1 p2)
                  (if p2
                      (tokens str test p2)
                      nil)))
          nil)))

#+END_SRC

Функция принимает в качестве аргумента символ.
Проверет, явяется ли он буквой. Затем, проверяем,
не является ли он пробелом.
Если это буква и не пробел, возвращаем символ.

#+BEGIN_SRC lisp


  (defun constituent (c)
    (and (graphic-char-p c)
         (not (char= c #\ ))))

#+END_SRC


** page 84

Функция преобразует строку, содержащую число в само число.

Если вся строка состоит из цифр,
#+BEGIN_SRC lisp

  (defun read-integer (str)
    (if (every #’digit-char-p str)
        (let ((accum 0))
          (dotimes (pos (length str))
            (setf accum (+ (* accum 10)
                           (digit-char-p (char str pos)))))
          accum)
        nil))

#+END_SRC

** page 89

Создание дерева.
Создаем структуру с помощью defstruct, называем ее node (узел)
Указываем, что для печати node мы будем использовать format, который
выведет нам элемент, его правый и левый потомок.

#+BEGIN_SRC lisp

  (defstruct (node (:print-function
                    (lambda (n s d)
                      (format s "#<~A>" (node-elt n)))))
    elt (l nil) (r nil))

#+END_SRC

Bst-insert как cons для списков: создает новые узлы и объединяет их в
дерево.

Функция принимает 3 аргумента: объект, дерево и функция, с помощью
которой дерево будет упорядочено.

Если дерево пустое, то создаем экземпляр структуры node и в поле
elt записываем объект (видимо, остальные поля идентичны node).
Если же дерево не пустое, то мы создаем переменную elt и записываем
в нее node-elt(видимо, поле elt конкретного узла) и дерево (целиком? зачем?)
Проверяем, если объект равен элементу, то возвращаем дерево.
Если же не равен, то мы проверяем:
- объект меньше элемента?
Если да, то создаем новый экземпляр node, присваиваем полю elt
значение elt, поле l (левый потомок) получает значение от рекурсивного
вызова bst-insert (в качестве объекта левый потомок node, дерево и
оператор). В поле r (правый потомок) будет записано значение парвого
поля node и само дерево.
- если предыдущая ветка ифа не сработала, значит, объект больше
  элемента
Тогда мы опять записываем в поле elt значение elt, в правый потомок
будет записан рекурсивый вызов от bst-insert, а в левый - значение
поля l из node и дерево (зачем писать дерево?)


#+BEGIN_SRC lisp

  (defun bst-insert (obj bst <)
    (if (null bst)
        (make-node :elt obj)
        (let ((elt (node-elt bst)))
          (format t "~a ~&" node-elt)
          (if (eql obj elt)
              bst
              (if (funcall < obj elt)
                  (make-node
                   :elt elt
                   :l (bst-insert obj (node-l bst) <)
                   :r (node-r bst))
                  (make-node
                   :elt elt
                   :r (bst-insert obj (node-r bst) <)
                   :l (node-l bst)))))))

#+END_SRC

Запускать надо все вместе:

#+BEGIN_SRC lisp

  (defstruct (node (:print-function
                    (lambda (n s d)
                      (format s "#<~A>" (node-elt n)))))
    elt (l nil) (r nil))

  (defun bst-insert (obj bst <)
    (if (null bst)
        (make-node :elt obj)
        (let ((elt (node-elt bst)))
          (format t "~a ~&" node-elt)
        (if (eql obj elt)
            bst
            (if (funcall < obj elt)
                (make-node
                 :elt elt
                 :l (bst-insert obj (node-l bst) <)
                 (format t " left true ~a ~&" l)
                 :r (node-r bst)
                 (format t " right true ~a ~&" r))
                 (make-node
                  :elt elt
                  :r (bst-insert obj (node-r bst) <)
                  (format t "right false ~a ~&" r)
                  :l (node-l bst)
                  (format t "left false ~a ~&" l)))))))

  (let ((nums))
    (dolist (x '(5 8 4 2 1 9 6 7 3))
      (setf nums (bst-insert x nums #' <))))

#+END_SRC

Bst-find ищет элемент в дереве и если находит,
то возвращает его поддерево. В противном случае возвращается nil.

Если дерево пустое, возвращаем nil.
В противном случае записываем в переменную elt узел дерева. Проверяем,
является ли искомый объект элементом из узла. Если да, то возвращаем
поддерево. Если нет, то рекурсивно вызываем bst-find в зависимости от
того, какая ветка ифа сработала.

#+BEGIN_SRC lisp

  (defun bst-find (obj bst <)
    (if (null bst)
        nil
        (let ((elt (node-elt bst)))
          (if (eql obj elt)
              bst
              (if (funcall < obj elt)
                  (bst-find obj (node-l bst) <)
                  (bst-find obj (node-r bst) <))))))

#+END_SRC


#+BEGIN_SRC lisp

  (defun bst-remove (obj bst <)
    (if (null bst)
        nil
        (let ((elt (node-elt bst)))
          (if (eql obj elt)
              (percolate bst)
              (if (funcall < obj elt)
                  (make-node
                   :elt elt
                   :l (bst-remove obj (node-l bst) <)
                   :r (node-r bst))
                  (make-node
                   :elt elt
                   :r (bst-remove obj (node-r bst) <)
                   :l (node-l bst)))))))

#+END_SRC
