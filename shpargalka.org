#+STARTUP: showall indent hidestars


* Chapter 3
** Page 55

Функция принимает параметр x. Проверяет, является ли он ячейкой.
Если да, то вызывает фнкцию compr, котораяпринимает 3 параметра:
последний повстречавшийся элемент, число его повторений и
остаток списка. Если же X ячейкой не является, мы просто
вернем его.


#+BEGIN_SRC lisp

  (defun compress (x)
    (if (consp x)
        (compr (car x) 1 (cdr x))
        x))

#+END_SRC


Функция compr должна вернуть нам сжатое продставление списка.
Сначала проверяем, не пустой ли остаток нашего списка (lst).
Если пустой, то вызываем n-elts, которая сожмет наш список. Если
lst не пустой, то мы берем первый элемент списка и записываем его
в локальную переменную next. Смотрим, одинаков ли первый элемент
списка и переменная. Если да, то рекурсивно вызываем compr,
инкрементировав n и в качестве lst подставив его остаток.
Если next и первый элемент списка не равны, то вызываем n-elts и
результат записываем в новый список. А потом снова рекурсивно
вызываем compr, чтоб проверить остальные элементы списка.

#+BEGIN_SRC lisp

  (defun compr (elt n lst)
    (if (null lst)
        (list (n-elts elt n))
        (let ((next (car lst)))
          (if (eql next elt)
              (compr elt (+ n 1) (cdr lst))
              (cons (n-elts elt n)
                    (compr next 1 (cdr lst)))))))

#+END_SRC

Функция n-elts проверяет, встретился ли элемент более одного раза.
Если да, то формируется новый список, который показыаает
сколько раз встретился элемент. Если элемент встретился один или
менее раз, то мы просто его возвращаем.

#+BEGIN_SRC lisp

  (defun n-elts (elt n)
    (if (> n 1)
        (list n elt)
        elt))
#+END_SRC
** Page 56

Досмотреть. Какая-то ерунда получилась.

Функция uncompress превращает сжатый список в исходный. Параметр:
список.
Сначала проверяем, не пустой ли список. Если пустой, возвращаем nil.
Если нет, загружаем первый элемент списка в переменную elt и
рекурсивно вызываем фунцию с остатком списка, а rest предоставит нам
остаток от остатка списка (cdr(cdr lst)).
Если elt ячейка, то вызываем list-of с elt (сколько раз повторяется
элемент?) и rest - остаток списка. Apply вернет результат вызова
функции, а append склеит результат в один список. Если же elt не
является ячейкой, то мы создадим новый список.


#+BEGIN_SRC lisp

  (defun uncompress (lst)
    (if (null lst)
        nil
        (let ((elt (car lst))
              (rest (uncompress (cdr lst))))
          (if (consp elt)
              (append (apply #’list-of elt)
                      rest)
              (cons elt rest)))))

#+END_SRC

Функция list-of формирует список. Если n ноль, то мы возвращаем nil,
в противном случае рекурсивно вызываем функцию и формируем новый
список.

#+BEGIN_SRC lisp

  (defun list-of (n elt)
    (if (zerop n)
        nil
        (cons elt (list-of (- n 1) elt))))

#+END_SRC


** Page 68
Функция должна найти крайтчайший путь к элементу.
shortest-path принимает 3 аргумента: начальную и конченую точки, саму
сеть. Она передает bfs конечную точку и начальную, обернутую в список
(два раза? зачем?) и саму сеть.

#+BEGIN_SRC lisp

  (defun shortest-path (start end net)
    (bfs end (list (list start)) net))

#+END_SRC

Bfs принимает 3 аргумента: конечную точку, "очередь" и саму сеть.
Затем мы проверяем, является очередь пустым списком. Если да,
возвращаем nil. Если нет, то записываем первый элемент очереди в
переменную path. А первый элемент path - в переменную node. Видимо,
первый элемент queue должен быть списоком или хотя бы точечной парой.
Затем мы проверям, равны ли node и end. Если равны, то возвращаем
элементы списка в обратном порядке. Если нет, то рекурсивно вызываем
bfs c конечной точкой, склеенным списком, состоящим из остатка queue и
 результата вызова функции new-path, и сетью.

(Как можно клеить результат вызова new-paths, если append игнорирует
последний аргумент?)

#+BEGIN_SRC lisp

  (defun bfs (end queue net)
    (if (null queue)
        nil
        (let ((path (car queue)))
          (let ((node (car path)))
            (if (eql node end)
                (reverse path)
                (bfs end
                     (append (cdr queue)
                             (new-paths path node net))
                     net))))))

#+END_SRC

new-paths принимает три аргумента: путь, узел и саму сеть.
Затем мы с помощью assoc находим в какие узлы net (сети) можно попасть
из узла node. Возвращенный результат (кроме первого попавшегося узла)
мы по очереди применяем к каждому элементу path с помощью mapcar.
#+BEGIN_SRC lisp

  (defun new-paths (path node net)
    (mapcar #’(lambda (n)
                (cons n path))
              (cdr (assoc node net))))
#+END_SRC
