#+STARTUP: showall indent hidestars


* Chapter 3
** Page 55

Функция принимает параметр x. Проверяет, является ли он ячейкой.
Если да, то вызывает фнкцию compr, котораяпринимает 3 параметра:
последний повстречавшийся элемент, число его повторений и
остаток списка. Если же X ячейкой не является, мы просто
вернем его.


#+BEGIN_SRC lisp

  (defun compress (x)
    (if (consp x)
        (compr (car x) 1 (cdr x))
        x))

#+END_SRC


Функция compr должна вернуть нам сжатое продставление списка.
Сначала проверяем, не пустой ли остаток нашего списка (lst).
Если пустой, то вызываем n-elts, которая сожмет наш список. Если
lst не пустой, то мы берем первый элемент списка и записываем его
в локальную переменную next. Смотрим, одинаков ли первый элемент
списка и переменная. Если да, то рекурсивно вызываем compr,
инкрементировав n и в качестве lst подставив его остаток.
Если next и первый элемент списка не равны, то вызываем n-elts и
результат записываем в новый список. А потом снова рекурсивно
вызываем compr, чтоб проверить остальные элементы списка.

#+BEGIN_SRC lisp

  (defun compr (elt n lst)
    (if (null lst)
        (list (n-elts elt n))
        (let ((next (car lst)))
          (if (eql next elt)
              (compr elt (+ n 1) (cdr lst))
              (cons (n-elts elt n)
                    (compr next 1 (cdr lst)))))))

#+END_SRC

Функция n-elts проверяет, встретился ли элемент более одного раза.
Если да, то формируется новый список, который показыаает
сколько раз встретился элемент. Если элемент встретился один или
менее раз, то мы просто его возвращаем.

#+BEGIN_SRC lisp

  (defun n-elts (elt n)
    (if (> n 1)
        (list n elt)
        elt))
#+END_SRC
** Page 56

Досмотреть. Какая-то ерунда получилась.

Функция uncompress превращает сжатый список в исходный. Параметр:
список.
Сначала проверяем, не пустой ли список. Если пустой, возвращаем nil.
Если нет, загружаем первый элемент списка в переменную elt и
рекурсивно вызываем фунцию с остатком списка, а rest предоставит нам
остаток от остатка списка (cdr(cdr lst)).
Если elt ячейка, то вызываем list-of с elt (сколько раз повторяется
элемент?) и rest - остаток списка. Apply вернет результат вызова
функции, а append склеит результат в один список. Если же elt не
является ячейкой, то мы создадим новый список.


#+BEGIN_SRC lisp

  (defun uncompress (lst)
    (if (null lst)
        nil
        (let ((elt (car lst))
              (rest (uncompress (cdr lst))))
          (if (consp elt)
              (append (apply #’list-of elt)
                      rest)
              (cons elt rest)))))

#+END_SRC

Функция list-of формирует список. Если n ноль, то мы возвращаем nil,
в противном случае рекурсивно вызываем функцию и формируем новый
список.

#+BEGIN_SRC lisp

  (defun list-of (n elt)
    (if (zerop n)
        nil
        (cons elt (list-of (- n 1) elt))))

#+END_SRC

** Page 67

Функция должна выдать нам пару для key в заданном ассоциативном
списке (списке из точечных пар).

#+BEGIN_SRC lisp

(defun our-assoc (key alist)
(and (consp alist)
(let ((pair (car alist)))
(if (eql key (car pair))
pair
(our-assoc key (cdr alist))))))

#+END_SRC

Если alist - это ячейка, тогда мы присваиваем локальной переменной
pair первую пару списка. Если key = первому элементу списка, то
возвращаем пару. Если нет, то рекурсивно вызываем функцию с key
и остатком списка. Если список кончится, а мы ничего не нашли,
вернем nil.



** Page 68

Функция должна найти крайтчайший путь к элементу.
shortest-path принимает 3 аргумента: начальную и конченую точки,
саму сеть. Она передает функции bfs конечную точку, начальную
точку, представленную в виде списка (зачем 2 раза оборачивать?) и
саму сеть.

#+BEGIN_SRC lisp

  (defun shortest-path (start end net)
    (bfs end (list (list start)) net))

#+END_SRC

Bfs принимает 3 аргумента: конечную точку, "очередь" и саму сеть.
Затем мы проверяем, является очередь пустым списком. Если да,
возвращаем nil. Если нет, то записываем первый элемент очереди в
переменную path. А первый элемент path - в переменную node.
Видимо, первый элемент queue должен быть списоком или хотя бы
точечной парой. Затем мы проверям, равны ли node и end.
Если равны, то возвращаем элементы path в обратном порядке, чтоб
показать, через какие узлы надо пройти для достижения цели.
Если нет, то рекурсивно вызываем bfs c конечной точкой,
склеенным списком, состоящим из остатка queue и результата
вызова new_paths (новая очередь/путь), и сетью.

#+BEGIN_SRC lisp

  (defun bfs (end queue net)
    (format t " BFS end ~a queue ~a  net ~a ~&" end queue net)
    (if (null queue)
        nil
        (let ((path (car queue)))
          (let ((node (car path)))
            (format t " BFS path ~a ~& " path)
            (if (eql node end)
                (format t " reverse path ~a ~&" (reverse path))
                (bfs end
                     (append (cdr queue)
                             (new-paths path node net))
                     net))))))

#+END_SRC

new-paths принимает три аргумента: путь, узел и саму сеть.
Дальше к каждому элементу списка (какого?) будет применено
(cons n path), где n - это результат от (cdr (assoc node net)).
Assoc ищет в ассоциативных списках пару, где встречается ключ.
Затем возьмем cdr от полученного списка, потому что пройденный
узел нам уже не интересует, и к остатку писка применим функцию
внутри mapcar. То есть возьмем каждый элемент полученного списка,
подставим его вместо n и присоединим его к path.

Так мы получим новый путь, а вернее сказать, новую очередь для
функции bfs.
#+BEGIN_SRC lisp

    (defun new-paths (path node net)
      (format t " NEW-PATHS path ~a node  ~a  net ~a ~&" path node net)
      (mapcar #'(lambda (n)
                  (cons n path))
              (cdr (assoc node net))))
  ;;Запуск:

  (let ((min '((a b c) (b c) (c d))))
    (shortest-path 'a 'd min))
#+END_SRC

* Chapter 4


** page 76

Функция реализует бинарный  поиск в отсортированном
одномерном массиве (векторе)

Функция bin-search принимает два аргумента:
искомый объект и массив (вектор)
Устанавливаем длину массива в len. Если длина массива != 0,
то вызываем функцию finder, передаем ей объект, массив, начальную
и конечную точки поиска.

#+BEGIN_SRC lisp

  (defun bin-search (obj vec)
    (let ((len (length vec)))
      (and (not (zerop len))
           (finder obj vec 0 (- len 1)))))

#+END_SRC

Вычитаем из конечной точки начальную, записываем результат в
range. Если range = 0, то проверяем, равен ли объект элементу
массива. Если да, то возвращаем объект. Если нет - значит, во
всем массиве ничего не нашлось. Данная ветка может сработать,
если поиск сократился до одного элемента.

В случае, если range != 0, то мы получаем середину (mid).
Получаем элемент вектора, соответствующий mid и записываем его в
obj2. Если искомый объект меньше, чем середина, то мы "сдвигаемся
влево", вызывая finder с (mid - 1) вместо конечной точки.
В противном случае мы проверям, больше ли объект середины. Если
да, то "сдвигаемся вправо", вызывает finder c (mid + 1) вмето
начальной точки. В противном случае возвращаем сам объект, т.к.
если он не больше и не меньше средины, значит, сереина = объект.

#+BEGIN_SRC lisp

(defun finder (obj vec start end)
    (let ((range (- end start)))
      (if (zerop range)
          (if (eql obj (aref vec start))
              obj
              nil)
          (let ((mid (+ start (round (/ range 2)))))
            (let ((obj2 (aref vec mid)))
              (if (< obj obj2)
                  (finder obj vec start (- mid 1))
                  (if (> obj obj2)
                      (finder obj vec (+ mid 1) end)
                      obj)))))))

#+END_SRC
** page 83

Функция tokens разберет нашу строку на знаки. Знаками считается
все, из чего может состоять строка: буквы, цифры, знаки
препинания и т.д.

Принимает строку, ключ и начальную точку.
Проверяем первый символ сроки на соответствие ключу. Если первый
символ найден, то ищем второй.
Когда нашли второй элемент (каким образом?), вызываем cons.
Cons содеинит нам строку от первого элемента до второго и
выхов tokens со вторым элементом в качестве начальной точки.
Если рекурсивный вызов ничего не дал, возвращаем nil.

Таким образом мы полчим все символы, удовлетворяющие условию.
#+BEGIN_SRC lisp

  (defun tokens (str test start)
    (let ((p1 (position-if test str :start start)))
      (if p1
          (let ((p2 (position-if #’(lambda (c)
                                     (not (funcall test c)))
                                   str :start p1)))
            (cons (subseq str p1 p2)
                  (if p2
                      (tokens str test p2)
                      nil)))
          nil)))

#+END_SRC

Функция принимает в качестве аргумента символ.
Проверет, явяется ли он буквой. Затем, проверяем,
не является ли он пробелом.
Если это буква и не пробел, возвращаем символ.

#+BEGIN_SRC lisp


  (defun constituent (c)
    (and (graphic-char-p c)
         (not (char= c #\ ))))

#+END_SRC


** page 84

Функция преобразует строку, содержащую число в само число.

Если вся строка состоит из цифр,
#+BEGIN_SRC lisp

  (defun read-integer (str)
    (if (every #’digit-char-p str)
        (let ((accum 0))
          (dotimes (pos (length str))
            (setf accum (+ (* accum 10)
                           (digit-char-p (char str pos)))))
          accum)
        nil))

#+END_SRC

** page 89

Создание дерева.
Создаем структуру с помощью defstruct, называем ее node (узел)
Указываем, что для печати node мы будем использовать format, который
выведет нам элемент, его правый и левый потомок.

#+BEGIN_SRC lisp

  (defstruct (node (:print-function
                    (lambda (n s d)
                      (format s "#<~A>" (node-elt n)))))
    elt (l nil) (r nil))

#+END_SRC

Bst-insert как cons для списков: создает новые узлы и объединяет их в
дерево.

Функция принимает 3 аргумента: объект, дерево и функция, с помощью
которой дерево будет упорядочено.

Если дерево пустое, то создаем экземпляр структуры node и в поле
elt записываем объект (видимо, остальные поля идентичны node).
Если же дерево не пустое, то мы создаем переменную elt и записываем
в нее node-elt(видимо, поле elt конкретного узла).
Проверяем, если объект равен элементу, то возвращаем дерево.
Если же не равен, то мы проверяем:
- объект меньше элемента?
Если да, то создаем новый экземпляр node, присваиваем полю elt
значение elt, поле l (левый потомок) получает значение от рекурсивного
вызова bst-insert (в качестве объекта левый потомок node, дерево и
оператор). В поле r (правый потомок) будет записано значение парвого
поля node и само дерево.
- если предыдущая ветка ифа не сработала, значит, объект больше
  элемента
Тогда мы опять записываем в поле elt значение elt, в правый потомок
будет записан рекурсивый вызов от bst-insert, а в левый - значение
поля l из node и дерево (зачем писать дерево?)


#+BEGIN_SRC lisp

  (defun bst-insert (obj bst <)
    (if (null bst)
        (make-node :elt obj)
        (let ((elt (node-elt bst)))
          (format t "~a ~&" node-elt)
          (if (eql obj elt)
              bst
              (if (funcall < obj elt)
                  (make-node
                   :elt elt
                   :l (bst-insert obj (node-l bst) <)
                   :r (node-r bst))
                  (make-node
                   :elt elt
                   :r (bst-insert obj (node-r bst) <)
                   :l (node-l bst)))))))

#+END_SRC

Запускать надо все вместе:

#+BEGIN_SRC lisp

  (defstruct (node (:print-function
                    (lambda (n s d)
                      (format s "#<NODE:~A{~A|~A}>"
                              (node-elt n)
                              (node-r n)
                              (node-l n)
                              ))))
    elt (l nil) (r nil))

  (make-node :elt "aaa" :l 123 :r 234)


  (defun bst-insert (obj bst sortfun)
    (if (null bst)
        (make-node :elt obj :r nil :l nil)
        ;; else
        (let ((elt (node-elt bst)))
          (format t "~a ~&" elt)
          (if (eql obj elt)
              bst
              (if (funcall sortfun obj elt)
                  (progn
                    (format t "<")
                    (format t " left true ~a ~&" (node-l bst))
                    (format t " right true ~a ~&" (node-r bst))
                    (make-node
                     :elt elt
                     :l (bst-insert obj (node-l bst) sortfun)
                     :r (node-r bst)))
                  ;; else
                  (format t ">")
                  ;; (make-node
                  ;;  :elt elt
                  ;;  :r (bst-insert obj (node-r bst) sortfun)
                  ;;  (format t "right false ~a ~&" (node-r bst))
                  ;;  :l (node-l bst)
                  ;;  (format t "left false ~a ~&" (node-l bst)))
                  ))
          )))

  ;; (let ((nums))
  ;;   (dolist (x '(5 8 4 2 1 9 6 7 3))
  ;;     (setf nums (bst-insert x nums #'<))))


  (let ((var1 nil))
    (let ((var2 (bst-insert 1 var1 #'<)))
      (bst-insert 2 var2 #'<)))

  C-c ' ;; open code
  C-x e ;; execute
#+END_SRC

Bst-find ищет элемент в дереве и если находит,
то возвращает его поддерево. В противном случае возвращается nil.

Если дерево пустое, возвращаем nil.
В противном случае записываем в переменную elt узел дерева. Проверяем,
является ли искомый объект элементом из узла. Если да, то возвращаем
поддерево. Если нет, то рекурсивно вызываем bst-find в зависимости от
того, какая ветка ифа сработала.

#+BEGIN_SRC lisp

  (defun bst-find (obj bst <)
    (if (null bst)
        nil
        (let ((elt (node-elt bst)))
          (if (eql obj elt)
              bst
              (if (funcall < obj elt)
                  (bst-find obj (node-l bst) <)
                  (bst-find obj (node-r bst) <))))))

#+END_SRC


#+BEGIN_SRC lisp

  (defun bst-remove (obj bst <)
    (if (null bst)
        nil
        (let ((elt (node-elt bst)))
          (if (eql obj elt)
              (percolate bst)
              (if (funcall < obj elt)
                  (make-node
                   :elt elt
                   :l (bst-remove obj (node-l bst) <)
                   :r (node-r bst))
                  (make-node
                   :elt elt
                   :r (bst-remove obj (node-r bst) <)
                   :l (node-l bst)))))))

#+END_SRC

* Chapter 5

#+BEGIN_SRC lisp

  (let ((x ’a))
    (do ((x 1 (+ x 1))
         (y x x))
        ((> x 5))
      (format t "(~A ~A) " x y)))

  (defun show-squares (start end)
    (do ((i start (+ i 1)))
        ((> i end) ’done)
      (format t "~A ~A~%" i (* i i))))

#+END_SRC

#+BEGIN_SRC lisp
  ;; устанавливаем константы
  ;; этот вектор показывает, сколько дзней проходит от начала года
  ;; до соответствующего месяца
  (defconstant month
    #(0 31 59 90 120 151 181 212 243 273 304 334 365))

  ;; устанваливаем константу yzerop
  ;; ее значение - двухтычатный год

  (defconstant yzero 2000)

  ;; функция leap? принимает год в качестве параметра и проверяет,
  ;; не високосный ли он
  ;; год високосный если:
  ;; - кратен 4
  ;; - либо кратен 400 или не кратен 100

  (defun leap? (y)
    (and (zerop (mod y 4))
         (or (zerop (mod y 400))
             (not (zerop (mod y 100))))))

  ;; преобразовывает дату в целое число
  ;; функция принимает день, месяц и год
  ;; складываем день (со вчерашнего дня), соответствующий месяц, прибавив к нему 1,
  ;; если год високосный и искомый месяц после февраля, и количество дней от двухтысячного
  ;; года до первого января текущего года

  (defun date->num (d m y)
    (+ (- d 1) (month-num m y) (year-num y)))

  ;; отнимаем от месяца один, чтоб не считать текущий месяц,
  ;; если год високосный, прибавляем к количеству дней, если нет, то 0

  (defun month-num (m y)
    (+ (svref month ( - m 1))
       (if (and (> m 2) (leap? y))
           1
           0)))

  (defun year-num (y)
    (let ((d 0))
      (if (>= y yzero)
          (dotimes (i (- y yzero)
                    (incf d (year-days (+
                                        (dotimes (i (- yzero y)
                                                  (incf d (year-days (+
                                                                      d)
                                                                     yzero i))))
                                        (- d))
                                       y i)))))))
  (defun year-days (y) (if (leap? y) 366 365))
#+END_SRC
* Chapter 6

#+BEGIN_SRC lisp
  ;;Функция может принимать любое количество аргументов (все они будут загружены в fns
  ;; благодаря &rest)



  (defun compose (&rest fns)
    (destructuring-bind (fn1 . rest) (reverse fns)
      #’(lambda (&rest args)
          (reduce #’(lambda (v f) (funcall f v))
                    rest
                    :initial-value (apply fn1 args)))))

  (defun disjoin (fn &rest fns)
    (if (null fns)
        fn
        (let ((disj (apply #’disjoin fns)))
          #’(lambda (&rest args)
              (or (apply fn args) (apply disj args))))))
  (defun conjoin (fn &rest fns)
    (if (null fns)
        fn
        (let ((conj (apply #’conjoin fns)))
          #’(lambda (&rest args)
              (and (apply fn args) (apply conj args))))))
#+END_SRC

* Chapter 7

Почему потоки у read-line и format различаются?
Зачем  (read-line str nil 'eof) написано дважды?

#+BEGIN_SRC lisp

  ;; функция печатает файл
  ;; аргумент - файл, который надо распечатать построчно
  (defun pseudo-cat (file)
    ;; открываем поток для чтения файла (и сам файл ?)
    (with-open-file (str file :direction :input)
      ;; запускаем цикл, который будет грузить в переменную line
      ;; каждую строку файла по очереди
      ;; условие завершения цикла: line = eof (?)
      (do ((line ;; this is VAR
            (read-line str nil 'eof) ;; this is INIT
            (read-line str nil 'eof) ;; this is STEP
            ))
          ((eql line 'eof))
        ;; вывод строки
        (format t "~A~%" line))))

  ;; (pseudo-cat "go3.sh")
#+END_SRC

[COMMENT:gmm] Как написано, например тут:
http://filonenko-mikhail.github.io/cltl2-doc/ru/clmse42.html#x54-860007.8.2
В общем виде DO выглядит так:

#+BEGIN_SRC lisp
  (do ((var1 init1 step1)
       (var2 init2 step2)
       ...
       (varn initn stepn))
      (end-test . result)
   {declaration}*
      . tagbody)
#+END_SRC

Таким образом вторая запись (read-line str nil 'eof) соответствует STEP. На каждом шаге
будет выполняться форма STEP и ее результат будет записан в переменную.

#+BEGIN_SRC lisp

  ;; создаем структуру buf
  ;; ее поля - это ветор и его индексы (поэтому все значения - 1, индекс начинается с нуля)
  (defstruct buf
    vec (start -1) (used -1) (new -1) (end -1))

  ;; bref позволяет получить значение по заданному индексу
  (defun bref (buf n)
    ;; получаем вектор из поля структуры и индекс, поделив заданный индекс на размер буфера
    ;; зачем делить?), и все это передаем svref, что  вернет элемент
    (svref (buf-vec buf)
           (mod n (length (buf-vec buf)))))

  ;; обратная операция: кладем элемент по индексу
  (defun (setf bref) (val buf n)
    (setf (svref (buf-vec buf)
                 (mod n (length (buf-vec buf))))
          val))
  ;; создаем кольцевой буфер заданного размера
  (defun new-buf (len)
    (make-buf :vec (make-array len)))

  ;; функция добавляет элемент к буферу, аргументы: элемент и буфер
  ;; сначала передаем функции bref буфер и инкрементированный индекс end, затем setf запишет
  ;; по этому индексу значение x
  (defun buf-insert (x b)
    (setf (bref b (incf (buf-end b))) x))

  ;; обратная операция: стираем элемент из вектора
  (defun buf-pop (b)
    (prog1
        (bref b (incf (buf-start b)))
      (setf (buf-used b) (buf-start b)
            (buf-new b) (buf-end b))))

  ;; чтение следующего элемента из буфера без его извлечения
  (defun buf-next (b)
    (when (< (buf-used b) (buf-new b))
      (bref b (incf (buf-used b)))))

#+END_SRC


#+BEGIN_SRC lisp

  ;; file-subst принимает на вход 4 аргумента:
  ;; строку, подлежащую замене, строку, которая заменит старую, файл,
  ;; входной и выходной файлы.
  (defun file-subst (old new file1 file2)
    ;; открываем потоки между файлами: читаем из  file1, пишем в file2
    (with-open-file (in file1 :direction :input)
      (with-open-file (out file2 :direction :output
                           :if-exists :supersede)
        ;; вызываем алгоритм замены строк
        (stream-subst old new in out))))

  (defun stream-subst (old new in out)
    ;; устанавливаем переменные: позицию, длину старой строки, новый буфер,
    ;; и from-buf (в эту переменную будут читаться чимволы из промежуточного буфера)
    (let* ((pos 0)
           (len (length old))
           (buf (new-buf len))
           (from-buf nil))

      ;; в переменную цикла "с" записывается символ из файла in,
      ;; условие завершения цикла - конец файла. На каждой итерации в переменную
      ;; "с" попадет либо содержимое from-buf (т.e следующий символ из буфера),
      ;;  либо следующий символ из файла (смотря, что окажется истинным)

      (do ((c (read-char in nil :eof)
              (or (setf from-buf (buf-next buf))
                  (read-char in nil :eof))))
          ((eql c :eof))

        ;; "с" = символу из строки old с заданным индексом?
        (cond ((char= c (char old pos))
               ;; Да!
               ;; инкрементируем pos
               (incf pos)
               ;; pos = len?
               (cond ((= pos len)
                      ;; Да! (строки совпали!)  ; 3
                      ;; печатаем новую строку в выходной файл
                      (princ new out)
                      ;; устанавливаем индекс в 0 снова
                      (setf pos 0)
                      ;; очищаем промежуточный буфер
                      (buf-clear buf))

                     ;; pos != len (продолжаем сравнивать строки)
                     ;; если from-buf пустой (?)
                     ((not from-buf)             ;2
                       ;; добавляем текщий элемент в промежуточный буфер
                      (buf-insert c buf))))

              ;; "с" != символу из старой строки
              ;; проверяем pos на 0 (вдруг раньше символы совпадали?)
              ((zerop pos)    ;; 1
               ;; pos = 0!
               ;; сразу печатаем символ в выходной файл
               (princ c out)
               ;; если в from-buf что-то было
               ;; все очищаем
               ;;(иначе при следующих проверках и печатях будут
               ;; печататься и проверяться старые, ненужные символы)
               (when from-buf
                 (buf-pop buf)
                 (buf-reset buf)))

              (t                 ;;4
               ;; если в from-buf нет ничего
               (unless from-buf
                 ;; добавляем символ в буфер
                 (buf-insert c buf))
               ;; эм, что?
               (princ (buf-pop buf) out)
               ;; очищаем буфер
               (buf-reset buf)
               ;; устанавливаем индекс в 0
               (setf pos 0))))
      ;; после того как цикл отработал, сливаем остаток из буфера в выходной файл
      (buf-flush buf out)))

#+END_SRC

* chapter 8

Пример: генерация случайного текста

#+BEGIN_SRC lisp
  ;; хэш-таблица для прочитанного абзаца
  (defparameter *words* (make-hash-table :size 10000))

  ;; максимум в абзаце может быть 100 слов
  (defconstant maxword 100)

  ;;чтение текста
  ;; на вход получаем путь к тексту
  (defun read-text (pathname)
    ;; открываем файл на чтение
    (with-open-file (s pathname :direction :input)
      ;; создаем буфер исходя из идеи, что в обзаце 100 слов
      (let ((buffer (make-string maxword))
            ;; устанавливаем индекс
            (pos 0))
        ;; цикл обеспечит чтение текст посимвольно (не путать символы-буквами
        ;; с символами-идентификаторами, видимо, недоработка переводчика)
        ;; условие конца цткла - конец файла
        (do ((c (read-char s nil :eof)
                (read-char s nil :eof)))
            ((eql c :eof))
          ;; если считанный знак буква или апостроф
          (if (or (alpha-char-p c) (char= c #\'))
              ;; записываем его в буфер и инкрементируем индекс
              (progn
                (setf (aref buffer pos) c)
                (incf pos))
              ;; считанный знак != буква или апостроф, слово кончилось
              ;; pos = 0?
              (progn
                (unless (zerop pos)
                  ;; нет
                  ;; накопленное слово превращаем в символ (тот, что заглавными буквами
                  ;; пишется, символ-идентификатор)
                  (see (intern (string-downcase
                                (subseq buffer 0 pos))))
                  ;; устанавливаем индекс в 0
                  (setf pos 0))
                ;; если символ = знак пунктупции, то punc выдаст нам его как есть
                (let ((p (punc c)))
                  ;; что значит этот иф?
                  (if p (see p)))))))))

  (defun punc (c)
    (case c
      (#\. '|.|) (#\, '|,|) (#\; '|;|)
      (#\! '|!|) (#\? '|?|) ))
  ;; фнукция see полученный символ запишет в таблицу слов
  ;; так же она "помнит" предыдущее слово с помощью prev. По умолчанию prev - это точка.

  (let ((prev '|.|))
    ;; получаем на вход символ
    (defun see (symb)
      ;; устанавливаем пару символ-ключ.В нашем варианте это предудыщее слово - текущее слово
      ;; устанавливаем пару
      (let ((pair (assoc symb (gethash prev *words*))))
        ;; пара пустая?
        (if (null pair)
            ;; зачит, это первое слово в таблице, таки запишем (слово. 1)
            (push (cons symb 1) (gethash prev *words*))
            ;; в противном случае инкрементируем cdr образовавшейся пары
            ;; (получилось (слово . 2)
            (incf (cdr pair))))
      ;; устанавливаем текущий символ в prev
      (setf prev symb)))

  ;; а вот эта часть обеспечит саму генерацию текста

  (defun generate-text (n &optional (prev ’|.|))
    (if (zerop n)
        (terpri)
        (let ((next (random-next prev)))
          (format t "~A " next)
          (generate-text (1- n) next))))
  (defun random-next (prev)
    (let* ((choices (gethash prev *words*))
           (i (random (reduce #’+ choices
                                :key #’cdr))))
      (dolist (pair choices)
        (if (minusp (decf i (cdr pair)))
            (return (car pair))))))
#+END_SRC


* Chapter 9

#+BEGIN_SRC lisp
  ;;возвращает квадрат числа
  (defun sq (x)
    (* x x))
  ;; возвращает длину ветора по трем компонентам
  (defun mag (x y z)
    (sqrt (+ (sq x) (sq y) (sq z))))

  (defun unit-vector (x y z)
    (let ((d (mag x y z)))
      (values (/ x d) (/ y d) (/ z d))))

  (defstruct (point (:conc-name nil))
    x y z)

  (defun distance (p1
                   (mag (- (x p1) (x
                                   (- (y p1) (y
                                              (- (z p1) (z
                                                         p2)
                                                 p2))
                                      p2))
                           p2))))

  (defun minroot (a b c)
    (if (zerop a)
        (/ (- c) b)
        (let ((disc (- (sq b) (* 4 a c))))
          (unless (minusp disc)
            (let ((discrt (sqrt disc)))
              (min (/ (+ (- b) discrt) (* 2 a))
                   (/ (- (- b) discrt) (* 2 a))))))))

#+END_SRC

* Chapter 12

Реализация очереди:

#+BEGIN_SRC lisp

  ;; делаем пустую точечную пару
  (defun make-queue () (cons nil nil))

  ;; принимает объект и очередь
  (defun enqueue (obj q)
    ;; очередь пустая?
    (if (null (car q))
        ;;Да!
        ;; в конец (cdr) очереди устанавливаем список, сохраненный
        ;; в начало очереди
        (setf (cdr q) (setf (car q) (list obj)))
        ;; Нет!
        ;; в хвост очереди останавливаем список,
        ;; в начало устанавливаем хвост
        (setf (cdr (cdr q)) (list obj)
              (cdr q) (cdr (cdr q))))
    ;; возвращаем начало очереди
    (car q))

  (defun dequeue (q)
    (pop (car q)))

#+END_SRC

Реализация двусвязного списка и функция для оперирования с ним:

#+BEGIN_SRC lisp
  ;; ячейка двусвязного списка: next = cdr, prev = указатель на предыдущий элемент,
  ;; data = содержимое ячейки
  (defstruct (dl (:print-function print-dl))
    prev data next)

  ;;печатает ячкйку, принимает ячейку, поток и ...(?)
  (defun print-dl (dl stream depth)
    (declare (ignore depth))
    (format stream "#<DL ~A>" (dl->list dl)))

  ;; возвращает двусвязный список
  (defun dl->list (lst)
    (if (dl-p lst)
        (cons (dl-data lst) (dl->list (dl-next lst)))
        lst))

  ;; вставляет ячейку в двусвязный список
  (defun dl-insert (x lst)
    ;; создаем ячейку, где содержимое X, а cdr - lst
    (let ((elt (make-dl :data x :next lst)))
      ;; если lst двусвязный список
      (when (dl-p lst)
        ;; и при этом car этого списка указывает на какое-то предыдущее значение
        ;; т.е. мы не в начале списка
        (if (dl-prev lst)
            ;; то вставляем elt в список
            (setf (dl-next (dl-prev lst)) elt
                  (dl-prev elt) (dl-prev lst)))
        ;; в противном случае устанавливаем elt в начало списка
        (setf (dl-prev lst) elt))
      elt))

  (defun dl-list (&rest args)
    (reduce #’dl-insert args
              :from-end t :initial-value nil))

  (defun dl-remove (lst)
    (if (dl-prev lst)
        (setf (dl-next (dl-prev lst)) (dl-next lst)))
    (if (dl-next lst)
        (setf (dl-prev (dl-next lst)) (dl-prev lst)))
    (dl-next lst))
#+END_SRC
* Chapter 15

#+BEGIN_SRC lisp
  ;; сравнивает 2 дерева на совпадения. Если совпадения найдены, match возвращает их в виде
  ;; ассоциативного списка

  (defun match (x y &optional binds)
    ;;(format t "~% binds are ~A" binds)
    (cond
      ;; если x = y, возвращаем связи и t
      ((eql x y)
       ;; (progn
       ;;   (format t "~% 1")
         (values binds t))
       ;;)
      ;; если какое-то зачение из binds соответствует X, находим его с помощью binding
      ;; и рекурсивно вызываем match, чтоб сопоставить полученный результат с Y
      ((assoc x binds)
       ;; (progn
       ;;   (format t "~% 2")
         (match (binding x binds) y binds))
       ;;)
      ;; если какое-то зачение из binds соответствует Y, находим его с помощью binding
      ;; и рекурсивно вызываем match, чтоб сопоставить полученный результат с X
      ((assoc y binds)
       ;; (progn
       ;;   (format t "~% 3")
         (match x (binding y binds) binds))
       ;;)
      ;; если Х переменная, не ассоциированная ни с каким значением, возвращаем точечную
      ;; пару и t.
      ((var? x)
       ;; (progn
       ;;   (format t "~% 4")
         (values (cons (cons x y) binds) t))
       ;;)
      ;; если Y переменная, не ассоциированная ни с каким значением, возвращаем точечную
      ;; пару и t
      ((var? y)
       ;; (progn
       ;;   (format t "~% 5")
         (values (cons (cons y x) binds) t))
       ;;)
      (t
       ;; если же Y и X ячейки, то сначала сопоставляем их car, и если сопоставление
       ;; найдено, сравниваем их cdr
       (when (and (consp x) (consp y))
         ;; (progn
         ;;   (format t "~% 6")
           (multiple-value-bind (b2 yes)
               (match (car x) (car y) binds)
             (and yes (match (cdr x) (cdr y) b2)))))))
  ;;)

  ;; проверяет, является ли ее аргумент переменной
  ;; если аргумент = символ лиспа, начинающийся с вопросительного знака,
  ;; значит аргумент = переменная
  (defun var? (x)
    (and (symbolp x)
         (eql (char (symbol-name x) 0) #\?)))

  ;; проверяет, если ли еще ассоциированные значения к cdr полученной пары
  ;; это делается, чтоб найти даже косвенные связи
  (defun binding (x binds)
    ;;(format t "~% binding x ~A binds ~A" x binds)
    (let ((b (assoc x binds)))
      (if b
          ;; (progn
          ;;   (format t "~% B is ~A" b)
            (or (binding (cdr b) binds)
                (cdr b)))))
  ;;)
  ;; запуск
  ;; (match '(p ?v b ?x d (?z ?z))
  ;;   '(p a ?w c ?y ( e e)))

  ;; таблица правил. Правила выглядят как (<- заголовок тело), где заголовок - это консеквен,
  ;; а тело - антецедент. Т.е. заголовок = следствие, тело = причина
  (defvar *rules* (make-hash-table))

  ;; определяет правило, пушит его в таблицу с правилами и возвращает номер этого правила
  (defmacro <- (con &optional ant)
    `(length (push (cons (cdr ',con) ',ant)
                   (gethash (car ',con) *rules*))))
  ;; определяем правило (<- (father ?x ?y) (and (parent ?x ?y) (male ?x)))
  ;; макрос раскрывается в:
  ;; (length (push (cons (cdr 'con) 'ant)
  ;;               (gethash (car 'con) *rules*)))
  ;; con = '(father ?x ?y), ant = '(and (parent ?x ?y) (male ?x))
  ;; father, parent и male - предикаты (видимо, определенные ранее)
  ;; (cons (cdr 'con) 'ant) = ((?x ?y) and (parent ?x ?y) (male ?x))
  ;; затем получаем из таблицы правил значение, ассоциированное с 'father и
  ;; пушим получившееся правило в него (puthash)


  ;; Эта функция ищет все правила с истинным предикатом (что значит истинный предикат
  ;; в данном контексте?) и пытается сопоставить заголовок (в нем содержится следствие)
  ;; каждого из них с фактом (правило, содержащее только заголовок), который мы хотим
  ;; доказать. Затем для каждого совпавшего заголовка доказывается его тело с учетом новых
  ;; связей, созданных match. Вызовы prove возвращают списки связей, которые затем
  ;; собираются mapcan.

  ;; мы ищем все правила, которым мог бы соответствовать данный факт. Для
  ;; этого сравниваем на совпадения факт и заголовок правила. И если правило подходит для
  ;; данного факта, т.е. сопоставление произошло, мы получаем связи, которые показывают, где
  ;; именно произошло сопоставление. После этого вычисляем тело правила с новыми связями(?).

  (defun prove (expr &optional binds)
    ;; сравниваем первый элемент expr с логическими операторами
    (format t "~% expr  ~A" expr)
    (case (car expr)
      (and (prove-and (reverse (cdr expr)) binds))
      (or (prove-or (cdr expr) binds))
      (not (prove-not (cadr expr) binds))
      ;; если expr начинается не с логического оператора, вызываем prove-simple
      (t
       (progn
         (format t "~% t")
       (prove-simple (car expr) (cdr expr) binds)))))

  ;; принимает предикат, аргументы и связи
  (defun prove-simple (pred args binds)
    ;; mapcan имеет 2 аргумента: список, который вернет лямбда, и список, который вернет
    ;; mapcar. Mapcar вернет список результатов вызова change-vars для каждого элемента
    ;; списка, который вернет (gethash pred *rules*)
    ;; аргумент лямбды - правило, возвращенное gethash из таблицы (?)
    (format t "~% pred ~A args ~A bids ~A" pred args binds)
    (mapcan #'(lambda (r)
                (format t " ~% r in lambda ~A" r)
                (multiple-value-bind (b2 yes)
                    ;;ищем совпадение между первым элементов правила и аргументами
                    (match args (car r) binds)
                  ;; если совпадение есть
                  (when yes
                    ;; и при этом cdr правила (тело правила) истинно, т.е. там не nil
                    ;; а значит, это именно правило, а не факт
                    (if (cdr r)
                        ;; доказываем тело, передавая в prove тело и связи
                        (prove (cdr r) b2)
                        (list b2)))))
            (mapcar #'change-vars
                    ;; вернет правило, соответствующее предикату из таблицы
                    (gethash pred *rules*))))
  ;; меняет переменные на gensym, чтоб они не перекрывали друг друга в разных правилах или в
  ;; вызове одного и того же правило рекурсивно
  (defun change-vars (r)
    (format t "~% r ~A in  change-vars" r)
    ;; sublis принимает ассоциативный список и дерево. Возвращает дерево, но каждое поддерево
    ;; совпадающее с ключом ассоциативного списка, заменяется на соответствующее ему
    ;; значение.
    ;; В данном примере sublis получит список переменных, возвращенный mapcar (наш alist)
    ;; и исходный список переменных (tree)
    (format t "~% sublis ~A"
    (sublis (mapcar #'(lambda (v)

                        (cons v (gensym "?")))
                    (vars-in r))
            r))
    (sublis (mapcar #'(lambda (v)
                        (format t "~% v ~A in  change-vars" v)
                        (cons v (gensym "?")))
                    (vars-in r))
            r))
  ;; принимает выражение
  ;; возвращает список переменных в нем
  (defun vars-in (expr)
    (format t "~% expr ~A in vars-in" expr)
    ;; если выражение атом
    (if (atom expr)
        ;; и при этом переменная
        (if (var? expr)
            ;; обернем ее в список
            (list expr))
        ;; в противном случае вызываем union,
        ;; который вернет в списке резульятат вызова vars-in для всех элементов expr
        ;; без повторяющихся элементов
        (union (vars-in (car expr))
               (vars-in (cdr expr)))))

  ;;(gethash 'parent *rules*)
  ;; сработает в случае, если clauses (условие) начинается с логического оператора and
  ;; будет проверять истинность первого выражения для каждого набора связей (не очень
  ;; понятно, как?)
  (defun prove-and (clauses binds)
    ;; если clauses пустой
    (format t "~% clauses ~A" clauses)
    (if (null clauses)
        ;; возвращаем связи
        (list binds)
        ;; в противном случае вызовем prove-and c cdr текущего условия и будем повторять
        ;; вызов до тех пор, пока не сработает условие завершение рекурсии (пустое условие)
        ;; тогда результат вызова (список связей) будет отправлен в аргумент b лямбды
        ;; ---- (зачем нам такая рекурсия?)---
        (mapcan #'(lambda (b)
                    (prove (car clauses) b))
                  (prove-and (cdr clauses) binds))))

  ;; собираем все связи, полученные из каждого выражения с or (зачем и как?)
  (defun prove-or (clauses binds)
    (mapcan #'(lambda (c)
                (format t "~% c prove-or ~A" c)
                (prove c  binds))
              clauses))

  (defun prove-not (clause binds)
    ;; если prove вернет false (как?)
    (unless (prove clause binds)
      ;; возвращаем список связей
      (list binds)))

  ;; осуществляет запуск всей программы
  (defmacro with-answer (query &body body)
    ;; этот let отработает на стадии макрораскрытия, сгенерит 2 локальные переменные
    (let ((binds (gensym)))
      `(dolist (,binds (prove ',query))
         ;; этот let тоже отработает на стади макрораскртия
         ;; сначала вызовем vars-in с выражением
         ;; vars-in вернет список переменных в выражении
         ;; затем этот список попадет в аргумент V лямбды
         ;;------стадия макрораскрытия закончена----
         ;; (DOLIST (#:G954 (PROVE '(PARENT ?X ?Y)))
         ;;   (LET ((?Y (BINDING '?Y #:G954)) (?X (BINDING '?X #:G954)))
         ;;     (FORMAT T "~A is the father of ~A.~%" ?X ?Y)))
         ;; вызываем prove с выражением (prove вернет полученные связи, т.е. места, в которых
         ;; могут совпадать факт и заголовок правила)
         ;; с помощью binding мы проверим, если ли у переменной косвенные связи,
         ;; результат будет записан в саму переменную. Затем полученный результат выведем
         ;; форматом (пример расписан для вызова ниже)
         (let ,(mapcar #'(lambda (v)
                           `(,v (binding ',v ,binds)))
                         (vars-in query))
           ,@body))))

  ;; расписан этот пример
  (with-answer (parent ?x ?y)
    (format t "~A is the father of ~A.~%" ?x ?y))

  (clrhash *rules*)

  (<- (parent donald nancy))
  (<- (parent donald debby))
  (<- (parent ?x ?y))

  (macroexpand-1 '(with-answer (parent ?x ?y)
    (format t "~A is the father of ~A.~%" ?x ?y)))

#+END_SRC

* Chapter 16


#+BEGIN_SRC lisp
  ;; макросы для определения утилит HTML

  ;; принимает строку и метку
  ;; печатает строку, окруженную метками
  (defmacro as (tag content)
    `(format t "<~(~A~)>~A</~(~A~)>"
             ',tag ,content ',tag))

  ;; принимает метку и тело кода
  ;; исполняет код и выводит его результат между напечатанными метками
  (defmacro with (tag &rest body)
    `(progn
       (format t "~&<~(~A~)>~%" ',tag)
       ,@body
       (format t "~&<~(~A~)>~%" ',tag)))

  ;; генерирует разрыв строки
  (defun brs (&optional (n 1))
    (fresh-line)
    (dotimes (i n)
      (princ "<br>"))
    (terpri))

  ;; присоединяет к файлу расширение html
  (defun html-file (base)
    (format nil "~(~A~).html" base))

  ;; принимает имя файла, заголовок и опционально тело
  (defmacro page (name title &rest body)
    ;; на стадии макрораскрытия генерим переменную ti
    (let ((ti (gensym)))
      ;; ------ после макрораскрытия------
      ;; откываем поток вывод (вывод стандартный)
      ;; (теперь поток связан с нашим html-файлом
      `(with-open-file (*standard-output*
                        (html-file ,name)
                        :direction :output
                        :if-exists :supersede)
         (let ((,ti ,title))
           ;; выводим заголовок
           (as title ,ti)
           ;; выводим результат вызова макроса as (выводит тот же заголовок крупным шрифтом)
           (with center
                 (as h2 (string-upcase ,ti)))
           ;; 3 пустые строки
           (brs 3)
           ;; исполняем остальной код
           ,@body))))
  ;; создаем ссылку
  ;; принимает путь к каталогу и код
  (defmacro with-link (dest &rest body)
    `(progn
       (format t "<a href=\"~A\">" (html-file ,dest))
       ,@body
       (princ "</a>")))

  ;; создает элемент списка (обычного, не в лисп-смысле) как ссылку
  (defun link-item (dest text)
    (princ "<li>")
    (with-link dest
      (princ text)))

  ;; создает кнопку (в основе все та же ссылка)
  (defun button (dest text)
    (princ "[ ")
    (with-link dest
      (princ text))
    (format t " ]~%"))

  ;; принимает функцию с 3мя аргументами и список. Функция применяется для текущего,
  ;; предыдущего и последющего элемента. В случае, если предыдущий и/или последующий
  ;;элементы отсутствуют, вместо них будет выведен nil
  (defun map3 (fn lst)
    ;; labels позволяет внутри своей области видимсти определять функции и тут же их
    ;; использовать
    (labels ((rec (curr prev next left)
               (funcall fn curr prev next)
               (when left
                 (rec (car left)
                      curr
                      (cadr left)
                      (cdr left)))))
      (when lst
        (rec (car lst) nil (cadr lst) (cdr lst)))))
#+END_SRC

Генерация  страниц сайта на "HTML"

#+BEGIN_SRC lisp

  (defparameter *sections* nil)

  ;; пункт
  (defstruct item
    id title text)
  ;; раздел
  (defstruct section
    id title items)

  ;; макрос, создающий пункт
  ;; id - это уникальное имя пункта
  ;; title - заголовок текста
  (defmacro defitem (id title text)
    `(setf ,id
           (make-item :id ',id
                      :title ,title
                      :text ,text)))

  ;; макрос, создающий разделы
  ;; (опционально может содержать пункты)
  ;; id - это уникальное имя раздела
  ;; title - заголовок текста
  (defmacro defsection (id title &rest items)
    `(setf ,id
           (make-section :id
                         ’,id
                          :title ,title
                          :items (list ,@items))))

  ;; сохранение разделов
  (defun defsite (&rest sections)
    (setf *sections* sections))

  (defconstant contents "contents")

  (defconstant index
    "index")

  ;; генерирует оглавление
  (defun gen-contents (&optional (sections *sections*))
  ;; вызываем макрос page (создает страницу)
    (page contents contents
          ;; вызываем макрос with, который выведет результат исполнения кода между
          ;; метками (в нашем случае макрос with вернет список ссылок-пунктов)
          (with ol
                (dolist (s sections)
                  (link-item (section-id s) (section-title s))
                  (brs 2))
                (link-item index (string-capitalize index)))))

  ;; генерирует оглавление раздела (?)
  (defun gen-index (&optional (sections *sections*))
    (page index index
          (with ol
                (dolist (i (all-items sections))
                  (link-item (item-id i) (item-title i))
                  (brs 2)))))

  ;; получение всех пунктов из раздела
  (defun all-items (sections)
    (let ((is nil))
      (dolist (s sections)
        ;; получаем пункты из раздела
        (dolist (i (section-items s))
          ;; упорядочиваем их
          (setf is (merge 'list (list i) is #'title<))))
      is))

  ;; сравнивает заголовки(?)
  ;; видимо, чтоб быть уверенным, что материал принадлежит одному пункту или разделу
  (defun title< (x y)
    (string-lessp (item-title x) (item-title y)))

  ;; создание сайта
  (defun gen-site ()
    (map3 #'gen-section *sections*)
    (gen-contents)
    (gen-index))

  ;; создание раздела
  (defun gen-section (sect <sect sect>)
    ;; создаем страницу раздела
    (page (section-id sect) (section-title sect)
          ;; создаем список пунктов
          (with ol
                (map3 #'(lambda (item <item item>)
                          ;; генерим ссылку на текущий пункт
                          (link-item (item-id item)
                                     (item-title item))
                          (brs 2)
                          (gen-item sect item <item item>))
                      ;; возвращает список пунктов раздела
                      (section-items sect)))
          (brs 3)
          ;; генерит кнопки перехода
          (gen-move-buttons
           ;; если задан предыдущий раздел, кнопка "назад" будет указывать на него
           (if <sect (section-id <sect))
           ;; кнопка "наверх" будет указывать на оглавление
           contents
           ;; если задан следующий раздел, кнопка "вперед" будет указывать на него
           (if sect> (section-id sect>)))))

  ;; создание пункта
  ;; принимает текущий раздел, структуру пункта и структуры пунктов до и после текущего
  ;; возвращает страницу пункта
  (defun gen-item (sect item <item item>)
    ;; генерим страницу пункта
    (page (item-id item) (item-title item)
          ;; печатаем в нее текст
          (princ (item-text item))
          ;; пропускаем 3 строки
          (brs 3)
          ;; генерим кнопки перехода
          (gen-move-buttons
           ;; если задан предыдущий пункт, кнопка "назад" будет указывать на него
           (if <item (item-id <item))
           ;; кнопка "наверх" указывает на наало раздела
           (section-id sect)
           ;; если задан следующий пункт, кнопка "вперед" будет указывать на него
           (if item> (item-id item>)))))

  ;; генерит 3 кнопки
  (defun gen-move-buttons (back up forward)
    (if back (button back "Back"))
    (if up (button up "Up"))
    (if forward (button forward "Forward")))
#+END_SRC
