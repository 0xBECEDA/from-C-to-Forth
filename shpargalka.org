#+STARTUP: showall indent hidestars


* Chapter 3
** Page 55

Функция принимает параметр x. Проверяет, является ли он ячейкой.
Если да, то вызывает фнкцию compr, котораяпринимает 3 параметра:
последний повстречавшийся элемент, число его повторений и
остаток списка. Если же X ячейкой не является, мы просто
вернем его.


#+BEGIN_SRC lisp

  (defun compress (x)
    (if (consp x)
        (compr (car x) 1 (cdr x))
        x))

#+END_SRC


Функция compr должна вернуть нам сжатое продставление списка.
Сначала проверяем, не пустой ли остаток нашего списка (lst).
Если пустой, то вызываем n-elts, которая сожмет наш список. Если
lst не пустой, то мы берем первый элемент списка и записываем его
в локальную переменную next. Смотрим, одинаков ли первый элемент
списка и переменная. Если да, то рекурсивно вызываем compr,
инкрементировав n и в качестве lst подставив его остаток.
Если next и первый элемент списка не равны, то вызываем n-elts и
результат записываем в новый список. А потом снова рекурсивно
вызываем compr, чтоб проверить остальные элементы списка.

#+BEGIN_SRC lisp

  (defun compr (elt n lst)
    (if (null lst)
        (list (n-elts elt n))
        (let ((next (car lst)))
          (if (eql next elt)
              (compr elt (+ n 1) (cdr lst))
              (cons (n-elts elt n)
                    (compr next 1 (cdr lst)))))))

#+END_SRC

Функция n-elts проверяет, встретился ли элемент более одного раза.
Если да, то формируется новый список, который показыаает
сколько раз встретился элемент. Если элемент встретился один или
менее раз, то мы просто его возвращаем.

#+BEGIN_SRC lisp

  (defun n-elts (elt n)
    (if (> n 1)
        (list n elt)
        elt))
#+END_SRC
** Page 56

Досмотреть. Какая-то ерунда получилась.

Функция uncompress превращает сжатый список в исходный. Параметр:
список.
Сначала проверяем, не пустой ли список. Если пустой, возвращаем nil.
Если нет, загружаем первый элемент списка в переменную elt и
рекурсивно вызываем фунцию с остатком списка, а rest предоставит нам
остаток от остатка списка (cdr(cdr lst)).
Если elt ячейка, то вызываем list-of с elt (сколько раз повторяется
элемент?) и rest - остаток списка. Apply вернет результат вызова
функции, а append склеит результат в один список. Если же elt не
является ячейкой, то мы создадим новый список.


#+BEGIN_SRC lisp

  (defun uncompress (lst)
    (if (null lst)
        nil
        (let ((elt (car lst))
              (rest (uncompress (cdr lst))))
          (if (consp elt)
              (append (apply #’list-of elt)
                      rest)
              (cons elt rest)))))

#+END_SRC

Функция list-of формирует список. Если n ноль, то мы возвращаем nil,
в противном случае рекурсивно вызываем функцию и формируем новый
список.

#+BEGIN_SRC lisp

  (defun list-of (n elt)
    (if (zerop n)
        nil
        (cons elt (list-of (- n 1) elt))))

#+END_SRC

** Page 67

Функция должна выдать нам пару для key в заданном ассоциативном
списке (списке из точечных пар).

#+BEGIN_SRC lisp

(defun our-assoc (key alist)
(and (consp alist)
(let ((pair (car alist)))
(if (eql key (car pair))
pair
(our-assoc key (cdr alist))))))

#+END_SRC

Если alist - это ячейка, тогда мы присваиваем локальной переменной
pair первую пару списка. Если key = первому элементу списка, то
возвращаем пару. Если нет, то рекурсивно вызываем функцию с key
и остатком списка. Если список кончится, а мы ничего не нашли,
вернем nil.



** Page 68
Функция должна найти крайтчайший путь к элементу.
shortest-path принимает 3 аргумента: начальную и конченую точки,
саму сеть. Она передает функции bfs конечную точку, начальную
точку, представленную в виде списка (зачем 2 раза оборачивать?) и
саму сеть.
#+BEGIN_SRC lisp

  (defun shortest-path (start end net)
    (bfs end (list (list start)) net))

#+END_SRC

Bfs принимает 3 аргумента: конечную точку, "очередь" и саму сеть.
Затем мы проверяем, является очередь пустым списком. Если да,
возвращаем nil. Если нет, то записываем первый элемент очереди в
переменную path. А первый элемент path - в переменную node.
Видимо, первый элемент queue должен быть списоком или хотя бы
точечной парой. Затем мы проверям, равны ли node и end.
Если равны, то возвращаем элементы path в обратном порядке
(зачем?).
Если нет, то рекурсивно вызываем bfs c конечной точкой,
склеенным списком, состоящим из остатка queue и
результата вызова функции new-path, и сетью.

#+BEGIN_SRC lisp

  (defun bfs (end queue net)
(fornat t " BFS end ~a queue ~a  net ~a ~&" end queue net)
(if (null queue)
        nil
        (let ((path (car queue)))
          (let ((node (car path)))
            (if (eql node end)
                (reverse path)
                (bfs end
                     (append (cdr queue)
                             (new-paths path node net))
                     net))))))

#+END_SRC

new-paths принимает три аргумента: путь, узел и саму сеть.
Дальше ничего не ясно.

#+BEGIN_SRC lisp

  (defun new-paths (path node net)
    (mapcar #'(lambda (n)
                (cons n path))
              (cdr (assoc node net))))
#+END_SRC
