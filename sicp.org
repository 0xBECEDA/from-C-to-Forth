
#+STARTUP: showall indent hidestars

* Chapter 1
:PROPERTIES:
:ORDERED:  t
:END:

Ниже приведена последовательность выражений. Какой результат
напечатает интерпретатор в ответ на каждое из них?
Предполагается, что выражения вводятся в том же порядке, в каком они написаны.

~Упражнение 1.1~

#+BEGIN_SRC scheme
  (+ 5 3 4)
  ;; => 12

  (- 9 1)
  ;; => 8

  (/ 6 2)
  ;; => 3

  (+ (* 2 4) (- 4 6))
  ;; => 6

  (define a 3)
  ;; => 3

  (define b (+ a 1))
  ;; => 4

  (+ a b (* a b))
  ;; => 19

  (= a b)
  ;; => 4

  (if (and (> b a) (< b (* a b)))
      b
      a)
  ;; => a (т.е. 4)

  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
  ;; => 6

  (+ 2
     (if (> b a)
         b
         a))
  ;; => 6

  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))

  ;; => -5 (поскольку a = b, то сработает выражение else)

#+END_SRC

~Упражение 1.2~

Переведите выражение в префиксную форму:

5 + 4 + (2 − (3 − (6 + 4/5)))
____________________________
     3(6 − 2)(2 − 7)

(4/5 в данном контексте означает дробь "четыре пятых")

#+BEGIN_SRC scheme

    (/ (+ 4 5 (- 2 (- 3 (+ 6 (/ 4 5)))))
       (* 3 (- 6 2) (- 2 7)))

#+END_SRC

~Упражнения 1.3~

Определите процедуру, которая принимает в качестве аргументов три числа
и возвращает сумму квадратов двух бо́льших из них.
#+BEGIN_SRC scheme

  (define (sum-of-biggest-squares a b c)
    (cond ((and (> a b) (> b c)) (+ (* a a) (* b b)))
          ((and (> b a) (> c b)) (+ (* b b) (* c c)))
          ((and (> c a) (> a b)) (+ (* a a) (* c c)))
          ((and (> a c) (> b a)) (+ (* a a) (* b b)))
          ((and (> b c) (= a b)) (+ (* b b) (* c c)))
          ((and (> a b) (= c b)) (+ (* a a) (* b b)))
          (else (a b c))))

#+END_SRC

~Упражнение 1.4~

Заметим, что наша модель вычислений разрешает существование комбинаций, операторы кото-
рых — составные выражения. С помощью этого наблюдения опишите, как работает следующая
процедура:

#+BEGIN_SRC scheme

  (define (a-plus-abs-b a b)
    ((if (> b 0)
         +
         -)
     a b))

#+END_SRC

Ответ: в зависимости от того, больше b нуля или нет, форма if вернет предикат
"+" или "-", а возвращенный предикат будет применен к числам a и b.

~Упражнений 1.5~

Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком
вычислений он
работает, аппликативным или нормальным. Бен определяет такие две процедуры:

#+BEGIN_SRC scheme
  (define (p) (p))
  (define (test x y)
    (if (= x 0)
        0
        y))

  ;; Затем он вычисляет выражение

  (test 0 (p))
#+END_SRC

Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок
вычислений? Какое поведение он увидит, если интерпретатор использует нормальный
порядок?
Объясните Ваш ответ. (Предполагается, что правило вычисления особой формы if одинаково
независимо от того, какой порядок вычислений используется.
Сначала вычисляется выражение-предикат, и результат определяет,
нужно ли вычислять выражение-следствие или альтернативу.)

Ответ: мой интерпритатор использует нормальный порядок.

При аппликативном порядке интерпритор сначала подстатавит все значения в параметры
процедуры и только потом вычислит.

Процедура P - это рекурсивный выозов самой себя без конца.
аппликативный порядок даже не запустит процедуру.

Нормальный же порядок сначала вычисляет то, что вычислить можно сразу, затем выполняет
подстановку значений, если в этом есть необходимость и вычисляет новое выражение. И так
до тех пор, пока выражение не будет вычислено полностью.

Таким образом мы зациклимся навечно.

~Упражнение 1.6~

Лиза П. Хакер не понимает, почему if должна быть особой формой. «Почему нельзя просто
определить ее как обычную процедуру с помощью cond?» — спрашивает она. Лизина подруга
Ева Лу Атор утверждает, что, разумеется, можно, и определяет новую версию if:
#+BEGIN_SRC scheme

  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))

#+END_SRC

Обрадованная Лиза переписывает через new-if программу вычисления квадратного корня.
Что получится, когда Лиза попытается использовать эту процедуру для вычисления
квадратных корней? Объясните.
#+BEGIN_SRC scheme

  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (define (square x) (* x x))

  (define (average x y)
    (/ (+ x y) 2))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (good-enough? guess x)
    ;; возводим предполагаемый корень числа в квадрат,
    ;; вычитаем его из заданного числа
    ;; молучаем модуль разости
    ;; проверям, меньше ли он 0.001
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (square guess) x)) 0.001))

  ;; поиск корня с допустимой погрешностью
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (new-if (good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))

  ;; считаем, что корень любого числа = 1
  (define (sqrt x)
    ;; вызываем основную процедуру
    (sqrt-iter 1.0 x))
#+END_SRC

Ответ: при запуске процедуры с new-if я получила ошибку о переполнении стека.
Проблема в том, что срабатывают оба ветвления cond, это означает, возвращаемое
значение предиката (вызов good-enogh? в нашем случае) не интерпритируется
как "истина".


~Упражнение 1.7~
Проверка good-enough?, которую мы использовали для вычисления квадратных корней, будет
довольно неэффективна для поиска квадратных корней от очень маленьких чисел. Кроме
того, в настоящих компьютерах арифметические операции почти всегда вычисляются
с ограниченной точностью. Поэтому наш тест оказывается неадекватным и для очень больших
чисел. Альтернативный подход к реализации good-enough? состоит в том, чтобы следить,
как от одной итерации к другой изменяется guess, и остановиться, когда изменение
оказывается небольшой долей значения приближения.
Разработайте процедуру вычисления квадратного корня, которая использует такой
вариант проверки на завершение. Верно ли, что на больших и маленьких числах она
работает лучше?

Ответ: неверно, поскольку процедура вынуждена вызывать саму себя одинаковое кол-во
раз для good-enough? и my-good-enough?
#+BEGIN_SRC scheme
  (define (my-good-enough? guess x)
    (display "iteration\n")
    (< (abs (- (square (improve guess x)) (square guess))) 0.001))

  ;; вызов с определенной в мане процедурой
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))

  ;; вызов с моей процедурой
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (my-good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))
#+END_SRC

~Упражнение 1.8~

Метод Ньютона для кубических корней основан на том, что если Y является приближением к
кубическому корню из X, то мы можем получить лучшее приближение по формуле:

x/(y * y) + 2y
______________
      3

С помощью этой формулы напишите процедуру вычисления кубического корня, подобную проце-
дуре для квадратного корня.

Чтоб узнать кубический корень из X, нужно разделить X на Y в квадрате, прибавить к
получившемуся значению Y, умноженный на 2, и все это поделить на 3.

Как найти Y?

Предположим, что Y = 1.0

#+BEGIN_SRC scheme
  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (define (square x) (* x x))

  (define (cube x) (* x x x))

  ;; (define (my-average x y)
  ;;   (/ (+ x y) 3))

  (define (formula-realization guess x)
    ( / (+ (/ x (square guess )) (* 2 guess ))
        3))

  ;; (define (improve guess x)
  ;;   (average guess (/ x guess)))

  (define (good-enough? guess x)
    ;; возводим предполагаемый корень числа в квадрат,
    ;; вычитаем его из заданного числа
    ;; молучаем модуль разости
    ;; проверям, меньше ли он 0.001
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (cube (formula-realization guess x)) x))
       0.001))

  (define (my-good-enough? guess x)
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (cube (formula-realization guess x)) (cube guess))) 0.001))

  ;; поиск корня с допустимой погрешностью
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (my-good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (formula-realization guess x) x)))

  ;; считаем, что корень любого числа = 1
  (define (sqrt x)
    ;; вызываем основную процедуру
    (sqrt-iter 1.0 x))

#+END_SRC

~Упражнение 1.9~

Каждая из следующих двух процедур определяет способ сложения двух положительных целых
чисел с помощью процедур inc, которая добавляет к своему аргументу 1, и dec, которая
отнимает от своего аргумента 1.

Используя подстановочную модель, проиллюстрируйте процесс, порождаемый каждой из этих
процедур, вычислив (+ 4 5). Являются ли эти процессы итеративными или рекурсивными?

#+BEGIN_SRC scheme
  (define (+ a b)
    (if (= a 0)
        b
        (inc (+ (dec a) b))))

  (define (+ a b)
    (if (= a 0)
        b
        (+ (dec a) (inc b))))
#+END_SRC

Ответ: первая процедура - это линейный рекурсивный процесс. Вторая - итеративный
линейный процесс, он же хвостовая рекурсия.

~Упражнение 1.10~

Следующая процедура вычисляет математическую функцию, называемую функцией Аккермана.

Каковы значения следующих выражений?
(A 1 10) => 1024
(A 2 4)  => 65536
(A 3 3)  => 65536
#+BEGIN_SRC scheme
  (define (A x y)
    (display "----\n")
    (display "x:")
    (display x)
    (display "\n")
    (display "y:")
    (display y)
    (display "\n")
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))
#+END_SRC


Рассмотрим следующие процедуры, где A — процедура, определенная выше:
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))

Дайте краткие математические определения функций, вычисляемых процедурами f, g и h для
положительных целых значений n.

~Шпаргалка по fib~
#+BEGIN_SRC scheme
  (define (fib n sp)
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (cond ((= n 0) (let ((answer 0))
                     (space sp)
                     (display "first\n")
                     0))
          ((= n 1) (let ((answer 1))
                     (space sp)
                     (display "second\n")
                     1))
          (else (let ((answer 10))
                  (space sp)
                  (display "else\n")
                  (+ (fib (- n 1) (+ 1 sp))
                     (fib (- n 2) (+ 1 sp)))))))

  (define (fib n sp)
    (fib-iter 1 0 n sp))

  (define (fib-iter a b count sp)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1) (+ sp 1))))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))
#+END_SRC

~Упражнение 1.11~

Функция f определяется правилом:
f (n) = n, если n < 3, и f (n) = f (n − 1) + f (n − 2) + f (n − 3), если n ≥ 3.
Напишите процедуру, вычисляющую f с помощью рекурсивного процесса.
Напишите процедуру, вычисляющую f с помощью итеративного процесса.

#+BEGIN_SRC scheme
  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (f n sp)
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (if (< n 3)
        n
        (+ (f (- n 1) (+ sp 1)) (f (- n 2) (+ sp 1)) (f (- n 3) (+ sp 1)))))

  (define (iter-f a b c count sp)
    (space sp)
    (display "A:")
    (display a )
    (display "\n")
    (space sp)
    (display "B:")
    (display b )
    (display "\n")
    (space sp)
    (display "C:")
    (display c )
    (display "\n")
    (space sp)
    (display "count:")
    (display count )
    (display "\n")
    (if (= count 0)
        c
        (iter-f (+ a b c) a b (- count 1) (+ sp 1))))

  (define (f n sp)
    (iter-f 2 1 0 n sp))
#+END_SRC

~Упражнение 1.12~

Дан треугольник Паскаля (см. стр. 57)

Все числа по краям треугольника равны 1, а каждое число внутри треугольника равно сумме
двух чисел над ним. Напишите процедуру, вычисляющую элементы треугольника Паскаля с
помощью рекурсивного процесса.

PS скорее всего имеется в виду вычисление суммы коэфициентов. Т.е. надо опираться на
следующее:
сумма биномиальных коэффициентов равна числу 2, возведенному в степень, равную
показателю степени бинома Ньютона. Т.е. сумма коэфициэнтов третьей строчки треугольника
Паскаля будет равна 8, поскольку 2 в третьей степени = 8.

 #+BEGIN_SRC scheme
   ;; n = строка треугольника Паскаля. Нумерция строк наинчается от нуля.
   ;; k = кол-во элементов в строке. Всегда равно номеру строки + 1
   (define (paskal n)
     (p n (+ n 1)))

   (define (p n k)
     (if (or (= n 0) (= n k))
         1
         (+ (p (- n 1) (- k 1))
            (p (- n 1) k))))
#+END_SRC

~Упражнение 1.13~
Докажите, что Fib(n) есть целое число, ближайшее к φ в степени n / √5,
где φ = (1 + √5)/2. Указание: пусть ψ = (1 − √5)/2.
С помощью  определения чисел Фибоначчи (см. раздел 1.2.2) и индукции докажите,
что Fib(n) = (φ в степени n − ψ в степени n )/ √5.

Определение числел Фибоначчи: каждое последующее число = сумме предыдущих двух:
F(n) = 0, если n = 0
F(n) = 1, если n = 1
F(n) = F(n - 1) + F (n - 2) во всех остальных случаях

φ = (1 + √5)/2 - это формула золотого сечения

Полагаю, что под индукцией понимается математическая индукция, т.е. если базис индукции
верен (будем считать его 1 или же P1), то верно и Pn, а значит справедливо будет
сказать, что верно Pn + 1. Иллюстрация этого утверждения - принцип домино: если упала
первая косточка домино, то упадут и все последующие.

Значит, нам нужно доказать, что
Fib(1) есть целое число, ближайшее к φ в степени 1 /√5, где φ = (1 + √5)/2  -  это
будет базис нашей индукции.

Воспользуемся определенными в ~упражнениеи 1.7~ функциями, чтоб извлекать квадратные
корни.
 #+BEGIN_SRC scheme
   (define (abs x)
     (cond ((> x 0) x)
           ((= x 0) 0)
           ((< x 0) (- x))))

   (define (square x) (* x x))

   (define (average x y)
     (/ (+ x y) 2))

   (define (improve guess x)
     (average guess (/ x guess)))

   (define (good-enough? guess x)
     ;; возводим предполагаемый корень числа в квадрат,
     ;; вычитаем его из заданного числа
     ;; молучаем модуль разости
     ;; проверям, меньше ли он 0.001
     (< (abs (- (square guess) x)) 0.001))

   ;; поиск корня с допустимой погрешностью
   (define (sqrt-iter guess x)
     ;; корень нашли?
     (if (good-enough? guess x)
         ;; да, вернуть корень
         guess
         ;; иначе считаем дальше
         (sqrt-iter (improve guess x)
                    x)))

   ;; считаем, что корень любого числа = 1
   (define (sqrt x)
     ;; вызываем основную процедуру
     (sqrt-iter 1.0 x))
#+END_SRC

#+BEGIN_SRC scheme
  (define (fib n)
    (fib-iter 1 0 n))

  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))

  ;; вычисление фи
  (define (fi)
    ( / (+ 1 (sqrt 5)) 2))

  ;; вычисление пси
  (define (psi)
    ( / (- 1 (sqrt 5)) 2))

  ;; возведение числа в степень (написано криво, я знаю)
  (define (extent x pr-x n)
    (cond ((= n 0) 1)
          ((= n 1) x)
          (else (extent (* x pr-x) pr-x (- n 1)))))

  ;; если базис индукции верен, вычисляем условие с n
  ;; внимаение, наблюдается погрешность приблиительно на 0.001, которая становится выше
  ;; на больших числах
  ;; P.S. формально вычисление условия с n не требуется, т.к. если базис индукции
  ;; верен, то и условие с n верно
  (define (proof n)
    (if (= (fib 1) ( / (- (extent (fi) (fi) 1) (extent (psi) (psi) 1)) (sqrt 5)))
        (if (or (> (- (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
                   0.1)
                (< (- (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
                   0.1)
                (= (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5))))

            #t
            (let ((f #f))
              (display (fib n))
              (display "\n")
              (display ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
              (display "\n")
              f))))

#+END_SRC


~Шпаргалка по размену монет~

#+BEGIN_SRC scheme

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (cc amount kinds-of-coins sp)
    (space sp)
    (display "amount:")
    (display amount)
    (display "\n")
    (space sp)
    (display "kinds-of-coins:")
    (display kinds-of-coins)
    (display "\n")
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+ (cc amount
                       (- kinds-of-coins 1) (+ sp 1))
                   (cc (- amount
                          (first-denomination kinds-of-coins))
                       kinds-of-coins (+ sp 1))))))

  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))

  (define (count-change amount)
    (cc amount 5 0))
#+END_SRC

~Упражнение 1.15~

Синус угла (заданного в радианах) можно вычислить, если воспользоваться приближением
sin x ≈ x при малых x и употребить тригонометрическое тождество (см. стр 59)
для уменьшения значения аргумента sin. (В этом упражнении мы будем считать, что угол
«достаточно мал», если он не больше 0.1 радиана.) Эта идея используется в следующих
процедурах:

#+BEGIN_SRC scheme
  (define (cube x) (* x x x))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (p x count sp)
    (space sp)
    (display "count:")
    (display count)
    (display "\n")
    (- (* 3 x) (* 4 (cube x))))

  (define (sine angle count)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0) (+ 1 count)) (+ count 1) (+ sp 1))))
#+END_SRC

а. Сколько раз вызывается процедура p при вычислении (sine 12.15)?
б. Каковы порядки роста в терминах количества шагов и используемой памяти
(как функция a) для процесса,
порождаемого процедурой sine при вычислении (sine a)?

Ответ: p выполнится 5 раз.

?

~Упражнение 1.16~

Напишите процедуру, которая развивается в виде итеративного процесса и реализует
возведение в степень за логарифмическое число шагов, как fast-expt.
(Указание: используя наблюдение, что (b^n/2 )^2 = (b^2 )^n/2 ,
храните, помимо значения степени n и основания b, дополнительную переменную состояния
a, и определите переход между состояниями так, чтобы произведение ab^n от
шага к шагу не менялось. Вначале значение a берется равным 1, а ответ получается
как значение a в момент окончания процесса.
В общем случае метод определения инварианта (invariant quantity), который не изменяется
при переходе между шагами, является мощным способом размышления о построении
итеративных алгоритмов.)

Первоначальный вариант fast-expt:
o
#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))
#+END_SRC

Первод задания на русский язык:
- функция должна реализовывать хвостовую рекурсию вместо линейной
- функция должна работать по тому же принципу, что и fast-expt: т.е. использовть
логарифмическое кол-во шагов, а не линейное
- функция должна использовать 3 переменные: n - значение степени,
 b - основание, а - переменная состояния
- переменная состояния - это, видимо, аккумулятор. Т.е. в нем будет накапливаться
значение, которое вернет функция. Изначально его значение = 1.
- дана подсказка: можно сначала разделить степень на два, возвести число в степень и
затем возвести результат в квадрат или сначала возвести число в квадрат, а затем
в разделенную на два степень.
- переход между состояниями, т.е. между итерациями/вызовами функции должен быть
  определен так, чтоб произведение от а*b^n не менялось (что имеется в виду?)
Возможный вариант:
- n делится на 2 на каждой итерации
- a = a * b на каждой итерации (здесь была ошибка: не на каждой итерации, а только
на последней. Т.е. акум все равно b, и только на последней итерации, когда
n = 1, мы перемножаем a и b, т.е. умножаем b на единицу, поскольку любой число
в степени 1 = то же самое число)

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (fast-expt b n)
    (my-fast-expt b n 1 0))

  (define (my-fast-expt b n a sp)
    (space sp)
    (display "a:")
    (display a)
    (display "\n")
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (space sp)
    (display "b:")
    (display b)
    (display "\n")
    (cond ((= n 0) a)
          ((even? n) (my-fast-expt (* b b) (/ n 2) a (+ 1 sp)))
          (else (my-fast-expt b (- n 1) (* a b) (+ 1 sp)))))

#+END_SRC
~Упражнение 1.17~

Алгоритмы возведения в степень из этого раздела основаны на повторяющемся
умножении. Подобным же образом можно производить умножение с помощью повторяющегося
сложения.
Следующая процедура умножения (в которой предполагается,
что наш язык способен только складывать, но не умножать) аналогична процедуре expt:

#+BEGIN_SRC scheme

  (define (* a b)
    (if (= b 0)
        0
        (+ a (* a (- b 1)))))

#+END_SRC

Этот алгоритм затрачивает количество шагов, линейно пропорциональное b.
Предположим теперь, что, наряду со сложением, у нас есть операции double,
которая удваивает целое число, и halve, которая делит (четное) число на 2.
Используя их, напишите процедуру, аналогичную fast-expt,
которая затрачивает логарифмическое число шагов.

Итак, нам фактически нужно реализовать процедуру умножения, не используя само
умножение и затратить на это логарифмическое кол-во шагов.
Если "b" четное, то мы делим b на 2, затем складываем "a" с самим собой до тех пор,
пока b не станет 0 (1?).

#+BEGIN_SRC scheme

  (define (double a)
    (+ a a))

  (define (halve a)
    (/ a 2))

  (define (even? n)
    (= (remainder n 2) 0))

  (define (multiple a b)
    (cond ((or (= b 0) (= a 0)) 0)
          ((= b 1) a)
          ((= a 1) b)
          ((even? b) (multiple (double a) (halve b)))
          (else (+ a (multiple a (- b 1))))))

#+END_SRC

~Упражнение 1.18~

Используя результаты упражнений 1.16 и 1.17, разработайте процедуру, которая порождает
итеративный процесс для умножения двух чисел с помощью сложения, удвоения и деления пополам,
и затрачивает логарифмическое число шагов.

Дана подсказка: данный алгоритм называется "метод русского крестьянина" или
"египетский" метод.

#+BEGIN_SRC scheme
  (define (double a)
    (+ a a))

  (define (halve a)
    (/ a 2))

  (define (even? n)
    (= (remainder n 2) 0))

  (define (new-multiple a b accum)
    (cond ((or (= b 0) (= a 0)) accum)
          ((= b 1) (+ a accum))
          ((= a 1) b)
          ((even? b) (new-multiple (double a) (halve b) accum))
          (else (new-multiple a (- b 1) (+ a accum)))))

  (define (multiple a b)
    (new-multiple a b 0))
#+END_SRC

~Упражнение 1.19~

уществует хитрый алгоритм получения чисел Фибоначчи за логарифмическое число шагов.
Вспомните трансформацию переменных состояния a и b процесса fib-iter из раздела 1.2.2

a ← a + b и b ← a. Назовем эту трансформацию T и заметим, что n-кратное применение T ,
начиная с 1 и 0, дает нам пару Fib(n + 1) и Fib(n). Другими словами, числа Фибоначчи
получаются путем применения T^n , n-ой степени трансформации T , к паре (1,0).
Теперь рассмотрим T как частный случай p = 0, q = 1 в семействе трансформаций T pq ,
где Tpq преобразует пару (a, b) по правилу a ← bq + aq + ap, b ← bp + aq.
Покажите, что двукратное применение трансформации Tpq равносильно однократному
применению трансформации Tp ′q ′ того же типа, и вычислите p ′ и q ′ через p и q.
Это дает нам прямой способ возводить такие трансформации в квадрат, и
таким образом, мы можем вычислить T n с помощью последовательного возведения в квадрат, как в
процедуре fast-expt. Используя все эти идеи, завершите следующую процедуру, которая
дает результат за логарифмическое число шагов.

Перевод на русский язык:
есть некая трансформация, которая называется Т. Она работает так:  a ← a + b и b ← a
Му говорим что применение этой трансформации какое-то кол-во раз к числам 1 0 дает
нам в конечном итоге формулу Фибоначи, а вернее, пару Fib(n + 1) и Fib(n). Иными
словами можно сказать, что числа Фибоначчи получаются, если применить трансформацию Т
заданное кол-во раз, т.е. Т^n к паре 1 и 0.

Теперь скажем, что это частный случай в целом семестве трансформаций Tpq, где
p = 0, q = 1.
Семейство этих трансформаций работает по правилу: a ← bq + aq + ap, b ← bp + aq,
преобразовывая таким образом а и b.

Задание: у нас есть семейство трансформаций Tpq и какая-то конкретная трансформация
этого семейства Tp ′q ′, т.е. за p ′q` скрыты реальные числа.
Нам нужно вычислить их через p и q, зная, что однократное применение Tp ′q ′
будет равносильно двукратному применению Tpq, т.е. p ′и q ′ - в 2 раза больше, чем p и
q.

#+BEGIN_SRC scheme
  (define (fib n)
    (fib-iter 1 0 0 1 n 0))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (fib-iter a b p q count sp)
    (space sp)
    (display "a:")
    (display a)
    (display "\n")
    (space sp)
    (display "b:")
    (display b)
    (display "\n")
    (space sp)
    (display "p:")
    (display p)
    (display "\n")
    (display "q:")
    (display q)
    (display "\n")
    (space sp)
    (display "count:")
    (display count)
    (display "\n")
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (* p p) (* q q))
                     (+ (* 2 p q) (* q q))
                     (/ count 2) (+ sp 1)))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1) (+ sp 1)))))
#+END_SRC

~Упражнение 1.20~

Процесс, порождаемый процедурой, разумеется, зависит от того, по каким правилам
работает интерпретатор. В качестве примера рассмотрим итеративную процедуру gcd,
приведенную выше. Предположим, что мы вычисляем эту процедуру с помощью нормального
порядка, описанного в разделе 1.1.5.
(Правило нормального порядка вычислений для if описано в упражнении 1.5.)
Используя подстановочную модель для нормального порядка, проиллюстрируйте процесс,
порождаемый при вычислении (gcd 206 40) и укажите, какие операции вычисления остатка
действительно выполняются. Сколько операций remainder выполняется на самом деле при вычислении
(gcd 206 40) в нормальном порядке? При вычислении в аппликативном порядке?

#+BEGIN_SRC scheme

(define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

#+END_SRC

Итак, нормальный порядок вычислений будет сначала подставит все аргументы и только
потом запустит процедуру "«полная подстановка, затем редукция".If будет работать
одинаково и при аппликативном, и при нормальном порядке.

Апликативный порядок будет осуществляться:

Даны аргументы 206 и 40. Их можно сразу подставить и запустить процедуру gcd.
Сработает ветка if-a false, т.к. 40 != 0. Процедура remainder получит аргументы
206 и 40,вернет остаток от деления, запустится рекурсивный вызов gcd и так будет до тех пор, пока
b не окажется = 0. Иными словами, мы будем сначала вычислять аргументы, а затем
запускать процедуру.

При нормальном порядке аргументы remainder не будут вычислены.
Проще показать это через код:
#+BEGIN_SRC scheme
;; доделать!
  ;; первый вызов
  (gcd 206 40 ) ->

  (if (= 40 0)
      206
      (gcd 40 (remainder 206 40))) ->

  ;; рекурсивый вызов 1
  (gcd 40 (remainder 206 40)) ->

  (if (= (remainder 206 40) 0)
      40
      (gcd (remainder 206 40) (remainder 40
                                         (remainder 206 40)))) ->
  ;; рекурсивный вызов 2
  (gcd (remainder 206 40) (remainder 40
                                     (remainder 206 40))) ->

  (if (= (remainder 40
                    (remainder 206 40)) 0)

      (remainder 206 40)
      (gcd (remainder 40
                      (remainder 206 40))
           (remainder (remainder 206 40)
                      (remainder 40
                                 (remainder 206 40))))) ->




#+END_SRC



~Шпаргалка по тесту Ферма~

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  ;; принимает основание, степень и модуль
  (define (expmod base exp m)
    ;; если степень = 0, вернуть 1
    (cond ((= exp 0) 1)
          ;; если степень четная,
          ((even? exp)
           ;; рекурсивно вызываем с процедуру с степенью поделенной на 2,
           ;; когда достигнем дна рекурсии, отктимся назад, получим число, возведенное
           ;; в степень, деленную на 2 и возведем его в квадрат (см алгоритм fast-expt)
           ;; затем передадим результат и модуль в процедуру reminder,
           ;; которая вернет нам остаток от деления данного числа на модуль
           (remainder (square (expmod base (/ exp 2) m))
                      m))
          ;; если степень не четная, отнимаем от степени 1, рекурсивно вызываем процедуру,
          ;; достигаем дна рекурсии, откатываем назад, умножаем полученный результат
          ;; основание и передаем все в remainder, чтоб, опять же, получить остаток
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))

  ;; вызов exmod  с рандомным числом от "a" до n-1
  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

  ;; если тест Ферма прошел заданное кол-во раз, мы считаем, что число n простое
  (define (fast-prime? n times)
    (cond ((= times 0) #t)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else #f)))
#+END_SRC


~Упражнение 1.21~

С помощью процедуры smallest-divisor найдите наименьший делитель следующих чисел:
199, 1999, 19999.

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))
#+END_SRC

Для числа 199 - наименьший делитель само число, т.к. это простое число, для 1999 - само
число по аналогичной причине (вообще-то наименьший делитель для них должен быть 1)

Для числа 19999 ответ 7, т.к. это непростое число.


~Упражнение 1.22~
Бо́льшая часть реализаций Лиспа содержат элементарную процедуру runtime, которая
возвращает целое число, показывающее, как долго работала система (например, в
миллисекундах).

Следующая процедура timed-prime-test, будучи вызвана с целым числом n, печатает n и
проверяет, простое ли оно. Если n простое, процедура печатает три звездочки и количество
времени, затраченное на проверку.

Используя эту процедуру, напишите процедуру search-for-primes, которая проверяет на
простоту все нечетные числа в заданном диапазоне. С помощью этой процедуры найдите
наименьшие три простых числа после 1000; после 10 000; после 100 000; после 1 000 000.
Посмотрите, сколько времени затрачивается на каждое простое число.
Поскольку алгоритм проверки имеет порядок роста Θ(√n), Вам следовало бы ожидать,
что проверка на простоту чисел, близких к 10 000, занимает в 10 раз больше времени, чем
для чисел, близких к 1000. Подтверждают ли это Ваши замеры времени?
Хорошо ли поддерживают предсказание √n данные для 100 000 и 1 000 000?
Совместим ли Ваш результат с предположением, что программы на Вашей машине затрачивают
на выполнение задач время, пропорциональное числу шагов?


#+BEGIN_SRC scheme
  (define (report-prime start-time end-time)
    (display " *** ")
    (display (- (cdr end-time) (cdr start-time)))
    (display "\n")
    #t)

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime start-time (gettimeofday))
        #f))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (gettimeofday)))

#+END_SRC

Отсутствует процедура runtime, пришлось заменить на такой "кустарный" таймер.
gettimeofday пару значений: секунды и микросекунды с 1.1.1970.

Добавила возвращаемые значение #t, если число простое, и #f - если нет, так легче
написать search-for-primes.

Процедура принимает диапазон, в котором должна найти простые числа, и кол-во этих
простых чисел.
#+BEGIN_SRC scheme
  (define (search-for-primes start-num end-num count)
    (cond ((= (remainder start-num 2) 0) (search-for-primes (+ 1 start-num) end-num count))
          ((or (= count 0) (= start-num end-num)) (display "finished\n"))
          ((timed-prime-test start-num)
           (search-for-primes (+ 2 start-num) end-num (- count 1)))
          (else (search-for-primes (+ 2 start-num) end-num count))))

#+END_SRC

Форматный вывод:
1009 *** 11
1013 *** 14
1019 *** 10

10007 *** 65
10009 *** 72
10037 *** 67

100003 *** 168
100019 *** 167
100043 *** 119

1000003 *** 546
1000033 *** 546
1000037 *** 679

Итак, если верить полученному выводу, то на поиск простых чисел, ближайших к
10 000, уходит не в 10 раз больше времени, чем для поиска простых чисел, ближайших к
1000. Возможно, дело во внутренней оптимизации.

Если я правильно понимаю обозначение Θ(√n), то число шагов будет расти как "квабратный
корень от n", т.е. кол-во шагов при n = 1000 приблизительно равно 32, при n = 10 000
кол-во шагов приблизительно равно 100, при n = 100 000 число шагов приблизительно 320,
при n = 1 000 000 приблизительно 1000. Т.е. чтоб найти три простых числа рядом
с 100 00 нужно в 10 раз меньше шагов чем для 1 000 000, и в 10 раз меньше шагов
нужно, чтоб найти три простых числа рядом с 1000, чем рядом 100 000.

Смотрим на вермя: для 1 000 000 понадобилось приблизительно в 10 раз больше времени,
чем для 10 000, для 100 000 понадобилось приблизительно в 10 раз больше времени, чем
для 1000.

Ответ: да, кол-во времени пропорционально кол-ву затрачиваемых шагов.

~Упражнение 1.23~
Процедура smallest-divisor в начале этого раздела проводит множество лишних проверок:
после того, как она проверяет, делится ли число на 2, нет никакого смысла проверять
делимость на другие четные числа. Таким образом, вместо последовательности
2, 3, 4, 5, 6 . . . , используемой для test-divisor, было бы лучше использовать
2, 3, 5, 7, 9 . . . .

Чтобы реализовать такое улучшение, напишите процедуру next,
которая имеет результатом 3, если получает 2 как аргумент, а иначе возвращает свой
аргумент плюс 2.
Используйте (next test-divisor) вместо (+ test-divisor 1) в
smallest-divisor.

Используя процедуру timed-prime-test с модифицированной версией smallest-divisor,
запустите тест для каждого из 12 простых чисел, найденных в упражнении 1.22.
Поскольку эта модификация снижает количество шагов проверки вдвое, Вы должны ожидать
двукратного ускорения проверки. Подтверждаются ли эти ожидания?
Если нет, то каково наблюдаемое соотношение скоростей двух алгоритмов, и как Вы
объясните то, что оно отличается от 2?

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (next test-divisor)
    (if (= test-divisor 2)
        3
        (+ test-divisor 2)))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (next test-divisor)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))

#+END_SRC

Судя по форматному выводу, для первой тройки чисел отклонение составляет 2-3
милисекунды, со второй тройкой чисел тоже почти не изменилась, как и с третьей.
Больше всего изменения коснулись последней тройки:

было:  1000003 *** 546     стало:  1000003 *** 389
       1000033 *** 546             1000033 *** 389
       1000037 *** 679             1000037 *** 342

В принципе, мы можем сказать, что получили двухкратный прирост производительности, т.к.
я думаю, что остальные результаты мало изменились по причине хорошой оптимизации кода
внутри интерпритатора и при неоптимальной версии smallest-divisor. На более больших
числах внутренняя оптимизация работала хуже.

P.S. Проверено на более больших числах. Гипотеза не подтвердилась, процедура с
первоначальной  версией smallest-divisor работает даже быстрее, чем с
оптимальной. Возможно, это все шутки интерпритатора, т.к. процедуры сравнительно
небольшие.

~Упражнение 1.24~
Модифицируйте процедуру timed-prime-test из упражнения 1.22 так, чтобы она использовала
fast-prime? (метод Ферма) и проверьте каждое из 12 простых чисел, найденных в этом
упражнении.
Исходя из того, что у теста Ферма порядок роста Θ(log n), то какого соотношения
времени Вы бы ожидали между проверкой на простоту поблизости от 1 000 000 и
поблизости от 1000?
Подтверждают ли это Ваши данные? Можете ли Вы объяснить наблюдаемое несоответствие,
если оно есть?

#+BEGIN_SRC scheme
  (define (report-prime start-time end-time)
    (display " *** ")
    (display (- (cdr end-time) (cdr start-time)))
    (display "\n")
    #t)

  (define (start-prime-test n start-time)
    (if (fast-prime? n 5)
        (report-prime start-time (gettimeofday))
        #f))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (gettimeofday)))

#+END_SRC

Итак, если алгоритм растет как Θ(log n), то он растет медленнее, чем Θ(√n), т.к.
если n = 9, то логарифм от по основанию 3 равен 2 от 9. А вот квадратный корень из 9
= 3. 2 < 3, поэтому я думаю, что Θ(log n) растет медленнее.

Исходя из этого предположения можно сказать, что timed-prime-test, использующий метод
Ферма, должен работать быстрее, чем прежняя версия.

предыдущий результат:
1000003 *** 389
1000033 *** 389
1000037 *** 342

новый результат, если ставить проверку 5 раз:
1000003 *** 163
1000033 *** 285
1000037 *** 198


Мы видим, что новая версия работает в полтора-два раза быстрее. Схожесть на более
маленьких числах я объясняю оптимизацией интерпритатора.

~Вопросы:~
Как рассчитать время при проверке чисел для 1000 и для 1 000 000, не загружая в
интерпритатор? Понятно, что для 1000 будет меньше, но как рассчитать точно?

Метод Ферма вероятностный. Т.е. он должен отработать несколько раз, чтоб мы могли
считать его результат достаточно достоверным, в то время как prime? отрабатывает только
1 раз. Я могу запустить метод Ферма 10 000 раз, получить результат как от prime?, но
только метод Ферма в будет работать сильно дольше, хотя логарифмический рост медленнее
чем O(квадратный корень от n). И как быть тогда?


~Упражнение 1.25~
Лиза П. Хакер жалуется, что при написании expmod мы делаем много лишней работы. В конце
концов, говорит она, раз мы уже знаем, как вычислять степени, можно просто написать.

#+BEGIN_SRC scheme
  (define (expmod base exp m)
    (remainder (fast-expt base exp) m))
#+END_SRC

Права ли она? Стала бы эта процедура столь же хорошо работать при проверке простых
чисел?
Объясните.

Я думаю, что права, поскольку fast-expt работает по тому же механизму, что оригинальная
expod. Я думаю, что у обоих алгоритмов рост O(log n).

~Упражнение 1.26~

У Хьюго Дума большие трудности в упражнении 1.24. Процедура fast-prime? у него работает
медленнее, чем prime?. Хьюго просит помощи у своей знакомой Евы Лу Атор. Вместе изучая
код Хьюго, они обнаруживают, что тот переписал процедуру expmod с явным использованием
умножения вместо того, чтобы вызывать square:


#+BEGIN_SRC scheme
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (remainder (* (expmod base (/ exp 2) m)
                         (expmod base (/ exp 2) m))
                      m))
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))
#+END_SRC


Хьюго говорит: «Я не вижу здесь никакой разницы». «Зато я вижу, — отвечает Ева. —
Переписав процедуру таким образом, ты превратил процесс порядка Θ(log n) в процесс порядка
Θ(n)».
Объясните.

Процедура ~square~
#+BEGIN_SRC scheme
  (define (square x) (* x x))
#+END_SRC

Ответ: Хьюго исполняет одни и те же вычисления дважды, а затем умножает результат
вычислений друг на друга. Да, формально это дает тот же ответ, что при использовании
square, только вот в оригинальной процедуре вычисление проводится один раз и по мере
отката рекурсии назад мы возводим каждое промежуточное значение в квадрат, включая
результат от самого первого рекурсивного вызова. Это позволяет в два раза скорее
производить вычисление.

~Упражнение 1.27~
Покажите, что числа Кармайкла, перечисленные в сноске 47, действительно «обманывают»
тест Ферма: напишите процедуру, которая берет целое число n и проверяет, правда ли a^n
равняется a по модулю n для всех a < n, и проверьте эту процедуру
на этих числах Кармайкла.

Числа Кормайкла 561, 1105, 1729, 2465, 2821 и 6601.

Я взяла процедуры из теста Ферма и слегка их изменила.
#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (remainder (square (expmod base (/ exp 2) m))
                      m))
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))

  (define (cormaickle-test n a)
    (cond ((= a n) #t)
          ((= (expmod a n n) a) (cormaickle-test n (+ 1 a)))
          (else #f)))
#+END_SRC

~Упражнение 1.28~
Один из вариантов теста Ферма, который невозможно обмануть, называется тест
Миллера–Рабина (Miller-Rabin test) (Miller 1976; Rabin 1980).
Он основан на альтернативной формулировке Малой теоремы Ферма, которая состоит в том,
что если n — простое число, а "a" — произвольное положительное целое число,
меньшее n, то a в n − 1-ой степени равняется 1 по модулю n.

Проверяя простоту числа  n методом Миллера–Рабина, мы берем случайное число a < n
и возводим его в (n − 1)-ю степень по модулю n с помощью процедуры expmod.
Однако когда в процедуре expmod мы проводим возведение в квадрат, мы проверяем,
не нашли ли мы «нетривиальный квадратный корень из 1 по модулю n»,
то есть число, не равное 1  или n − 1, квадрат которого по модулю n равен 1.
Можно доказать, что если такой нетривиальный квадратный корень из 1 существует,
то n не простое число. Можно, кроме того, доказать, что если n — нечетное
число, не являющееся простым, то по крайней мере для половины чисел a < n
вычисление a n−1 с помощью такой процедуры обнаружит нетривиальный квадратный корень
из 1 по модулю n (вот почему тест Миллера–Рабина невозможно обмануть).

Модифицируйте процедуру expmod так, чтобы она сигнализировала обнаружение
нетривиального квадратного корня из 1, и используйте ее для реализации теста
Миллера–Рабина с помощью процедуры, аналогичной fermat-test.
Проверьте свою процедуру на нескольких известных Вам простых и составных числах.
Подсказка: удобный способ заставить expmod подавать особый сигнал — заставить
ее возвращать 0.

Альтернативная формулировка малой теоремы Ферма:
a^(n - 1) = 1 (mod n)

Первая проверка:
«нетривиальный квадратный корень из 1 по модулю n» = чило в диапазоне от 2 до n - 2,
чей квадрат = 1 ( mod m), т.е. надо возвести число в квадрат, разделить на n, разделить
1 на n и сравнить остатки этих чисел. Если остатки равны, то исходное число не
простое.

Вторая проверка: если число нечетное и не простое, то минимум для половины чисел
a < n первая проверка даст положительный результат.

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (check n m)
    (if (and (not (= n 1))
             (not (= n (- m 1)))
             (= (remainder (square n) m)  1))
        0
        (remainder (square n) m)))

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (check (expmod base (/ exp 2) m) m))
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))

  (define (try-it a n)
    (= (expmod a (- n 1) n) 1))

  (define (m-r-test-iter n a positiv)
    (if (= a (- n 1))
        (> positiv (/ n 2))
        (if (try-it a n)
            (m-r-test-iter n (+ a 1) (+ 1 positiv))
            (m-r-test-iter n (+ a 1) positiv))))

  (define (m-r-test n)
    (m-r-test-iter n 1 0))
#+END_SRC


~Упражнение 1.29~
Правило Симпсона — более точный метод численного интегрирования, чем представленный
выше.

Представленный выше вариант:
#+BEGIN_SRC scheme
  (define (integral f a b dx)
    (define (add-dx x) (+ x dx))
    (* (sum f (+ a (/ dx 2)) add-dx b)
       dx))
#+END_SRC

С помощью правила Симпсона интеграл функции f между a и b приближенно вычисляется в
виде:

h[y0 + 4y1 + 2y2 + 4y3 + 2y4 + . . . + 2y n−2 + 4yn−1 + yn ]
3

где h = (b − a)/n, для какого-то четного целого числа n, а yk = f(a + kh).
(Увеличение n повышает точность приближенного вычисления.)
Определите процедуру, которая принимает в качестве аргументов f, a, b и n,
и возвращает значение интеграла, вычисленное по правилу Симпсона.
С помощью этой процедуры проинтегрируйте cube между 0 и 1 (с n = 100 и n = 1000) и
сравните результаты с процедурой integral, приведенной выше.

- n > 0
- h = (b − a)/n - это один шаг
- yk = f(a + kh); параметр функции f - это a + kh; k - коэфициент от 0 до n
  (предположительно)
находи Y через функцию, затем умножаем на k. Если коэфициент четный, все это умножается
на 2, если нечетный, то на 4, за исключением случая, когда k = 0 или k=n, тогда ничего
не умножаем
- a = нижний порог интегрирования (что бы это не значило)
- b = верхний порог интегрирования
- f - какая-то функция (в нашем случае будет cube)

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (inc n)
    (+ 1 n))

  (define (simpson f a b n)
    (define (h)
      (/ (- b a) n))
    (define (funk k)
      (define (multiplier)
        (cond ((or (= k 0) (= k n)) 1)
              ((even? k) 2)
              (else 4)))
      (* (multiplier) (f (+ a (* k (h))))))
    (* (/ (h) 3)
       (sum funk 0 inc n)))

#+END_SRC

~Упражнение 1.30~
Процедура sum порождает линейную рекурсию. Ее можно переписать так, чтобы суммирование
выполнялось итеративно.

Оригинал:
#+BEGIN_SRC scheme

(define (sum term a next b)
    (if (> a b)
        0
        (+ (term a)
           (sum term (next a) next b))))

#+END_SRC

Мой вариант:
#+BEGIN_SRC scheme
  (define (my-sum term a next b)
    (define (iter a result)
      (if (> a b)
          result
          (iter (next a) (+ result (term a)))))
    (iter a 0))
#+END_SRC

~Упражнение 1.31~
Процедура sum — всего лишь простейшая из обширного множества подобных абстракций,
которые можно выразить через процедуры высших порядков. Напишите аналогичную
процедуру под названием product, которая вычисляет произведение значений функции
в точках на указанном интервале.
Покажите, как с помощью этой процедуры определить factorial.
Кроме того, при помощи product вычислите приближенное значение пи по формуле (см
стр. 73)

Реализовать в двух вариантах: хвостовая и нехвостовая рекурсия.

Формула факториала:
n! = n · (n − 1) · (n − 2) · · · 3 · 2 · 1

Процедура факториала:
#+BEGIN_SRC scheme

  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))

#+END_SRC

#+BEGIN_SRC scheme
  ;; нехвостовая рекурсия
  (define (product f a b next)
    (if (> a b )
        1
        (* (f a)
           (product f (next a) b next))))

  ;; хвостовая рекурсия
  (define (product f a b next)
    (define iter (a result)
      (if (> a b )
          result
          (iter (next a) (* result (term a))))))

  ;; определение факториала
  (define (my-factorial n)
    (define (inc n)
      (+ 1 n ))
    (define (identity x)
      x)
    (product identity 1 n inc))

  ; нахождение pi по формуле Уоллиса
  (define (pi n)
    (define (step x)
      (/ (* x x) (* (- x 1) (+ x 1))))
    (define (pi-next x)
      (+ x 2))
    (* 2.0 (product step 2 n pi-next)))
#+END_SRC


~Упражнение 1.32~
Покажите, что sum и product (упражнение 1.31) являются частными случаями еще более
общего понятия, называемого накопление (accumulation), которое комбинирует множество
термов с помощью некоторой общей функции накопления
(accumulate combiner null-value term a next b)
Accumulate принимает в качестве аргументов те же описания термов и диапазона,
что и sum с product, а еще процедуру combiner (двух аргументов),
которая указывает, как нужно присоединить текущий терм к результату накопления
предыдущих, и null-value, базовое значение, которое нужно использовать, когда термы
закончатся. Напишите accumulate и покажите, как и sum, и product можно определить в
виде простых вызовов accumulate.

Написать как хвостовую и нехвостовую рекурсию.

#+BEGIN_SRC scheme
  ;; хвостовая рекурсия
  (define (accumulate combiner null-value term a next b)
    (define (iter a accum)
      (if (> a b)
          accum
          (iter (next a) (combiner (term a) accum))))
    (iter a null-value))

  ;; нехвостовая рекурсия
  (define (accumulate combiner null-value term a next b)
    (if (> a b )
        null-value
        (combiner (term a)
                   (accumulate combiner null-value
                               term (next a) next b))))

  (define (new-product term a b next)
    (accumulate * 1 term a next b))

  (define (new-sum term a b next)
    (accumulate + 0 term a next b))

  ;; вспомогательные функции, чтоб "поиграться"
  (define (identity x)
    x)

  (define (inc n)
    (+ n 1))

  (define (square x)
    (* x x))
#+END_SRC

~Упражнение 1.33~

Можно получить еще более общую версию accumulate, если ввести понятие
фильтра (filter) на комбинируемые термы. То есть комбинировать только те термы,
порожденные из значений диапазона, которые удовлетворяют указанному условию.
Получающаяся абстракция filtered-accumulate получает те же аргументы, что и accumulate,
плюс дополнительный одноаргументный предикат, который определяет фильтр.
Запишите filtered-accumulate в виде процедуры.
Покажите, как с помощью filtered-accumulate выразить следующее:
а. сумму квадратов простых чисел в интервале от a до b (в предположении, что процедура
prime? уже написана);
б. произведение всех положительных целых чисел меньше n, которые просты по отношению к
n (то есть всех таких положительных целых чисел i < n, что НОД(i, n) = 1).

#+BEGIN_SRC scheme
  (define (filtered-accumulate combiner null-value term a next b filter)
    (define (iter a accum)
      (cond (( > a b) accum)
            ((filter a)
             (iter (next a) (combiner (term a) accum)))
            (else (iter (next a) accum))))
    (iter a null-value 0))

  ;; вспомогательные процедуры для подпунктов а и б
  (define (divides? a b)
    (= (remainder b a) 0))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))

  ;; решение для a
  (define (sum-squares-primes a b )
    (define (inc x)
      (+ 1 x))
    (define (square x) (* x x))
    (filtered-accumulate + 0 square a inc b prime?))

  ;; решение для б
  (define (product-primes-for-n n)
    (define (gcd a b)
      (if (= b 0)
          a
          (gcd b (remainder a b))))
    (define (identity x)
      x)
    (define (inc x)
      (+ 1 x))
    (define (prime-for-n? g)
      (= (gcd g n) 1))
    (filtered-accumulate * 1 identity 1 inc n prime-for-n?))
#+END_SRC

~Упражнение 1.34~
Допустим, мы определили процедуру
#+BEGIN_SRC scheme
  (define (f g)
    (g 2))

  ;; тогда:
  (f square)
  => 4

  (f (lambda (z) (* z (+ z 1))))
  => 6
#+END_SRC

Что случится, если мы (извращенно) попросим интерпретатор вычислить комбинацию (f f)?
Объясните.

Ответ: мой интерпритатор выдал ошибку, думаю, дело в том, что функция должна принимать
1 аргумент. Первый вызов получает в качестве аргумента f функцию f. Функция f
подставляется вместо g, получает в качестве аргумента 2. Мы опускаемся на уровень
вложенности ниже, снова подставляем вместо g переданный параметр. В нашем случае
интерпритатор ожидает, что g - это одноаргументная процедура или предикат, но вместо
этого получает число. Отсюда ошибка.


~Упражнение 1.35~
Покажите, что золотое сечение φ (раздел 1.2.2) есть неподвижная точка трансформации
x→  1 + 1/x, и используйте этот факт для вычисления фи с помощью процедуры fixed-point.

φ^2 = φ + 1 - это формула золотого сечения

#+BEGIN_SRC scheme
  (define tolerance 0.00001)

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

  (fixed-point (lambda (x)
                 (+ 1 (/ 1 x)))
               1.0)

#+END_SRC

~Упражнение 1.36~
Измените процедуру fixed-point так, чтобы она печатала последовательность приближений,
которые порождает, с помощью примитивов newline и display, показанных в упражнении
1.22.

Затем найдите решение уравнения x^x = 1000 путем поиска неподвижной точки
x → log(1000)/ log(x). (Используйте встроенную процедуру Scheme log, которая вычисляет
натуральные логарифмы.) Посчитайте, сколько шагов это занимает при использовании
торможения усреднением и без него. (Учтите, что нельзя начинать fixed-point со значения 1,
поскольку это вызовет деление на log(1) = 0.)

Воспользовалась форматом, поскольку он удобнее.
#+BEGIN_SRC scheme
  (define tolerance 0.00001)

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (format #t "next ~A\n" next)
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

  (define (average x y)
    (/ (+ x y) 2))

  ;; с торможением (работает быстрее)
  (fixed-point (lambda (x)
                 (average x (/ (log 1000) (log x))))
               2.0)

  ;; без
  (fixed-point (lambda (x)
                 (/ (log 1000) (log x)))
               2.0)
#+END_SRC

~Упражнение 1.37~
Бесконечная цепная дробь имеет вид: (см стр. 82)

В качестве примера можно показать, что расширение бесконечной цепной дроби при всех Ni
и Di , равных 1, дает 1/φ, где φ — золотое сечение (описанное в разделе 1.2.2). Один из
способов вычислить цепную дробь состоит в том, чтобы после заданного количества
термов оборвать вычисление. Такой обрыв — так называемая конечная цепная дробь.

Предположим, что n и d — процедуры одного аргумента (номера элемента i),
возвращающие Ni и Di элементов цепной дроби. Определите процедуру cont-frac так,
чтобы вычисление (cont-frac n d k) давало значение k-элементной конечной цепной дроби.
Проверьте свою процедуру, вычисляя приближения к 1/φ с помощью

#+BEGIN_SRC scheme

  (cont-frac (lambda (i) 1.0)
             (lambda (i) 1.0)
             k)
#+END_SRC

Если Ваша процедура cont-frac порождает рекурсивный процесс, напишите вариант, кото-
рый порождает итеративный процесс. Если она порождает итеративный процесс, напишите
вариант, порождающий рекурсивный процесс.

Перевод:
- цепная дробь - это дробь, у которой в знаменателе стоит другая дробь, а у того
тоже стоит дробь и т.д. И так либо пока не встретим конец, тогда это будет конечная
цепная дробь, либо мы конца не будет, и тогда дробь бесконечная.
- если Ni = 1 или Di = 1, то мы имеем 1/φ, где φ — золотое сечение (почему?)
- n и d - это процедуры, принимающие 1 аргумент. Этот аргумент - коэфициент,т.е. i
Процедуры должны вернуть значение N и D с этим коэфициентом.
- процедура cont-frac принимает 2 функции и 1 аргумент, который будет аргументом
для этих функций

#+BEGIN_SRC scheme
  ;; нехвостовая рекурсия
  (define (cont-frac n d k)
    (define (rec i)
      (/ (n i) (+ (d i)
                  (if (> i k )
                      1
                      (rec (+ 1 i))))))
    (rec 1))

  ;; хвостовая
  (define (cont-frac n d k)
    (define (iter i accum)
      (if (> i k)
          accum
          (iter (+ 1 i) (/ (n i) (+ (d i) accum)))))
    (iter 1 1))

  ;; достаточно k = 13, чтоб получить 4 правильных знака после запятой
  (define (g-r k)
    (cont-frac (lambda (i) 1.0)
               (lambda (i) 1.0)
               k))



#+END_SRC

~Упражнение 1.38~
В 1737 году швейцарский математик Леонард Эйлер опубликовал статью De functionibus
Continuis, которая содержала расширение цепной дроби для e − 2, где e — основание
натуральных логарифмов. В этой дроби все N i равны 1, а D i последовательно
равны 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, . . .
Напишите программу, использующую Вашу процедуру cont-frac из упражнения 1.37 для
вычисления e на основании формулы Эйлера.


#+BEGIN_SRC scheme
  ;; вариант по найденной в интернете формуле
  (define (euler-e k)
    (let ((e (cont-frac (lambda (i) 1.0)
                        (lambda (i) (- (* i 4) 2))
                        k)))
      (+ 2 e)))

  ;; подсмотренное
  (define (euler-e k)
    (+ 2 (cont-frac (lambda (i) 1.0)
               (lambda (i)
                 (if (= (remainder i 3) 2)
                     (* 2 (/ (+ i 1) 3))
                     1))
               k)))

  #+END_SRC

~Упражнение 1.39~
Представление тангенса в виде цепной дроби было опубликовано в 1770 году немецким
математиком Й.Х. Ламбертом (см. стр 82), где x дан в радианах. Определите процедуру
(tan-cf x k), которая вычисляет приближение к тангенсу на основе формулы Ламберта.
K указывает количество термов, которые требуется вычислить, как в упражнении 1.37.

#+BEGIN_SRC scheme
  (define (tan-cf x k)
    (define (iter x y i k)
      (- y
         (if (> i k)
             0
             (iter x (+ y 2) (+ i 1) k))))
    (/ x (iter (* x x) 1 1 k)))
#+END_SRC

~Упражнение 1.40~
Определите процедуру cubic, которую можно было бы использовать совместно с процедурой
newtons-method в выражениях вида (newtons-method (cubic a b c) 1)
для приближенного вычисления нулей кубических уравнений x^3 + ax^2 + bx + c.

#+BEGIN_SRC scheme
  (define dx 0.00001)

  (define tolerance 0.00001)

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

  (define (deriv g)
    (lambda (x)
      (/ (- (g (+ x dx)) (g x))
         dx)))

  (define (newton-transform g)
    (lambda (x)
      (- x (/ (g x) ((deriv g) x)))))

  (define (newtons-method g guess)
    (fixed-point (newton-transform g) guess))

  (define (cube x)
    (* x x x))
  (define (square x)
    (* x x))

  (define (cubic a b c)
    (lambda (x)
      (+ (cube x) (* a (square x)) (* b x) c)))

  (newtons-method (cubic 0 0 -8) 1)
#+END_SRC

~Упражнение 1.41~
Определите процедуру double, которая принимает как аргумент процедуру с одним
аргументом и возвращает процедуру, которая применяет исходную процедуру дважды.
Например, если процедура inc добавляет к своему аргументу 1, то (double inc)
должна быть процедурой, которая добавляет 2. Скажите, какое значение возвращает
(((double (double double)) inc) 5)

#+BEGIN_SRC scheme
  (define (double g)
    (lambda (x)
      (g (g x))))

  (define (inc x)
    (+ x 1))

  ((double inc) 1)
#+END_SRC

(((double (double double)) inc) 5) => 21

Чтобы 5 превратилась в 21, нужно, чтоб inc отработал 16 раз (21 - 5 = 16)
Соответственно, нужно, чтоб double сработал 8 раз, что мы и имеем.
Поскольку мой интерпритатор использует нормальный порядок, то сначала
мы подставим все полученные лямбды от в места вызова double (лямбды
окажутся вложенными друг в друга), а затем передадим туда процедуру inc и
аргумент 5, который будет увеличиваться при подъеме от самого низкого уровня
вложенности до самого высокого.

~Упражнение 1.42~
Пусть f и g — две одноаргументные функции. По определению, композиция (composition) f и
g есть функция x → f (g(x)).
Определите процедуру compose которая реализует
композицию.
Например, если inc — процедура, добавляющая к своему аргументу 1,
((compose square inc) 6) => 49

#+BEGIN_SRC scheme
  (define (compose f g)
    (lambda (x)
      (f (g x))))

  (define (inc x)
    (+ x 1))

  (define (square x)
    (* x x))
#+END_SRC

~Упражнение 1.43~
Если f есть численная функция, а n — положительное целое число, то мы можем построить
n-кратное применение f , которое определяется как функция, значение которой в точке x
равно f (f (. . . (f (x)) . . .)).
Например, если f есть функция x → x + 1, то n-кратным применением f
будет функция x → x + n. Если f есть операция возведения в квадрат, то n-кратное
применение f есть функция, которая возводит свой аргумент в 2n-ю степень.
Напишите процедуру, которая принимает в качестве ввода процедуру, вычисляющую f ,
и положительное целое n, и возвращает процедуру, вычисляющую n-кратное применение f .
Требуется, чтобы Вашу процедуру можно было использовать в таких контекстах:
((repeated square 2) 5) => 625
Подсказка: может оказаться удобно использовать compose из упражнения 1.42.

Иными словами, процедра должна принимать функцию и кол-во раз, сколько эту функцию
надо применить к аргументу. А возвращать должна процеудуру, которая применяет
фнкцию к аргументу заданное кол-во раз.
#+BEGIN_SRC scheme
  (define (inc x)
    (+ x 1))

  (define (square x)
    (* x x))

  (define (repeated f n)
    (lambda (x)
      (define (test x n)
        (if (= n 0)
            x
            (test (f x) (- n 1))))
      (test x n)))

  ((repeated square 2) 5) => 625
  ((repeated inc 19) 5) => 24

#+END_SRC

~Упражнение 1.44~
Идея сглаживания (smoothing a function) играет важную роль в обработке сигналов. Если f
— функция, а dx — некоторое малое число, то сглаженная версия f есть функция, значение
которой в точке x есть среднее между f (x − dx), f (x) и f (x + dx).
Напишите процедуру smooth, которая в качестве ввода принимает процедуру,
вычисляющую f , и возвращает процедуру, вычисляющую сглаженную версию f . Иногда бывает
удобно проводить повторное сглаживание (то есть сглаживать сглаженную функцию и т.д.),
получая n-кратно сглаженную функцию (n-fold smoothed function).
Покажите, как породить n-кратно сглаженную функцию с помощью smooth и
repeated из упражнения 1.43.

#+BEGIN_SRC scheme
  (define (inc x)
    (+ x 1))

  (define (square x)
    (* x x))

  (define (smooth f)
    (define dx 0.01)
    (lambda (x)
      (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))

  (define (repeated f n)
    (lambda (x)
      (define (test x n)
        (if (= n 0)
            x
            (test (f x) (- n 1))))
      (test x n)))

  ((repeated (smooth square) 2) 5)
#+END_SRC

~Упражнение 1.45~.
В разделе 1.3.3 мы видели, что попытка вычисления квадратных корней путем наивного
поиска неподвижной точки y → x/y не сходится, и что это можно исправить путем торможения
усреднением. Тот же самый метод работает для нахождения кубического корня как
неподвижной точки y → x/y^2 , заторможенной усреднением.
К сожалению, этот процесс не работает для корней четвертой степени — однажды
примененного торможения усреднением недостаточно, чтобы заставить сходиться процесс
поиска неподвижной точки y → x/y^3 . С другой стороны, если мы применим торможение
усреднением дважды (т.е. применим торможение усреднением к результату торможения
усреднением от y → x/y^3 ), то поиск неподвижной точки начнет сходиться. Проделайте
эксперименты, чтобы понять, сколько торможений усреднением нужно, чтобы вычислить
корень n-ой степени как неподвижную точку на основе многократного торможения усреднением
функции y → x/y n−1 . Используя свои результаты для того, напишите простую процедуру
вычисления корней n-ой степени с помощью процедур fixed-point, average-damp и repeated
из упражнения 1.43. Считайте, что все арифметические операции, какие Вам понадобятся,
присутствуют в языке как примитивы.

#+BEGIN_SRC scheme
  (define (inc x)
    (+ x 1))

  (define (square x)
    (* x x))

  (define tolerance 0.00001)

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))


  (define (average x y)
    (/ (+ x y) 2))

  ;; вычисляет среднее между иксом и результатом, который мернет функция с параметром
  ;; икс
  (define (average-damp f)
    (lambda (x) (average x (f x))))

  (define (repeated f n)
    (lambda (x)
      (define (test x n)
        (if (= n 0)
            x
            (test (f x) (- n 1))))
      (test x n)))

  ((repeated sqrt 2) 16)

  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))

  (define (log2 x)
      (/ (log x) (log 2)))

  (define (nth-root-empirical n x)
    (define (f y) (/ x (fast-expt y (- n 1))))
    (define damp-count (floor (log2 n)))
    (fixed-point ((repeated average-damp damp-count) f) 1.0))
#+END_SRC

~Упражнение 1.46~
Некоторые из вычислительных методов, описанных в этой главе, являются примерами
чрезвычайно общей вычислительной стратегии, называемой пошаговое улучшение
(iterative improvement). Пошаговое улучшение состоит в следующем: чтобы что-то
вычислить, нужно взять какое-то  начальное значение, проверить, достаточно ли оно
хорошо, чтобы служить ответом, и если нет, то улучшить это значение и продолжить
процесс с новым значением. Напишите процедуру iterative-improve, которая принимает
в качестве аргументов две процедуры: проверку, достаточно ли хорошо значение,
и метод улучшения значения. Iterative-improve должна возвращать процедуру,
которая принимает начальное значение в качестве аргумента и улучшает его, пока оно не
станет достаточно хорошим.
Перепишите процедуру sqrt из раздела 1.1.7 и процедуру fixed-point из раздела 1.3.3 в
терминах iterative-improve.

#+BEGIN_SRC scheme
  (define (iterative-improve check method)
    (lambda (x)
      (define (try x)
        (let ((next (method x)))
          (format #t "x ~A next ~A\n" x next)
          (if (check x next)
              next
              (try next))))
      (try x)))

  (define (new-fixed-point f first-guess)
    (define tolerance 0.00001)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    ((iterative-improve close-enough? f) first-guess))

  (define (new-sqrt x)
    (define tolerance 0.00001)
    (define (average x y)
      (/ (+ x y) 2))
    ((iterative-improve (lambda (guess next)
                          (format #t "guess ~A next ~A x ~A\n" guess next x)
                          (< (abs (- (square next) x))
                             tolerance))
                        (lambda (guess)
                          (average guess (/ x guess)))) 1.0))

#+END_SRC

~Упражнение 2.1~
Определите улучшенную версию mul-rat, которая принимала бы как положительные, так и
отрицательные аргументы. Make-rat должна нормализовывать знак так, чтобы в случае, если
рациональное число положительно, то и его числитель, и знаменатель были бы
положительны, а если оно отрицательно, то чтобы только его числитель был отрицателен.

#+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (numer x) (car x))
  (define (denom x) (cdr x))

  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  (define (make-rat n d)
    (let ((g (gcd n d)))
      (if (< g 0)
          (cons (/ n (abs g)) (/ d g))
          (cons (/ n g) (/ d g)))))

#+END_SRC


~Упражнение 2.2~
Рассмотрим задачу представления отрезков прямой на плоскости. Каждый отрезок
представляется как пара точек: начало и конец. Определите конструктор make-segment
и селекторы start-segment и end-segment, которые определяют представление отрезков
в терминах точек. Далее, точку можно представить как пару чисел: координата x и
координата y. Соответственно, напишите конструктор make-point и селекторы x-point и
y-point, которые определяют такое представление. Наконец, используя свои селекторы и
конструктор, напишите процедуру midpoint-segment, которая принимает отрезок в качестве
аргумента и возвращает его середину (точку,координаты которой являются средним
координат концов отрезка). Чтобы опробовать эти процедуры, Вам потребуется способ
печатать координаты точек:
#+BEGIN_SRC scheme

  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

#+END_SRC

Есть какая-то плоскость. На ней располагаются отрезки. Каждый отрезок - это начальная
и конечная точка.
#+BEGIN_SRC scheme
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")\n"))

  (define (y-point point)
    (cdr point))

  (define (x-point point)
    (car point))

  (define (make-point x y)
    (cons x y))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-segment start end)
    (cons start end))

  (define (midpoint-segment segment)
    (let ((start (start-segment segment))
          (end (end-segment segment)))
      (print-point (make-point (/ (+ (x-point start) (x-point end)) 2)
                               (/ (+ (y-point start) (y-point end)) 2)))))

  (midpoint-segment (cons (cons 10 20) (cons 30 80)))
#+END_SRC

~Упражнение 2.3~
Реализуйте представление прямоугольников на плоскости. (Подсказка: Вам могут
потребоваться результаты упражнения 2.2.) Определите в терминах своих конструкторов
и селекторов процедуры, которые вычисляют периметр и площадь прямоугольника.
Теперь реализуйте другое представление для прямоугольников. Можете ли Вы спроектировать
свою систему с подходящими барьерами абстракции так, чтобы одни и те же процедуры
вычисления периметра и площади работали с любым из Ваших представлений?

#+BEGIN_SRC scheme
  (define (P sqaure-figure)
    (let* ((length-segment (car sqaure-figure))
           (height-segment (cdr sqaure-figure))
           (start-length (start-segment length-segment))
           (end-length (end-segment length-segment))
           (start-height (start-segment height-segment))
           (end-height (end-segment height-segment))
           (length (- (x-point end-length) (x-point start-length)))
           (height (- (y-point end-height) (y-point start-height))))
      (* (+ length height) 2)))

  (define (square sqaure-figure)
    (let* ((length-segment (car sqaure-figure))
           (height-segment (cdr sqaure-figure))
           (start-length (start-segment length-segment))
           (end-length (end-segment length-segment))
           (start-height (start-segment height-segment))
           (end-height (end-segment height-segment))
           (length (- (x-point end-length) (x-point start-length)))
           (height (- (y-point end-height) (y-point start-height))))
      (* length height)))


  ;; P и S квадрата
  (P (cons (cons (make-point 10 20) (make-point 40 20))
           (cons (make-point 40 20) (make-point 40 50))))

  (square (cons (cons (make-point 10 20) (make-point 40 20))
                (cons (make-point 40 20) (make-point 40 50))))

  ;; P и S прямоугольника
  (P (cons (cons (make-point 10 20) (make-point 40 20))
           (cons (make-point 40 20) (make-point 40 80))))

  (square (cons (cons (make-point 10 20) (make-point 40 20))
                (cons (make-point 40 20) (make-point 40 80))))
#+END_SRC

~Упражнение 2.4~
Вот еще одно процедурное представление для пар. Проверьте для этого представления, что
при любых двух объектах x и y (car (cons x y)) возвращает x.

Каково соответствующее определение cdr?
(Подсказка: Чтобы проверить, что это работает, используйте подстановочную модель из
раздела 1.1.5.)

#+BEGIN_SRC scheme
  (define (test-cons x y)
    ;; видимо m - это процедура от двух аргументов
    (lambda (m)
      (m x y)))

  (define (test-car z)
    ;; лямбда принимает 2 аргумента
    ;; и возвращает первый
    (z (lambda (p q) p)))

  (define (test-cdr z)
    ;; лямбда принимает 2 аргумента
    ;; и возвращает второй11
    (z (lambda (p q) q)))


  (test-car (test-cons 1 2))
  (test-cdr (test-cons 1 2))
#+END_SRC

~Упражнение 2.5~
Покажите, что можно представлять пары неотрицательных целых чисел, используя только
числа и арифметические операции, если представлять пару a и b как произведение 2^a
3^b. Дайте соответствующие определения процедур cons, car и cdr.

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))

  (define (crazy-cons a b)
    (* (fast-expt 2 a) (fast-expt 3 b)))

  (define (crazy-car pair)
    (find-value 2 pair))

  (define (find-value base value)
    (define (iter value count)
      (if (= (remainder value base) 0)
          (iter (/ value base) (+ 1 count))
          count))
    (iter value 0))

#+END_SRC

~Упражнение 2.6~
Если представление пар как процедур было для Вас еще недостаточно сумасшедшим, то
заметьте, что в языке, который способен манипулировать процедурами, мы можем обойтись
и без чисел (по крайней мере, пока речь идет о неотрицательных числах), определив
0 и операцию прибавления 1 так:

#+BEGIN_SRC scheme
  (define zero
    (lambda (f) (lambda (x) x)))

  ((zero +) 4)

  ;; n - какая-то функция, которая принимает другую фукцию на вход
  (define (add-1 n)
    (lambda (f)
      (lambda (x)
        (f ((n f) x)))))

  (add-1 zero)
  (lambda (f)
    (lambda (x)
      (f (((lambda (f) (lambda (x) x)) f) x))))

  (lambda (f)
    (lambda (x)
      (f ((lambda (x) x) x))))

  (define (one f)
    (lambda (f)
      (lambda (x) (f x))))

  (add-1 one)
  (define (two f)
    (lambda (f)
      (lambda (x)
        (f (((lambda (f)
               (lambda (x) (f x))) f) x)))))

  n раз применить s к применённому m раз s к z
  (add-1 add-1)
  (define (Plus m n)
    (lambda (f x)
      (m f (n f x))))
#+END_SRC

Такое представление известно как числа Чёрча (Church numerals), по имени его
изобретателя, Алонсо Чёрча, того самого логика, который придумал λ-исчисление.
Определите one (единицу) и two (двойку) напрямую (не через zero и add-1).
(Подсказка: вычислите (add-1 zero) с помощью подстановки.)
Дайте прямое определение процедуры сложения +
(не в терминах повторяющегося применения add-1).

~Упражнение 2.7.~
Программа Лизы неполна, поскольку она не определила, как реализуется абстракция
интервала.
Вот определение конструктора интервала:
(define (make-interval a b) (cons a b))
Завершите реализацию, определив селекторы upper-bound и lower-bound.

исходник:
#+BEGIN_SRC scheme
  (define (make-interval a b)
    (cons a b))

  (define (upper-bound n)
    (cdr n))

  (define (lower-bound n)
    (car n))

  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (upper-bound y)))
          (p4 (* (upper-bound x) (lower-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (mul-interval x
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))

#+END_SRC

~Упражнение 2.8~
Рассуждая в духе Лизы, опишите, как можно вычислить разность двух интервалов. Напишите
соответствующую процедуру вычитания, называемую sub-interval.

#+BEGIN_SRC scheme
  (define (sub-interval x y)
    (cond ((and (> (lower-bound x) (lower-bound y))
                (> (upper-bound x) (upper-bound y)))
           (make-interval (- (lower-bound x) (lower-bound y))
                          (- (upper-bound x) (upper-bound y))))
          ((and (< (lower-bound x) (lower-bound y))
                (< (upper-bound x) (upper-bound y)))
           (make-interval (- (lower-bound y) (lower-bound x))
                          (- (upper-bound y) (upper-bound x))))
          ((and (> (lower-bound x) (lower-bound y))
                (< (upper-bound x) (upper-bound y)))
           (make-interval (- (lower-bound x) (lower-bound y))
                          (- (upper-bound y) (upper-bound x))))
          (else (make-interval (- (lower-bound y) (lower-bound x))
                               (- (upper-bound x) (upper-bound y))))))
#+END_SRC

~Упражнение 2.9~
Радиус (width) интервала определяется как половина расстояния между его верхней и
нижней границами. Радиус является мерой неопределенности числа, которое обозначает
интервал. Есть такие математические операции, для которых радиус результата зависит
только от радиусов интервалов-аргументов, а есть такие, для которых радиус результата
не является функцией радиусов аргументов.
Покажите, что радиус суммы (или разности) двух интервалов зависит только от
радиусов интервалов, которые складываются (или вычитаются). Приведите примеры, которые
показывают, что для умножения или деления это не так.

Предположим есть интервал (2 . 8) Его радиус будет равен 3, посольку это половина
расстояния от 2 до 8.

#+BEGIN_SRC scheme
  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))

  (define A (cons 2.0 5.0))
  (define B (cons 4.0 8.0))

  ;; радиусы равны
  (width (add-interval A B))
  (+ (width A) (width B))

  ;; радиусы не равны
  (width (mul-interval A B))
  (* (width A) (width B))

#+END_SRC

~Упражнение 2.10.~
Бен Битобор, системный программист-эксперт, смотрит через плечо Лизы и замечает:
неясно, что должно означать деление на интервал, пересекающий ноль.
Модифицируйте код Лизы так, чтобы программа проверяла это условие и сообщала об ошибке,
если оно возникает.

#+BEGIN_SRC scheme

(define (my-div-interval x y)
    (if (or (<= (lower-bound x) 0) (<= (lower-bound y) 0)
            (<= (upper-bound y) 0)  (<= (upper-bound x) 0))
        (display "error!\n")
        (let ((p1 (/ (lower-bound x) (lower-bound y)))
              (p2 (/ (lower-bound x) (upper-bound y)))
              (p3 (/ (upper-bound x) (upper-bound y)))
              (p4 (/ (upper-bound x) (lower-bound y))))
          (make-interval (min p1 p2 p3 p4)
                         (max p1 p2 p3 p4)))))

#+END_SRC

~Доделать! Упражнение 2.11~
Проходя мимо, Бен делает туманное замечание: «Если проверять знаки концов интервалов,
можно разбить mul-interval на девять случаев, из которых только в одном требуется
более двух умножений». Перепишите эту процедуру в соответствии с предложением Бена.

- проверить знаки на концах интервалов
- реализовать конд, в котором будет 9 случаев
- 9ый - else, в котором будет более 2х умножений

#+BEGIN_SRC scheme
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (upper-bound y)))
          (p4 (* (upper-bound x) (lower-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))


  (define A (cons 2.0 5.0))
  (define B (cons 4.0 8.0))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (upper-bound y)))
          (p4 (* (upper-bound x) (lower-bound y))))
      (format #t "p1 ~A p2 ~A p3 ~A p4 ~A\n" p1 p2 p3 p4)
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (my-mul-interval x y)
    (cond ((and (< (lower-bound x) 0) (> (upper-bound y) 0) (> (upper-bound x) 0))
           (make-interval (* (lower-bound x) (upper-bound y)) (* (upper-bound y)
                                                                 (upper-bound x))))
          ((and (< (lower-bound y) 0) (> (upper-bound x) 0) (> (upper-bound y) 0))
           (make-interval (* (lower-bound y) (upper-bound x)) (* (upper-bound y)
                                                                 (upper-bound x))))
          ((and (> (lower-bound x) 0) (< (upper-bound y) 0) (> (upper-bound x) 0)
                (> (lower-bound y) 0))
                (make-interval (* (lower-bound x) (upper-bound y)) (* (lower-bound y)
                                                                      (upper-bound x))))
          ((and (> (lower-bound x) 0) (< (upper-bound y) 0) (> (upper-bound x) 0)
                (> (lower-bound y) 0))
           (make-interval (* (lower-bound x) (upper-bound y)) (* (lower-bound y)
                                                                 (upper-bound x))))


#+END_SRC

~Упражнение 2.12~
Определите конструктор make-center-percent, который принимает среднее значение и по-
грешность в процентах и выдает требуемый интервал. Нужно также определить селектор
percent, который для данного интервала выдает погрешность в процентах.
Селектор center остается тем же, что приведен выше.

#+BEGIN_SRC scheme
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))

  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))

  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))

  (define (percent i)
    (let* ((c (center i))
           (inaccuracy (- (upper-bound i) c)))
           (* (/ inaccuracy c) 100)))

  (define (make-center-percent c p)
    (let ((inaccuracy (* (/ c 100) p)))
      (make-interval (- c inaccuracy) (+ c inaccuracy))))

#+END_SRC

~Упражнение 2.13~
Покажите, что, если предположить, что погрешность составляет малую долю величины
интервала, то погрешность в процентах произведения двух интервалов можно получить
из погрешности в процентах исходных интервалов по простой приближенной формуле.
Задачу можно упростить, если предположить, что все числа положительные.

- берем интервалы с небольшой погрешностью
- умножаем интервалы друг на друга
- получаем погрешность в процентах
- считаем погрешность в процентах у одного исходного интервала и у другого
- доказать, что погрешность у интервала-произведения можно получить из
  интервалов-исходников по приближенной формуле (какой?)

#+BEGIN_SRC scheme
  (define A (make-center-percent 40.0 3.0))
  (define B (make-center-percent 30.0 3.0))

  ;; процент погрешности при произведении 2х исходных интервалов примерно = проценту
  ;; погрешности при складывании погрешностей и исходных интервалов
  ;; (если изначальная погрешность не более 10%)
  (percent (mul-interval A B))
  (+ (percent A) (percent B))

#+END_SRC

~Упражнение 2.14~
Покажите, что Дайко прав. Исследуйте поведение системы на различных арифметических
выражениях. Создайте несколько интервалов A и B и вычислите с их помощью выражения A/A
и A/B. Наибольшую пользу Вы получите, если будете использовать интервалы, радиус которых
составляет малую часть от среднего значения.
Исследуйте результаты вычислений в форме центр/проценты.
(См. упр 2.12)

То есть надо найти интервалы с небольшим разбросом и работать с ними.

#+BEGIN_SRC scheme

  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
                  (add-interval r1 r2)))

  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval one
                    (add-interval (div-interval one r1)
                                  (div-interval one r2)))))

  ;; Проверка:
  (define A (cons 2 5))
  (define B (cons 4 8))

  (percent (par2 A A))
  = 42.857142857142854

  (percent (par2 A B))
  = 39.53488372093024

  (percent (par1 A B))
  = 83.09859154929579

  (percent (par1 A A))
  = 87.96992481203006

  (center (par1 A A))
  = 3.325

  (center (par2 A A))
  = 1.75

  (center (par2 A B))
  = 2.205128205128205

  (center (par1 A B))
  = 3.6410256410256405
#+END_SRC

~Упражнение 2.15~
Ева Лу Атор, другой пользователь Лизиной программы, тоже заметила, что алгебраически
эквивалентные, но различные выражения могут давать разные результаты. Она говорит, что
формула для вычисления интервалов, которая использует Лизину систему, будет
давать более узкие границы погрешности, если ее удастся записать так, чтобы ни одна
переменная, представляющая неточную величину, не повторялась. Таким образом, говорит
она, par2 «лучше» как программа для параллельных резисторов, чем par1.
Права ли она? Почему?

Ответ: логично предположить, что чем больше неточных данных мы используем, тем больше
общая неточность результата. Поскольку par2 использует только 2 неточные величины
вместо четырех, мы можем сказать, что par2 лучше.

~Упражнение 2.16~
Объясните в общем случае, почему эквивалентные алгебраические выражения могут давать
разные результаты. Можете ли Вы представить себе пакет для работы с интервальной
арифметикой, который бы не обладал этим недостатком, или такое невозможно?
(Предупреждение: эта задача очень сложна.)

Ответ: например, дело может быть в особенностях хранения цифр с плавающей
запятой. Из-за, казалось бы, эквивалентных алгебраических действий, неточность может
накапливаться и приводить к разным результатам.

Решение подобной проблемы - это задать меру точности, т.е. сколько знаком после запятой
мы будем оставлять на каждом этапе вычисления.

~Упражнение 2.17.~
Определите процедуру last-pair, которая возвращает список, содержащий только последний
элемент данного (непустого) списка.
(last-pair (list 23 72 149 34))
= (34)

#+BEGIN_SRC scheme
  (define (last-pair lst)
    (list-ref lst (- (length lst) 1)))
#+END_SRC

~Упражнение 2.18~
Определите процедуру reverse, которая принимает список как аргумент и возвращает
список, состоящий из тех же элементов в обратном порядке:
(reverse (list 1 4 9 16 25))
(25 16 9 4 1)

#+BEGIN_SRC scheme
  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))
#+END_SRC

~Упражнение 2.19.~
Рассмотрим программу подсчета способов размена из раздела 1.2.2. Было бы приятно иметь
возможность легко изменять валюту, которую эта программа использует, так, чтобы можно
было, например, вычислить, сколькими способами можно разменять британский фунт.
Эта программа написана так, что знание о валюте распределено между процедурами
first-denomination и count-change (которая знает, что существует пять видов
американских монет). Приятнее было бы иметь возможность просто задавать список монет,
которые можно использовать при размене.
Мы хотим переписать процедуру cc так, чтобы ее вторым аргументом был список монет, а не
целое число, которое указывает, какие монеты использовать. Тогда у нас могли бы быть
списки, определяющие типы валют:
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
Можно было бы вызывать cc следующим образом:
(cc 100 us-coins)
= 292
Определите процедуры first-denomination, except-first-denomination и no-more? в
терминах элементарных операций над списковыми структурами. Влияет ли порядок списка
coin-values на результат, получаемый cc? Почему?
#+BEGIN_SRC scheme
  (define (no-more? coin-values)
    (if (null? coin-values)
        #t
        #f))

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc amount
                  (except-first-denomination coin-values))
              (cc (- amount
                     (first-denomination coin-values))
                  coin-values)))))

  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))

  (cc 100 us-coins)
#+END_SRC

Ответ: порядок в списке coin-values не влияет на результат, потому что важен не порядок
элементов, а их общее количество. Например, если в список добавить еще один элемент,
то количество вариантов размена изменится.

~Упражнение 2.20~
Используя точечную нотацию, напишите процедуру same-parity, которая принимает одно или
более целое число и возвращает список всех тех аргументов, у которых четность та же,
что у первого аргумента. Например,
(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)
(same-parity 2 3 4 5 6 7)
(2 4 6)

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (same-parity n . nums)
    (let ((lst (list n)))
      (define (iter nums new-lst)
        (cond ((null? nums) (reverse new-lst))
              ((and (even? (car nums)) (even? (car new-lst)))
               (iter (cdr nums) (cons (car nums) new-lst)))
              ((and (not (even? (car nums))) (not (even? (car new-lst))))
               (iter (cdr nums) (cons (car nums) new-lst)))
              (else (iter (cdr nums) new-lst))))
      (iter nums lst)))
#+END_SRC

~Упражнение 2.21~
Процедура square-list принимает в качестве аргумента список чисел и возвращает список
квадратов этих чисел.
(square-list (list 1 2 3 4))
(1 4 9 16)
Перед Вами два различных определения square-list. Закончите их, вставив пропущенные вы-
ражения:

#+BEGIN_SRC scheme
  ;; первый вариант решения без map
  (define (square-list items)
    (define (iter items lst)
      (if (null? items)
          (reverse lst)
          (iter (cdr items) (cons (* (car items) (car items)) lst))))
    (iter items (list)))

  ;; правильный вариант
  (define (square-list items)
    (if (null? items)
        #nil
        (cons (* (car items) (car items))
              (square-list (cdr items)))))

  (define (square-list items)
    (map (lambda (x)  (* x x))
         items))
#+END_SRC

~Упражнение 2.22~
Хьюго Дум пытается переписать первую из процедур square-list из упражнения 2.21 так,
чтобы она работала как итеративный процесс. К сожалению, такое определение square-list
выдает список результатов в порядке, обратном желаемому. Почему?
Затем Хьюго пытается исправить ошибку, обменяв аргументы cons, но этот вариант так же
не срабатывает, объясните, почему.

В первом случае список выходит перевернутым, поскольку элемент, который мы добавляем к
списку с помощью cons, добавляется в начало списка. Если же попытаться поменять
аргументы cons местами, то мы попытаемся приклеить элементк концу списка. Только конец
списка - это не его последний элемент, а nil. В результате мы получаем пару, а не
склеенный список.


~Упражнение 2.23.~
Процедура for-each похожа на map. В качестве аргументов она принимает процедуру и спи-
сок элементов. Однако вместо того, чтобы формировать список результатов, for-each
просто применяет процедуру по очереди ко всем элементам слева направо.
Результаты применения процедуры к аргументам не используются вообще — for-each
применяют к процедурам, которые осуществляют какое-либо действие вроде печати.
Например,
(for-each (lambda (x) (newline) (display x))
(list 57 321 88))
57
321
88
Значение, возвращаемое вызовом for-each (оно в листинге не показано) может быть каким
угодно, например истина. Напишите реализацию for-each.

#+BEGIN_SRC scheme
  (define (for-each fn lst)
    (if (null? lst)
        #nil
        (and (fn (car lst)) (for-each fn (cdr lst)))))
#+END_SRC

~Упражнение 2.24~
Предположим, мы вычисляем выражение (list 1 (list 2 (list 3 4))). Укажите, какой
результат напечатает интерпретатор, изобразите его в виде стрелочной диаграммы, а также
его интерпретацию в виде дерева (как на рисунке 2.6)

#+BEGIN_SRC scheme
  (list 1 (list 2 (list 3 4)))

  = (1 (2 (3 4)))
#+END_SRC

~Упражнение 2.25~
Укажите комбинации car и cdr, которые извлекают 7 из следующих списков:

#+BEGIN_SRC scheme
  ;; (1 3 (5 7) 9)

  (car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9))))))

  ;; ((7))

  (car (car (list (list 7))))

  ;; (1 (2 (3 (4 (5 (6 7))))))

  (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))))
#+END_SRC

~Упражнение 2.26~.
Допустим, мы определили x и y как два списка.
Какой результат напечатает интерпретатор в ответ на следующие выражения:
#+BEGIN_SRC scheme
  (define x (list 1 2 3))
  (define y (list 4 5 6))

  (append x y)
  = (1 2 3 4 5 6)

  (cons x y)
  = ((1 2 3) 4 5 6)

  (list x y)
  = ((1 2 3) (4 5 6))
#+END_SRC

~Упражнение 2.27.~
Измените свою процедуру reverse из упражнения 2.18 так, чтобы получилась процедура
deep-reverse, которая принимает список в качестве аргумента и возвращает в качестве
значения список, где порядок элементов обратный и подсписки также обращены.

#+BEGIN_SRC scheme
  ;; например:

  (define x (list (list 1 2) (list 3 4)))

  x
  = ((1 2) (3 4))

  (reverse x)
  = ((3 4) (1 2))

  (deep-reverse x)
  = ((4 3) (2 1))

  ;; решение:

  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))

  (define (deep-reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (reverse (car lst)) new-lst))))
    (iter lst (list)))
#+END_SRC

~Упражнение 2.28.~
Напишите процедуру fringe, которая берет в качестве аргумента дерево (представленное в
виде списка) и возвращает список, элементы которого — все листья дерева, упорядоченные
слева направо.

#+BEGIN_SRC scheme
  ;; Например

  (define x (list (list 1 2) (list 3 4)))

  (fringe x)
  = (1 2 3 4)

  (fringe (list x x))
  = (1 2 3 4 1 2 3 4)

  ;; решение
  (define (fringe lst)
    (if (pair? lst)
        (append (fringe (car lst)) (fringe (cdr lst)))
        (if (null? lst)
            #nil
            (list lst))))
#+END_SRC

~Упражнение 2.29~
Бинарный мобиль состоит из двух ветвей, левой и правой. Каждая ветвь представляет собой
стержень определенной длины, с которого свисает либо гирька, либо еще один бинарный
мобиль.
Мы можем представить бинарный мобиль в виде составных данных, соединив две ветви
(например, с помощью ~list~):

#+BEGIN_SRC scheme
(define (make-mobile left right)
(list left right))
#+END_SRC

Ветвь составляется из длины ~length~ (которая должна быть числом) и структуры
~structure~, которая может быть либо числом (представляющим простую гирьку),
либо еще одним мобилем

#+BEGIN_SRC scheme
(define (make-branch length structure)
(list length structure))
#+END_SRC

а. Напишите соответствующие селекторы ~left-branch~ и ~right-branch~, которые возвраща-
ют левую и правую ветви мобиля, а также ~branch-length~ и ~branch-structure~, которые
возвращают компоненты ветви.
б. С помощью этих селекторов напишите процедуру ~total-weight~, которая возвращает общий
вес мобиля.
в. Говорят, что мобиль сбалансирован, если момент вращения, действующий на его левую
ветвь, равен моменту вращения, действующему на правую ветвь (то есть длина левого
стержня, умноженная на вес груза, свисающего с него, равна соответствующему
произведению для правой стороны), и если все подмобили, свисающие с его ветвей,
также сбалансированы. Напишите предикат, который проверяет мобили на
сбалансированность.

Будем считать мобиль своеобразным неупорядоченным бинарным деревом.
Исходя из идеи, что соединение 2х веток с помощью list дает мобиль, скажем, что
левая ветка - это car, а правая - cdr списка.
Аналогично с компонентами ветви. Каждый узел ветви - эт длина + структура. Значит,
длина ветви (узла?) - это car текущего подсписка, а структура - cadr. Использование
cadr позволяет убрать один уровень вложенности.


~total-weight~ должна вернуть общий вес мобиля, т.е. пройтись по каждой структуре,
дойти до "гирек" и суммировать значения.


#+BEGIN_SRC scheme
  (define test-mobile
    (make-mobile (make-branch 10 (make-branch 10 (make-branch 10 13)))
                 (make-branch 10 (make-branch 10 (make-branch 10 18)))))

  (define test2-mobile
    (make-mobile (make-branch 10 (make-branch 10 (make-branch 10 (make-branch 10 20))))
                 (make-branch 10 (make-branch 10 (make-branch 10 18)))))

  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (cadr mobile))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (cadr branch))

  (define (total-weight mobile)
    (define (iter mobile)
      (cond ((and (pair? mobile)
                  (pair? (left-branch mobile))
                  (pair? (right-branch mobile)))
             (+ (iter (right-branch mobile))
                (iter (left-branch mobile))))
            ((and (pair? mobile) (pair? (right-branch mobile)))
                  (iter (right-branch mobile)))
            ((and (pair? mobile) (pair? (left-branch mobile)))
                  (iter (left-branch mobile)))
            (else (right-branch mobile))))
    (iter mobile))

  (define (balanced? mobile)
    (cond ((and (pair? mobile)
                (pair? (left-branch mobile))
                (pair? (right-branch mobile)))
           ( = (balanced? (right-branch mobile))
               (balanced? (left-branch mobile))))
          ((and (pair? mobile) (pair? (right-branch mobile)))
           (balanced? (right-branch mobile)))
          ((and (pair? mobile) (pair? (left-branch mobile)))
           (balanced? (left-branch mobile)))
          (else (*  (branch-length mobile) (branch-structure mobile)))))

#+END_SRC

г. Допустим, мы изменили представление мобилей, так что конструкторы теперь приняли
такой вид:

#+BEGIN_SRC scheme
(define (make-mobile left right)
(cons left right))

(define (make-branch length structure)
(cons length structure))
#+END_SRC

Как много пришлось поменять в остальной программе?
Ответ: пришлось поменять только селекторы.
#+BEGIN_SRC scheme
  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (cdr mobile))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (cdr branch))

#+END_SRC

~Упражнение 2.30~
Определите процедуру square-tree, подобную процедуре square-list из упражнения 2.21. А
именно, square-tree должна вести себя следующим образом:

#+BEGIN_SRC scheme
  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))
  = (1 (4 (9 16) 25) (36 49))

  (define (square-tree tree)
    (define (square x)
      (* x x))
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (square-tree sub-tree)
               (square sub-tree)))
         tree))

  (define (square-tree tree)
    (define (square x)
      (* x x))
    (cond ((null? tree) #nil)
          ((not (pair? tree)) (square tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))
#+END_SRC

~Упражнение 2.31~
Абстрагируйте свой ответ на упражнение 2.30, получая процедуру tree-map, так, чтобы
square-tree можно было определить следующим образом:
(define (square-tree tree) (tree-map square tree))

#+BEGIN_SRC scheme
  (define (square-tree tree)
    (define (square x)
      (* x x))
    (tree-map square tree))

  (define (tree-map fn tree)
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (tree-map fn sub-tree)
               (fn sub-tree)))
         tree))

#+END_SRC

~Упражнение 2.32.~
Множество можно представить как список его различных элементов, а множество его
подмножеств как список списков. Например, если множество равно (1 2 3), то множество его
подмножеств равно (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)).
Закончите следующее определение процедуры, которая порождает множество подмножеств
и дайте ясное объяснение, почему она работает:

#+BEGIN_SRC scheme
  (define (subsets s sp)
    (if (null? s)
        (list #nil)
        (let ((rest (subsets (cdr s) (+ 1 sp))))
          (space sp)
          (format #t "~A\n" rest)
          (space sp)
          (format #t "~A\n" s)
          (append rest (map (lambda (x)
                              (if (pair? s)
                                  (and (cons (cdr s) x) (cons (car s) x))
                                  (cons s x))) rest)))))
#+END_SRC

Сначала я предположила, что элементы, которые содержатся в ~rest~ нужно просто обернуть
в список. Но в ~rest~ перманентно содержится nil. Тогда я поняла, что элементы содержит
что-то еще. В нашем случае это ~s~, я подумала, что следует соединить элементы из  ~s~
и ~rest~ с помощью cons, результат был уже ближе, но все еще не тот.
Тогда я поняла, что в конечном результате есть закономерность: элементы из ~rest~
последовательно соединяется с ~car~ и ~cdr~ возвращенной последовательности, если это
последовательность. Так удалось написать верную лямбду.

О работе процедуры:
Чтобы образовать множество, нам нужно откатиться к концу исходной последовательности,
а затем начать последовательно комбинировать элементы друг с другом. Для этого мы
сначала рекурсивно вызваем ~subsets~ с cdr последовательности, таким образом мы доходим
до конца списка. Достигнув его, возвращаем nil, который попадает в ~rest~ как
возвращаемое значение рекурсии, и начинаем откатываться назад по стеку вызовов. Прежде
чем вызвать любую функцию, программе нужно запомнить состояние параметров, чтоб
вернуться к исходному состоянию стека, которое было до вызова функции, и корректно
продолжить работу. Соответственно, состояние ~s~, которая хранит в себе
последовательность, тоже сохраняется на стеке перед каждым рекурсивным вызовом. А при
откате назад значения восстанавливаются. Так в ~s~ постепенно попадает исходная
последовательность и и это позволяет написанной мною лямбде работать.


~Упражнение 2.33.~
Заполните пропущенные выражения, так, чтобы получились определения некоторых базовых
операций по работе со списками в виде накопления:

#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))


  (define (my-map p sequence)
    (accumulate (lambda (x y)
                  (cons (p x) y)) (list) sequence))

  (my-map (lambda (x) (*  x x)) (list 1 2 3 4))

  ;; вторая последовательность является базовым значением для
  ;; нового append, поскольку если первая последовательность окажется пустой
  ;; реальный append вернет вторую
  (define (my-append seq1 seq2)
    (accumulate cons seq2 seq1))

  (my-append (list 1 2 3 4) (list 4 5 6 7))

  ;; достигнув конца списка мы возвращаем 0, который при откате назад по стеку
  ;; вызовов будет восприниматься как возвращаемое значение вызова и займет место параметра Y
  (define (my-length sequence)
    (accumulate (lambda (x y)
                 (+ y 1)) 0 sequence))

  (my-length (list 1 2 3 4))
#+END_SRC

~Упражнение 2.34.~
Вычисление многочлена с переменной x при данном значении x можно сформулировать в виде
накопления. Мы вычисляем многочлен
AnX^n + An−1X^n−1 + . . . + A1x + A0
по известному алгоритму, называемому схема Горнера (Horner’s rule).

(. . . (AnX + An−1 )X + . . . + A1 )X + A0 )

Другими словами, мы начинаем с An , умножаем его на x, и так далее, пока не достигнем
A0.
Заполните пропуски в следующей заготовке так, чтобы получить процедуру, которая
вычисляет многочлены по схеме Горнера. Предполагается, что коэффициенты многочлена
представлены в виде последовательности, от A0 до An .

#+BEGIN_SRC scheme

  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms)
                  (+ this-coeff (* x higher-terms)))
                0
                coefficient-sequence))

  ;; Например, чтобы вычислить 1 + 3x + 5x^3 + x^5 в точке x = 2, нужно ввести
  ;; возможно, нули стоят потому, что нет икса в первой степени...
  (horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

~Упражнение 2.35~
Переопределите count-leaves из раздела 2.2.2 в виде накопления.

Видимо, map должна собрать все листья (т.е. все непары)  и вернуть последовательность,
состоющую из листьев, после чего мы посчитаем их количество. Идея оказалась неверной.
Во-первых, map не может работать с деревьями, нужно было рекурсивно обойти дерево на
каждой итерации прохода по дереву. Но даже после того, как это удалось реализовать,
список результатов, возвращенный map, содержал вложенные списки. С которыми не может
работать и accumulate, поэтому пришлось рекурсивно обходить список и при подсчете
листов. В общем, громоздко, не понятно, не работало.

Нужно было разделить дерево на подпоследовательности и возвращать не список листьев,
а список единиц, где единица - это каждый найденный лист. Т.к. map проходит по
подпоследовательности и, встретив лист, записывает в список результатов 1. А затем все
значения в списке суммируются.


#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (format #t "~A\n" sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  ;; исходный вариант
  (define (count-leaves x)
    (cond ((null? x) 0)
          ((not (pair? x)) 1)
          (else (+ (count-leaves (car x))
                   (count-leaves (cdr x))))))
  ;; новый вариант
  (define (count-leaves tree)
    (accumulate + 0 (map (lambda (x)
                           (if (pair? x)
                               (count-leaves x)
                               1))
                         tree)))

#+END_SRC


~Упражнение 2.36.~
Процедура ~accumulate-n~ подобна ~accumulate~, только свой третий аргумент она
воспринимает как последовательность последовательностей, причем предполагается,
что все они содержат одинаковое количество элементов. Она применяет указанную процедуру
накопления ко всем первым элементам последовательностей, вторым элементам
последовательностей и так далее, и возвращает последовательность результатов.
Например, если ~s~ есть последовательность, состоящая из четырех последовательностей,
((1 2 3) (4 5 6) (7 8 9) (10 11 12)), то значением (accumulate-n + 0 s)
будет последовательность (22 26 30).
Заполните пробелы в следующем определении accumulate-n.

Ясно, что в ~accumulate-n~ третьим аргументом всегда должна быть последовательность
последовательностей. Cитуация, когда car последовательности оказался
пустым списком, возможно только если список стал похож на (()).

Это значит, что нужно постепенно вытаскивать из каждого подсписка по элементу,
пока они не станут пустыми.

Вариант написать 2 процедуры: одна выстаскивает каждый раз из всех подсписков списка,
другая делает то же, но с cdr. Так пришла идея использовать ~map~

#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        #nil
        (cons (accumulate op init (map (lambda (x)
                                         (car x)) seqs))
              (accumulate-n op init (map (lambda (x)
                                           (cdr x)) seqs)))))

  (define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))

  (accumulate-n + 0 s)
#+END_SRC

~Упражнение 2.37.~
Заполните пропуски в следующих процедурах для вычисления остальных матричных операций.

#+BEGIN_SRC scheme
  (define mat (list (list 1 2 3) (list 4 5 6)))
  (define vec (list 10 11 12))
  (define mat2 (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))

  ;; скалярное произведение
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))

  ;; произведение матрицы и вектора
  ;; чтоб умножить матрицу на ветор, нужно умножить первый компонент вектора
  ;; на все первые элементы строк матрицы, потом так же второй и т.д., а потом сложить
  ;; значения в каждой строке матрицы. Так получится новый вектор.
  (define (matrix-*-vector m v)
    (map (lambda (x)
           (dot-product v x)) m))

  ;; транспозиция матрицы
  ;; для получения транспонированной матрицы из исходной нужно каждую строчку исходной
  ;; матрицы записать в виде столбца в том же порядке
  (define (transpose mat)
    (accumulate-n (lambda (x y)
                    (cons x y)) #nil mat))

  ;; произведение матриц
  ;; кол-во строк в матрице А должно совпадать с кол-вом столбцов в матрице В
  (define mat-A (list (list 1 2 2) (list 3 1 1)))
  (define mat-B (list (list 4 2) (list 3 1) (list 1 5)))

  ;; сначала я думала, что надо задать 2 идентичные по размеру матрицы, но потом поняла, что
  ;; следует задавать матрицы так, как мы бы делали от руки, т.к. по правилу, описанному выше
  ;; А транспозиция превратит вторую матрицу в идентичную первой по размеру. И таким образом
  ;; мы сможем представить матрицы как набор векторов.
  ;; А раз это набор векторов, то можно использовать скалярное произведение. Все завернуто в
  ;; в list, чтоб можно было использовать append, тогда все красиво выводится.
  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (x)
             (append (list (dot-product (car cols) x)) (list (dot-product (cadr cols) x))))
           m)))
#+END_SRC

~Упражнение 2.38.~
Процедура accumulate известна также как fold-right (правая свертка), поскольку она
комбинирует первый элемент последовательности с результатом комбинирования
всех элементов справа от него.
Существует также процедура fold-left (левая свертка), которая подобна
fold-right, но комбинирует элементы в противоположном направлении.
Каковы значения следующих выражений?

Укажите свойство, которому должна удовлетворять op, чтобы для любой последовательности
fold-right и fold-left давали одинаковые результаты.

Ответ: op должно быть коммутативно, т.е. чтоб порядок аргументов для предиката не имел
значения

#+BEGIN_SRC scheme
    (define (fold-left op initial sequence)
      (define (iter result rest)
        (if (null? rest)
            result
            (iter (op result (car rest))
                  (cdr rest))))
      (iter initial sequence))

    ;; раз fold-right подобна accumulate, то и выражения я проверяла с помощью accumulate
    (fold-right / 1 (list 1 2 3))
    = 3/2

    (fold-left / 1 (list 1 2 3))
    = 1/6

    (fold-right list #nil (list 1 2 3))
    = (1 (2 (3 #nil)))

    (fold-left list #nil (list 1 2 3))
    = (((#nil 1) 2) 3)


  ;; Пример для ответа:
  (accumulate * 1 (list 1 2 3))
  (fold-left * 1 (list 1 2 3))
#+END_SRC

~Упражнение 2.39~
Закончите следующие определения reverse (упражнение 2.18) в терминах процедур fold-
right и fold-left из упражнения 2.38.

#+BEGIN_SRC scheme
  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))

  (define (reverse-right sequence)
    (accumulate (lambda (x y) (append y (list x))) #nil sequence))

  (define (reverse-left sequence)
    (fold-left (lambda (x y) (cons y x)) #nil sequence))
#+END_SRC

~Упражнение 2.40.~
Определите процедуру unique-pairs, которая, получая целое число n, порождает последова-
тельность пар (i, j), таких, что 1 ≤ j < i ≤ n. С помощью unique-pairs упростите данное
выше определение prime-sum-pairs.

i = n - 1 или n
j = диапазон от 1<=j до i - 1
нужно породить пары i и j. 2 вложенных чикла, которые будут выполняться, пока i не
достигнет значение n и n-1

для каждого целого i ≤ n перечислить целые числа j < i, и для каждых таких i и j
породить пару (i, j)

Фактически меня просят разбить процедуру на подпроцедуры, чтоб ее стало проще
воспринимать.

У автора процедура ~enumerate-interval~ встроена в стандарт его схемы, мне же ее
пришлось написать.

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))

  ;; отсюда начинается определение процедуры мана. Все функции до этого места вспомогательны,
  ;; рассчитано, что они уже залиты в интерпритатор, поэтому они просто используются по ходу
  ;; книги

  (define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))

  (define (flatmap proc seq)
    (accumulate append #nil (map proc seq)))

  (define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

  (define (enumerate-interval start end)
    (if (< start end)
        (cons start (enumerate-interval (+ 1 start) end))
        (list end)))

  ;; исходный вариант
  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum?
                 (flatmap
                  ;; сюда попадает последовательность
                  (lambda (i)
                    ;; для каждого i получаем пару (i j), где j всегда меньше i
                    (map (lambda (j) (list i j))
                         (enumerate-interval 1 (- i 1))))
                  ;; порождаем последовательность от 1 до n
                  (enumerate-interval 1 n)))))


  (define (unique-pairs n)
    (flatmap
     ;; сюда попадает последовательность
     (lambda (i)
       ;; для каждого i получаем пару (i j), где j всегда меньше i
       (map (lambda (j) (list i j))
            (enumerate-interval 1 (- i 1))))
     ;; порождаем последовательность от 1 до n
     (enumerate-interval 1 n)))

  ;; мой вариант
  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum?
                 (unique-pairs n))))
#+END_SRC

~Упражнение 2.41.~
Напишите процедуру, которая находит все такие упорядоченные тройки различных
положительных целых чисел i, j и k, меньших или равных данному целому числу n,
сумма которых равна данному числу s.

i, j ,k <= n
найти такие i j k, которые при сложении дадут s. собрать их в последоватлеьность
значит, надо сгенерировать 3 последовтаельности, где числа <=n.
затем попробовать сложить
Пусть последовательности разворачиваются в разных порядках: две от n до 1,
а одна от 1 до n

#+BEGIN_SRC scheme
  (define (new-enumerate-interval end start)
    (if (> end start)
        (cons end (new-enumerate-interval (- end 1) start))
        (list start)))

  (define (flatmap proc seq)
    (accumulate append #nil (map proc seq)))

  ;; вариант с грязным хаком
  ;; как состоит в использовании cond. но так есть возможность предусмотреть все варианты
  (define (find-sum s n)
    (define (sum? seq)
      (format #t "i ~A j ~A k ~A\n" (car seq) (cadr seq) (cadr (cdr seq)))
      (= s (+ (car seq) (cadr seq) (cadr (cdr seq)))))
    (filter sum?
            (flatmap
             (lambda (i)
               (map (lambda (j k)
                      (cond ((sum? (list (+ i) j k)) (list (+ i) j k))
                            ((sum? (list i (+ 1 j) k)) (list i (+ j) k))
                            ((sum? (list i (- j 1) k)) (list i (- j 1) k))
                            ((sum? (list (- i 1) j k)) (list (- i) j k))
                            (else (list i j k))))
                    (enumerate-interval 1 n) (new-enumerate-interval n 1)))
             (new-enumerate-interval n 1))))


  ;; подсмотренный вариант без грязного хака
  ;; но мне кажется, что мой более правильный в плане того, что у меня
  ;; i, j , k могут быть = n, а у этого решения j и k никогда не будут = n
  ;; к тому же, у него отсутствуют некоторые варианты слагаемых суммы
  ;; если, к примеру, вызвать (triples-with-sum 10 8), то будут отсутствовать варианты
  ;; (6 2 2), (8 1 1) и т.д. а у меня они есть ;)

  (define (unique-triples n)
    (flatmap (lambda (i)
               (flatmap (lambda (j)
                          (map (lambda (k) (list i j k))
                               (enumerate-interval 1 (- j 1))))
                        (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))

  (define (triples-with-sum s n)
  (filter (lambda (t) (= (accumulate + 0 t) s))
                    (unique-triples n)))
#+END_SRC


~Упражнение 2.42.~
В «задаче о восьми ферзях» спрашивается, как расставить на шахматной доске восемь
ферзей так, чтобы ни один из них не бил другого (то есть никакие два ферзя не должны
находиться на одной вертикали, горизонтали или диагонали).
Один из способов решать эту задачу состоит в том, чтобы идти поперек доски,
устанавливая по ферзю в каждой вертикали. После того, как k − 1 ферзя мы уже
разместили, нужно разместить k-го в таком месте, где он не бьет ни одного из тех,
которые уже находятся на доске. Этот подход можно сформулировать рекурсивно:
предположим, что мы уже породили последовательность из всех возможных способов
разместить k − 1 ферзей на первых k − 1 вертикалях доски. Для каждого из этих способов
мы порождаем расширенный набор позиций, добавляя ферзя на каждую горизонталь k-й
вертикали. Затем эти позиции нужно отфильтровать, оставляя только те, где
ферзь на k-й вертикали не бьется ни одним из остальных. Продолжая этот процесс, мы
породим не просто одно решение, а все решения этой задачи.

Это решение мы реализуем в процедуре ~queens~, которая возвращает последовательность ре-
шений задачи размещения n ферзей на доске n × n. В процедуре queens есть внутренняя
процедура ~queen-cols~, которая возвращает последовательность всех способов разместить
ферзей на первых k вертикалях доски.
В этой процедуре ~rest-of-queens~ есть способ размещения k − 1 ферзя на первых k − 1
вертикалях, а ~new-row~ — это горизонталь, на которую предлагается поместить ферзя с k-й
вертикали.
Завершите эту программу, реализовав представление множеств позиций ферзей на доске,
включая процедуру ~adjoin-position~, которая добавляет нового ферзя на определенных
горизонтали и вертикали к заданному множеству позиций, и empty-board, которая
представляет пустое множество позиций. Еще нужно написать процедуру safe?,
которая для множества позиций определяет, находится ли ферзь с k-й вертикали в
безопасности от остальных. (Заметим, что нам требуется
проверять только то, находится ли в безопасности новый ферзь — для остальных ферзей
безопасность друг от друга уже гарантирована.)

Бередом доску 8 на 8. Расставляем на ней 7 ферзей по вертикалям (пофиг, что сейчас они
все бьют друг друга). Теперь нужно придумать, как поставить восьмого ферзя так, чтоб
его не могли быть ни один из уже стоящих на доске.

Как это сделать? Нужна рекурсия.
- мы уже разместили всех ферзей по вертикалям всеми возможными способами
- для каждого из этих вариантов мы получаем набор вариантов, добавляя по ферзю на
  каждую горизонталь текущей вертикали.
- затем фильтруем позици, оставляя только те, где ферзь на конкретной вертикали не
  бьется никаким из остальных ферзей

Функция filter похожа на map, но: работает с последовательностями, которые состоят из
подпоследовательностей. Применяет к подспискам предикат, и если предикат дает t,
включает подсписок в список результатов

Написать safe, adjoin-position и empty-board
Сначала мы получаем пустые вертикали (видимо).



#+BEGIN_SRC scheme
  ;; возвращает последовательность, которая отображает все варианты постановки ферзей
  ;; принимает число клеток доски по вертикали или горизонтали
  ;; т.е. если ввести 8, то мы получим доску 8х8
  (define (queens board-size)
    ;; возвращает последовательность, которая отображает все варианты
    ;; расстановки ферзей по вертикали
    (define (queen-cols k)
      (if (= k 0)
          ;; empty-board должна представлять пустое множество позиций
          ;; видимо, должна эмулировать пустую доску
          (list empty-board)
          (filter
           ;; предикат фильтра
           (lambda (positions)
             (format #t "lambda k ~A positions ~A\n" k positions)
             (safe? k positions))
           ;; это должно вернуть некую последовательность из всех
           ;; вариантов расстановки ферзей
           (flatmap
            ;; rest-of-queens - это последовательность (?)
            ;; способов расставить k - 1 ферзей на k-1 вертикалях
            (lambda (rest-of-queens)
              ;; new-row - горизонталь, на которую нужно поставить ферзя
              ;; с конкретной вертикали
              (map (lambda (new-row)
                     ;; adjoin-position добавляет нового ферзя на определенную клетку
                     (adjoin-position new-row k rest-of-queens))
                   ;; это список горизонталей
                   (enumerate-interval 1 board-size)))
            (queen-cols (- k 1))))))
    ;; первый вызов функции
    (queen-cols board-size))

  (define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        ;; empty-board должна представлять пустое множество позиций
        ;; видимо, должна эмулировать пустую доску
        (list empty-board)
         (flatmap
          ;; rest-of-queens - это последовательность (?)
          ;; способов расставить k - 1 ферзей на k-1 вертикалях
          (lambda (rest-of-queens)
            ;; new-row - горизонталь, на которую нужно поставить ферзя
            ;; с конкретной вертикали
            (map (lambda (new-row)
                   ;; adjoin-position добавляет нового ферзя на определенную клетку
                   (adjoin-position new-row k rest-of-queens))
                 ;; это список горизонталей
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1)))))
  (queen-cols board-size))

  (define (even? n)
    (= (remainder n 2) 0))

  (filter (lambda (pair)
            (format #t "~A\n" pair)
            (even? (+ (car pair) (cadr pair))))
            (list (list 2 3) (list 3 3) (list 5 3)))

  ;; предположим так мы ставим ферзя на заданную позицию
  (define (adjoin-position new-row k rest-of-queens)
    (cons new-row rest-of-queens))

  ;; у нее нет никаких аргументов. с чем она может работать?
  ;; предположим, что пустое множество - это nil
  (define empty-board
    (list))

  ;; как проверить, стоит ли ферзь в безопасности?
  (define (safe? k positions)
    (format #t "lambda k ~A positions ~A\n" k positions)
    (not (or (= k (car positions)) (= k (cdr positions)))))

 #+END_SRC

~Упражнение 2.44.~
Определите процедуру up-split, которую использует corner-split. Она подобна right-
split, но только меняет местами роли below и beside.

beside - получает на вход 2 процедуры отрисовки и порождает отрисовку, которая
рисует в правой половине листа рисунок первой отрисовки, а в левой - второй

below - получает на вход 2 процедуры отрисовки и порождает отрисовку, которая
рисует в верхней половине листа рисунок первой отрисовки, а в нижней - второй

#+BEGIN_SRC scheme
  ;; позволяет дробить рисунок вправо, т.е. левую половину листа будет занимать сам паттерн,
  ;; следующее изображение паттерна будет занимать правую верхнюю четверть листа, потом
  ;; половину от нижней четверти и т.д. пока лист не кончится
  (define (right-split painter n)
    (if (= n 0)
        painter
        (let ((smaller (right-split painter (- n 1))))
          (beside painter (below smaller smaller)))))

  (define (up-split (painter n))
    (if (= n 0)
        painter
        (let ((smaller (up-split painter (- n 1))))
          (below painter (beside smaller smaller)))))

  ;; порождает сбалансированные узоры, позволяя наращивать их вверх
  (define (corner-split painter n)
    (if (= n 0)
        painter
        (let ((up (up-split painter (- n 1)))
              (right (right-split painter (- n 1))))
          (let ((top-left (beside up up))
                (bottom-right (below right right))
                (corner (corner-split painter (- n 1))))
            (beside (below painter top-left)
                    (below bottom-right corner))))))

#+END_SRC

~Упражнение 2.45.~
Right-split и up-split можно выразить как разновидности общей операции разделения.
Определите процедуру split с таким свойством, что вычисление

(define right-split (split beside below))
(define up-split (split below beside))

порождает процедуры right-split и up-split с таким же поведением, как и определенные
ранее.

сплит - общая операция разделения. нам явно нужна рисовлка, которую мы будем делить и
указание, как мы ее будем делить
получает 2 аргумента на вход
должен быть рекурсивный проход
при этом right-split и up-split перестали получать на вход аргументы.
аргументы beside и below - это 2 рисовлки у каждой
значит, split должна породить другую процедуру, которая принимает на вход
рисовалку-паттерн и кол-во раз, которое скажет нам, сколько раз разделить картинку,
а затем отрисует наш паттерн так, как мы укажем на входе split

#+BEGIN_SRC scheme

  (define (split painter1 painter2)
      (define (split-iter patern-paiter n)
        (if (= n 0)
            patern-paiter
            (let ((smaller (split patern-paiter (- n 1))))
              (painter1 patern-paiter (painter2 smaller smaller))
              )))
      split-iter)

#+END_SRC

~Упражнение 2.46.~

Двумерный вектор v, идущий от начала координат к точке, можно представить в виде пары,
состоящей из x-координаты и y-координаты. Реализуйте абстракцию данных для векторов,
написав конструктор ~make-vect~ и соответствующие селекторы ~xcor-vect~ и ~ycor-vect~.
В терминах своих селекторов и конструктора реализуйте процедуры ~add-vect~, ~sub-vect~
и ~scale-vect~, которые выполняют операции сложения, вычитания векторов и умножения
вектора на скаляр.

#+BEGIN_SRC scheme
  (define (make-vect x y)
    (cons x y))

  (define (xcor-vect v)
    (car v))

  (define (ycor-vect v)
    (cdr v))

  (define (add-vect v1 v2)
    (make-vect (+ (xcor-vect v1) (xcor-vect v2))
               (+ (ycor-vect v1) (ycor-vect v2))))

  (define (sub-vect v1 v2)
    (make-vect (- (xcor-vect v1) (xcor-vect v2))
               (- (ycor-vect v1) (ycor-vect v2))))

  (define (scale-vect v scale)
    (make-vect (* scale (xcor-vect v))
               (* scale (ycor-vect v))))

  (define v1 (make-vect 3 7))
  (define v2 (make-vect 2 4))

  (ycor-vect v1)
  (xcor-vect v2)
  (add-vect v1 v2)
  (sub-vect v1 v2)
  (scale-vect v1 3)
#+END_SRC

~Упражнение 2.47.~
Вот два варианта конструкторов для рамок.
К каждому из этих конструкторов добавьте соответствующие селекторы, так, чтобы получить
реализацию рамок.

цитата из мана:
каким образом представляются рамки; нужно только сказать, что
есть конструктор make-frame, который принимает три вектора и выдает рамку, и что
есть еще три селектора, ~origin-frame~, ~edge1-frame~ и ~edge2-frame~

видимо, нужно написать такие селекторы, чтоб можно было получить из списка, который
представляет собой рамку, origin, edge1 и edge2

#+BEGIN_SRC scheme
  ;; вариант 1
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (cadr frame))

  (define (edge2-frame frame)
    (cdr (cdr frame)))

  (define frame1 (make-frame (make-vect 0 3) (make-vect 1 8) (make-vect 2 6)))
  (origin-frame frame1)
  (edge1-frame frame1)
  (edge2-frame frame1)

  ;; вариант 2
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))

  ;; первые два селектора идентичны у первого и второго вариантов
  (define (edge2-frame frame)
    (cadr (cdr frame)))
#+END_SRC

~Упражнение 2.48.~
Направленный отрезок на плоскости можно представить в виде пары векторов: вектор от
начала координат до начала отрезка и вектор от начала координат до конца отрезка.
Используйте свое представление векторов из упражнения 2.46 и определите
представление отрезков с конструктором ~make-segment~ и селекторами ~start-segment~ и
~end-segment~.

#+BEGIN_SRC scheme
  (define (make-segment v1 v2)
    (make-vect v1 v2))

  (define (start-segment segment)
    (xcor-vect segment))

  (define (end-segment segment)
    (ycor-vect segment))

  (define segment (make-segment (make-vect 3 4) (make-vect 8 10)))

  (start-segment segment)
  (end-segment segment)
#+END_SRC

~Упражнение 2.49.~
С помощью segments->painter определите следующие элементарные рисовалки:

а. Рисовалку, которая обводит указанную рамку.
б. Рисовалку, которая рисует «Х», соединяя противоположные концы рамки.
в. Рисовалку, которая рисует ромб, соединяя между собой середины сторон рамки.
г. Рисовалку wave.

Рисовалка "х":
чтоб соединить противоположные концы рамки, нужно получить вектор, параллельный вектору
edge2, так мы получим третью сторону рамки, от которой можно провести линию по
диагонали
edge3 - назовем новую сторону так, от edge2 будет отличаться только координатой икс:
игреки у них будут одинаковые. Коодината иксбудет совпадать с edge1
после того, как мы получим третью сторону, останется соединить координату вектор
третьей стороны и ветор orgigin, образовав отрезок таким образом, а затем вектор edge2
и edge1. Так полчится нарисовать "x".

Рисовалка "ромб":
для рисовалки нам понадобятся все 4 строны рамки. найдем середину у каждой стороны,
затем создадим отрезки и передадим в процеудуру

Рисовалка wave.
Из решения последуюих упражнений стало ясно, что нужно передавать функции отрисовки
коркнетные координаты (от 0 до 1), а не переменные.
#+BEGIN_SRC scheme
  ;; frame-coord-map к рамке дает нам процедуру, которая,
  ;; получая вектор, возвращает тоже вектор. Если вектор-аргумент находится в единичном
  ;; квадрате, вектор-результат окажется в рамке.

  ;; чтоб получить рамку, надо иметь 3 ветора и единичный квадрат - это такой квадрат,
  ;; где сторона x >= 0, а y <=1. затем по вот такой формуле преобразуем это  рамку
  ;; Origin(Frame) + x · Edge 1 (Frame) + y · Edge 2 (Frame)

  ;; draw-line рисует отрезок между двумя точками. т.е. надо сформировать координаты
  ;; отрезка (два вектора) и передать ей

  ;; все процедуры для операций над векторами и сегментами следует искать в двух
  ;; предыдущих упражнениях
  (define (frame-coord-map frame)
    (lambda (v)
      (add-vect
       (origin-frame frame)
       (add-vect (scale-vect (xcor-vect v)
                             (edge1-frame frame))
                 (scale-vect (ycor-vect v)
                             (edge2-frame frame))))))

  (define (segments->painter segment-list)
    (lambda (frame)
      ;; применяем процедуру к каждому сегменту
      (for-each
       (lambda (segment)
         (draw-line
          ((frame-coord-map frame) (start-segment segment))
          ((frame-coord-map frame) (end-segment segment))))
       segment-list)))

  (define (rhomb frame)
    (let* ((edge3 (make-vect (xcor-vect (edge1-frame frame))
                             (ycor-vect (edge2-frame frame))))
           (edge4 (xcor-vect edge3)
                  (ycor-vect (edge2-frame frame)))
           (origin-edge1-middle (make-vect (/ (xcor-vect (edge1-frame frame)) 2)
                                           (ycor-vect (edge1-frame frame))))
           (edge1-edge3-middle (make-vect (xcor-vect edge3)
                                          (/ (ycor-vect edge3) 2)))
           (edge2-edge3-middle (make-vect (/ (xcor-vect edge3) 2)
                                          (ycor-vect edge3)))
           (origin-edge2-middle (make-vect (xcor-vect (origin-frame frame)))
                                           (/ (ycor-vect (edge2-frame frame)) 2)))

           (segm-list (list (make-segment origin-edge1-middle
                                          edge1-edge3-middle)
                            (make-segment edge1-edge3-middle
                                          edge2-edge3-middle)
                            (make-segment edge2-edge3-middle
                                          origin-edge2-middle)
                            (make-segment origin-edge2-middle
                                          origin-edge1-middle)))
           ((segments->painter segm-list) frame)))

  (define (cross frame)
    (let* ((edge3 (make-vect (xcor-vect (edge1-frame frame))
                             (ycor-vect (edge2-frame frame))))
           (segm-list (list (make-segment edge3 (origin-frame frame))
                            (make-segment (edge2-frame frame) (edge1-frame frame)))))
      ((segments->painter segm-list) frame)))

  (define (draw-frame frame)
    (let* ((edge3 (make-vect (xcor-vect (edge1-frame frame))
                             (ycor-vect (edge2-frame frame))))
           (edge4 (xcor-vect (edge3-frame frame))
                  (ycor-vect (edge2-frame frame)))
           (segm-list (list (make-segment (edge1-frame frame) (origin-frame frame))
                            (make-segment (edge2-frame frame) (origin-frame frame))
                            (make-segment (edge2-frame frame) edge3)
                            (make-segment (edge1-frame frame) edge3)))
           ((segments->painter segm-list) frame))))

  ;; чтоб не генерировать каждый отрезок, создадим вспомогательные функции. Например,
  ;; функцию, генерирующую ломанную линию

  ;; это довольно тупое задание, суть которого - приблизительно прикинуть координаты отрезков. Доделаю его позже.

  (define (wave frame)
  (let* ((head (make-vector

#+END_SRC

~попытка написать растор~

#+BEGIN_SRC scheme
  (define in (open-input-file "in.txt"))

  (read-line in)

  ;; написатьв файл
  (define draw
  (call-with-output-file "in.txt"
    (lambda (p)
      (format p " I am\n"))))

  ;; прочитать из файла
  (call-with-input-file "in.txt"
    (lambda (p)
      (let f ((x (read p)))
        (if (eof-object? x)
            '()
                      (cons x (f (read p)))))))

#+END_SRC

~Упражнение 2.50.~
Определите преобразование flip-horiz, которое обращает изображение вокруг
горизонтальной оси, а также преобразования, которые вращают рисовалки против
часовой стрелки на 180 и 270 градусов.

#+BEGIN_SRC scheme
  (define (transform-painter painter origin corner1 corner2)
    (lambda (frame)
      (let ((m (frame-coord-map frame)))
        (let ((new-origin (m origin)))
          (painter
           (make-frame new-origin
                       (sub-vect (m corner1) new-origin)
                       (sub-vect (m corner2) new-origin)))))))

  (define (rotate90 painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 0.0)))

  (define (rotate180 painter)
    (transform-painter painter
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 1.0)
                       (make-vect 1.0 0.0)))

  (define (rotate270 painter)
    (transform-painter painter
                       (make-vect 0.0 1.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.0 1.0)))

  (define (flip-horiz painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.0 1.0)))
#+END_SRC


~Упражнение 2.51.~
Определите для рисовалок операцию below. Below принимает в качестве аргументов две ри-
совалки. Когда получившейся рисовалке передается рамка, она рисует в нижней ее половине
при помощи первой рисовалки, а в верхней при помощи второй. Определите below двумя
способами — один раз аналогично процедуре beside, как она приведена выше, а второй раз
через beside и операции вращения (см. упражнение 2.50).

#+BEGIN_SRC scheme
  ;; beside из мана
  (define (beside painter1 painter2)
    (let ((split-point (make-vect 0.5 0.0)))
      (let ((paint-left
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                split-point
                                (make-vect 0.0 0.1)))
            (paint-right
             (transform-painter painter2
                                split-point
                                (make-vect 1.0 0.0)
                                (make-vect 0.5 1.0)))
            (lambda (frame)
              (paint-left frame)
              (paint-right frame))))))

  ;; вариант 1
  (define (below painter1 painter2)
    (let ((split-point (make-vect 0.0 0.5)))
      (let ((paint-down
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                (make-vect 1.0 0.0)
                                split-point))
            (paint-up
             (transform-painter painter2
                                split-point
                                (make-vect 1.0 0.5)
                                (make-vect 0.0 1.0)))
            (lambda (frame)
              (paint-down frame)
              (paint-up frame))))))

  (define (below painter1 painter2)
    (let* ((new-painter (beside (rotate270 painter1) (rotate270 painter2)))
           (below-painter (rotate90 new-painter)))
      (lambda (frame)
        (below-painter frame))))

#+END_SRC


~Упражнение 2.52.~
Измените предел квадрата рисовалки wave, показанный на рисунке 2.9, работая на каждом
из вышеописанных уровней. А именно:
а. Добавьте новые отрезки к элементарной рисовалке wave из упражнения 2.49 (например,
изобразив улыбку). (доделаю этот кусок, когда сделаю wave)
б. Измените шаблон, который порождает corner-split (например, используя только одну
копию образов up-split и right-split вместо двух).
в. Измените версию square-limit, использующую square-of-four, так, чтобы углы компо-
новались как-нибудь по-другому. (Например, можно сделать так, чтобы большой мистер
Роджерс выглядывал из каждого угла квадрата.)

#+BEGIN_SRC scheme
  ;; изначальный вариант
  ;; видимо цель не просто заполнить рамку изображениями, но и сделать
  ;; окаймовку изображением по краям рамки
  (define (corner-split painter n)
    (if (= n 0)
        painter
        ;; наращиваем изображение вверх
        (let ((up (up-split painter (- n 1)))
              ;; наращиваем изображение вправо
              (right (right-split painter (- n 1))))
          ;; наращиваем изображение влево
          (let ((top-left (beside up up))
                ;; наращиваем изображение вниз
                (bottom-right (below right right))
                ;; повторяем, пока не заполним всю рамку
                (corner (corner-split painter (- n 1))))
            (beside (below painter top-left)
                    (below bottom-right corner))))))

  ;; используем 1 копию образов вместо двух, как сказано в задании
  (define (corner-split painter n)
    (if (= n 0)
        painter
        (let ((up (up-split painter (- n 1)))
              (right (right-split painter (- n 1))))
          (let ((corner (corner-split painter (- n 1))))
            (beside (below painter up)
                    (below right corner))))))
  ;; задание "в"
  ;; изначальный вариант
  (define (square-of-four tl tr bl br)
    (lambda (painter)
      (let ((top (beside (tl painter) (tr painter)))
            (bottom (beside (bl painter) (br painter))))
        (below bottom top))))

  (define (square-limit painter n)
    (let ((combine4 (square-of-four flip-horiz identity
                                    rotate180 flip-vert)))
      (combine4 (corner-split painter n))))

  ;; мой вариант
  (define (square-limit painter n)
    (let ((combine4 (square-of-four flip-vert identity
                                    rotate180 flip-horiz)))
      (combine4 (corner-split painter n))))
#+END_SRC

~Упражнение 2.53.~
Что напечатает интерпретатор в ответ на каждое из следующих выражений?
#+BEGIN_SRC scheme
  (list 'a 'b 'c)
  = (a b c)

  (list (list 'george))
  = ((george))

  (cdr '((x1 x2) (y1 y2)))
  = ((y1 y2))

  (cadr '((x1 x2) (y1 y2)))
  =(y1 y2)

  (pair? (car '(a short list)))
  = #f

  (memq 'red '((red shoes) (blue socks)))
  = #f

  (memq 'red '(red shoes blue socks))
  =(red shoes blue socks)
#+END_SRC

~Упражнение 2.54.~
Предикат ~equal?~ для двух списков возвращает истину, если они содержат одни и те же
элементы в одинаковом порядке.
Например,
~(equal? '(this is a list) '(this is a list))~ истинно, но
~(equal? '(this is a list) '(this (is a) list))~ ложно.
Более точно, можно определить equal? рекурсивно в терминах базового равенства
символов eq?, сказав, что a равно b, если оба они символы и для них выполняется eq? либо
оба они списки и при этом верно, что (car a) равняется в смысле ~equal?~ (car b),
а (cdr a) равняется в смысле equal? (cdr b).
Пользуясь этой идеей, напишите ~equal?~ в виде процедуры.

- eq? берет 2 символа и проверяет, равны ли они (имеют один и тот же набор печатных
  знаков, которые стоят в одинаковом порядке)
- нужна рекурсия
- два списка равны если:
  символ "а" равен символу "б"
  либо они оба списки и при этом у них равны car-ы b cdr-ы
-
#+BEGIN_SRC scheme

  (define (equal? lst1 lst2)
    (cond ((and (not (pair? lst1)) (not (pair? lst2)) (eq? lst1 lst2)) #t)
          ((and (pair? lst1) (pair? lst1) (eq? (car lst1) (car lst2)))
           (equal? (cdr lst1) (cdr lst2)))
          (else #f)))

#+END_SRC

~Упражнение 2.55.~
Ева Лу Атор вводит при работе с интерпретатором выражение
~(car ''abracadabra)~
К ее удивлению, интерпретатор печатает quote. Объясните.

Ответ:
~quote~ предотвращает вычисление символа, следующего сразу за ней. Вторая ~'~ не дает
вычислиться ~abracadabra~, а стоящая перед ней первая ~quote~ не дает вычислиться
второй. Таким образом, последняя запятая попадает в список как символ, она не читается
интерпритатором как функция. Соответственно, ~сar~ полученного списка - это
невычисленная ~quote~.

~Упражнение 2.56.~
Покажите, как расширить простейшую программу дифференцирования так, чтобы она восприни-
мала больше разных типов выражений.
Добавьте еще одну проверку к программе ~deriv~ и определив соответствующие процедуры
exponentiation?, base, exponent и make-exponentiation (обозначать возведение в
степень можно символом **). Встройте правила, что любое выражение, возведенное в
степень 0, дает 1, а возведенное в степень 1 равно самому себе.

Полный код процедуры, представленный в мане:
#+BEGIN_SRC scheme
    (define (variable? x) (symbol? x))

    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))

    (define (make-sum a1 a2) (list '+ a1 a2))

    (define (make-product m1 m2) (list '* m1 m2))

    (define (sum? x)
      (and (pair? x) (eq? (car x) '+)))

    (define (addend s) (cadr s))

    (define (augend s) (caddr s))

    (define (product? x)
      (and (pair? x) (eq? (car x) '*)))

    (define (multiplier p) (cadr p))

    (define (multiplicand p) (caddr p))

    (define (=number? exp num)
      (and (number? exp) (= exp num)))

    (define (make-sum a1 a2)
      (cond ((=number? a1 0) a2)
            ((=number? a2 0) a1)
            ((and (number? a1) (number? a2)) (+ a1 a2))
            (else (list '+ a1 a2))))

    (define (make-product m1 m2)
      (cond ((or (=number? m1 0) (=number? m2 0)) 0)
            ((=number? m1 1) m2)
            ((=number? m2 1) m1)
            ((and (number? m1) (number? m2)) (* m1 m2))
            (else (list '* m1 m2))))

    (define (deriv exp var)
      (cond ((number? exp) 0)
            ((variable? exp)
             (if (same-variable? exp var) 1 0))
            ((sum? exp)
             (make-sum (deriv (addend exp) var)
                       (deriv (augend exp) var)))
            ((product? exp)
             (make-sum
              (make-product (multiplier exp)
                            (deriv (multiplicand exp) var))
              (make-product (deriv (multiplier exp) var)
                            (multiplicand exp))))
            (else
             (error "неизвестный тип выражения -- DERIV" exp))))

#+END_SRC

Мои дополнения:

#+BEGIN_SRC scheme
  ;; функция проверяет, является ли данное выражение возведением в степень
  ;; действуем по аналогии с суммой и произведением:
  (define (exponentiation? expr)
    (and (pair? expr) (eq? (car expr) '**)))

  ;; получаем основание из возведения в степень
  (define (base expr)
    (and (pair? expr) (cadr expr)))

  ;; полуаем экспоненту из возведения в степень
  (define (exponent expr)
    (and (pair? expr) (caddr expr)))

  ;; создаем выражение, которое возводит в заданную степень заданное число
  (define (make-exponentiation base exp)
    (list '** base exp))

  (define test (make-exponentiation 8 2))

  ;; дополненный вариант процедуры
  ;; прочитай про производные
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          ((exponentiation? exp)
           (make-sum
            (make-product (base exp)
                          (deriv (exponent exp) var))
            (make-product (deriv (exponent exp) var)
                          (base exp))))
          (else
           (error "неизвестный тип выражения -- DERIV" exp))))
#+END_SRC

~Упражнение 2.57.~
Расширьте программу дифференцирования так, чтобы она работала с суммами и
произведениями любого (больше двух) количества термов.
Тогда последний из приведенных выше примеров мог бы быть записан как
~(deriv '(* x y (+ x 3)) 'x)~
Попытайтесь сделать это, изменяя только представление сумм и произведений, не трогая
процедуру deriv. Тогда, например, процедура ~addend~ будет возвращать первое
слагаемое суммы, а ~augend~ сумму остальных.

#+BEGIN_SRC scheme
  ;; изначальный вариант
  (define (addend s) (cadr s))

  (define (augend s) (caddr s))

  (define (make-sum a1 a2)
    (list '+ a1 a2))

  ;; мой вариант
  ;; принимает неограниченное кол-во слагаемых
  (define (make-sum a1 . a2)
    (if (pair? a2)
        (append (list '+ a1) a2)
        (list '+ a1 a2)))

  ;; возвращает 1 слагаемое суммы
  (define (addend s) (cadr s))

  ;; возвращает сумму всех слагаемых кроме первого
  (define (augend s)
    (define (iter s)
      (if (null? s)
          0
          (+ (car s) (iter (cdr s)))))
    (iter (cddr s)))

  ;;тестовые примеры
  (define test (make-sum 1 2))

  (define test2 (make-sum 1 2 3 4))

#+END_SRC

~Упражнение 2.58.~
Предположим, что нам захотелось изменить программу дифференцирования так, чтобы она ра-
ботала с обычной математической нотацией, где + и * не префиксные, а инфиксные
операции.
Поскольку программа взятия производных определена в терминах абстрактных данных, мы
можем изменять представление выражений, с которыми она работает, меняя только предикаты,
селекторы и конструкторы, определяющие представление алгебраических выражений, с
которыми должен работать дифференциатор.
а. Покажите, как это сделать так, чтобы брать производные от выражений, представленных
в инфиксной форме, например (x + (3 * (x + (y + 2)))). Для упрощения задачи предполо-
жите, что + и * всегда принимают по два аргумента, и что в выражении расставлены все
скобки.
б. Задача становится существенно сложней, если мы разрешаем стандартную алгебраическую
нотацию, например (x + 3 * (x + y + 2)), которая опускает ненужные скобки и предпола-
гает, что умножение выполняется раньше, чем сложение. Можете ли Вы разработать
соответствующие предикаты, селекторы и конструкторы для этой нотации так, чтобы
наша программа взятия производных продолжала работать?

Вариант "а":
- раньше знаки умножения и сложения всегда стояли первым элементом списка, т.е.
(+ 1 2) или (* 1 (+ 2 8)) и т.д. А теперь они всегда будут стоять вторым элементом.
Таким образом надо только переделать конструкторы и селекторы, отвечающие за сложение и
умножение.
#+BEGIN_SRC scheme
  ;; инфиксная нотация
  (x + (3 * (x + (y + 2))))

  (define (make-sum a1 a2) (list a1 '+ a2))

  (define (make-product m1 m2) (list m1 '* m2))

  (define (sum? x)
    (and (pair? x) (eq? (cadr x) '+)))

  (define (addend s) (car s))

  (define (augend s) (caddr s))

  (define (product? x)
    (and (pair? x) (eq? (cadr x) '*)))

  (define (multiplier p) (car p))

  (define (multiplicand p) (caddr p))

  ;; тестовые примеры
  (define test (make-sum 2 4))

  (define test2 (make-product 3 5))

#+END_SRC

Вариант "б" с стандартной алгебраической нотацией
(это фактически инфиксная нотация, но без вспомогательных скобок. Тем не менее, знак
умножения или сложения окажется "между" своими аргументами, а не перед ними)

1. нужно разработать систему правил:
- внутрениие скобки решаются первыми, т.е. нужно дойти до самого глубокого уровня
  вложенности и начать от него
- установить приоритет операций: умножение и деление выполняются перывыми, сложение и
  вычитание - следом. Если у нас несколько операций умножения или сложения, то начинаем
  их применять слева направо
2. Для осуществления этой системы необходим проход по выражению. Необходима рекурсия.
Текущий элемент списка является парой?
Да!
- зайти внутрь подспика, вычислить его, вернуть значение вычисления, вернуться назад,
  если нет подсписка
Нет!
проверяем следующий элемент списка, пока они не кончатся

Фактически, нужно разработать экспертную систему
проблемы:
- пока не дошли до конца списка, ничего нельзя вычислить: мы не знаем, встретится ли нам
  приоритетная операция или уже можно вычислять, значит, придется проходить по
  выражению несколько раз (но можно сформировать новое, с уже вычисленными частями,
  использовать нехвостовую рекурсию)

#+BEGIN_SRC scheme
  ;; алгебраическая нотация
  (x + 3 * (x + y + 2))

  (define (make-sum a1 a2) (list a1 '+ a2))

  (define (make-product m1 m2) (list m1 '* m2))

  (define (sum? x)
    (and (pair? x) (eq? (cadr x) '+)))

  (define (addend s) (car s))

  (define (augend s) (caddr s))

  (define (product? x)
    (and (pair? x) (eq? (cadr x) '*)))

  (define (multiplier p) (car p))

  (define (multiplicand p) (caddr p))

  ;; тестовые примеры
  (define test (make-sum 2 4))

  (define test2 (make-product 3 5))

#+END_SRC

~Упражнение 2.59.~

Реализуйте операцию ~union-set~ для представления множеств в виде неупорядоченных
списков.
Union-set вычисляет объединение двух множеств, то есть множество, содержащее те
элементы, которые присутствуют хотя бы в одном из аргументов.

То есть два множества (1 2 3 4) и (4 5 6 2) соединятся в (1 2 3 4 5 6), видимо. Потому
что если бы была цель просто соединить два списка, подошла бы операция append. На это
так же указывает утверждение из мана, что "можно представить множество как список, в
котором ни один элемент не содержится более одного раза", таким образом множестве,
которое является результатом объединения, не должно содержаться повторяющихся
элементов.

- как проверить, встречался ли этот элемент?
использовать element-of-set?, который проверяет наличие элемента в множестве
добавить новый элемент можно с помощью adjoin-set

#+BEGIN_SRC scheme
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  (define (union-set set1 set2)
    (define (iter set new-set)
      (if (null? set)
          new-set
          (iter (cdr set) (adjoin-set (car set) new-set))))
    ;; добавляем элементы из первого множества
    (let ((uni-set (iter set1 (list))))
      ;; добавляем элементы из второго моножества
      (iter set2 uni-set)))

  (union-set (list 1 2 3 4) (list 2 3 4 5 6 7))

  (union-set (list 11 2 32 4) (list 22 3 4 42 5 6 7))
#+END_SRC

~Упражнение 2.60.~
Мы указали, что множество представляется как список без повторяющихся элементов. Допу-
стим теперь, что мы разрешаем повторяющиеся элементы. Например, множество {1, 2, 3}
могло бы быть представлено как список (2 3 2 1 3 2 2).
Разработайте процедуры ~element-of-set?~, ~adjoin-set~, ~union-set~ и
~intersection-set~, которые бы работали с таким представлением.
Как соотносится эффективность этих операций с эффективностью соответствующих процедур
для представления без повторений?
Существуют ли приложения, в которых Вы бы использовали скорее
это представление, чем представление без повторений?

Первый вывод: старое представление операций работает корректно на новом представлении
множеств.
Второй вывод: некоторые операции определить теперь проще, раз не надо проверять, был
элемент в множестве или нет. Так, например, для написания ~adjoin-set~ и ~union-set~
теперь не требуется проходить по всем множествам-аргументам, поскольку нет больше
проверки элементов на повторение. Соответственно, мы можем просто присоединить
необходимые элементы, что эффективнее и проще с точки зрения расходования ресурсов.
Но ~element-of-set?~ и ~intersection-set~ переписать невозможно, в результате с
повторяющимися элементами их сложность возрастает линейно.


#+BEGIN_SRC scheme
  ;; проверяет, есть ли элемент в множестве
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  ;; добавляет новый элемент в множество, если множество не содержит такой же
  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  ;;объяединяет неповторяющиеся элементы 2х множеств в одно
  (define (union-set set1 set2)
    (define (iter set new-set)
      (if (null? set)
          new-set
          (iter (cdr set) (adjoin-set (car set) new-set))))
    ;; добавляем элементы из первого множества
    (let ((uni-set (iter set1 (list))))
      ;; добавляем элементы из второго моножества
      (iter set2 uni-set)))

  ;;возвращает элементы, которые присуствуют в обоих множествах
  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
          ((element-of-set? (car set1) set2)
           (cons (car set1)
                 (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))

  ;; новый вариант функций:
  (define (union-set set1 set2)
    (append set1 set2))

  (define (adjoin-set x set)
    (cons x set))

#+END_SRC

~Упражнение 2.61.~
Напишите реализацию ~adjoin-set~ для упорядоченного представления множеств.
По аналогии с ~element-of-set?~ покажите, как использовать упорядочение, чтобы
получить процедуру, которая в среднем требует только половину числа шагов,
которое требуется при неупорядоченном представлении.

Упорядоченные множества позволяют реализовать зачатки бинарного поиска.
~adjoin-set~ построено на ~element-of-set~, которое теперь использует в среднем
в половину меньше шагов. Соответственно, ~adjoin-set~ теперь тоже использует в
полоивну меньше шагов даже при том, что я ничего в нем не изменила.

Но есть и второй вариант, реализованный "с нуля".
#+BEGIN_SRC scheme
  ;; усовершенствованный вариант процедуры для упорядоченных множеств
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((= x (car set)) #t)
          ((< x (car set)) #f)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  ;; второй вариант
  (define (adjoin-set x set)
    (cond ((or (null? set) (> x (car set))) (cons x set))
          ((= x (car set)) set)
          (else (adjoin-set x (cdr set)))))

  (define test (list 1 2 3 4 5 6 7 8))
#+END_SRC

~Упражнение 2.62.~
Дайте представление порядка Θ(n) для операции ~union-set~ с представлением в виде
упорядоченных списков.

В переводе на человеческий язык, от меня требуется реализация ~union-set~ для
упорядоченных списков, который будет расти линейно.

Внимание: в качестве аргументов моено передавать только упорядоченные списки, причем
упорядочены они должны быть "в одну сторону", т.е. в обоих числа должны располагаться от
меньшего к большему или от большего к меньшему, в противном случае новый список будет
неупорядоченным и может содержать повторяющиеся элементы.

#+BEGIN_SRC scheme
  (define (union-set set1 set2)
    (cond ((and (null? set1) (null? set2)) '())
          ((null? set1) set2)
          ((null? set2) set1)
          (else
           (let ((x1 (car set1)) (x2 (car set2)))
             (cond ((= x1 x2)
                    (cons x1 (union-set (cdr set1) (cdr set2))))
                   ((< x1 x2)
                    (cons x1 (union-set (cdr set1) set2)))
                   (else
                    (cons x2 (union-set set1 (cdr set2)))))))))

  (define set1 (list 2 8 9 13))

  (define set2 (list 1 5 8 10))
#+END_SRC

~Упражнение 2.63.~
Каждая из следующих двух процедур (~tree->list-1~ и ~tree->list-2~) преобразует
дерево в список.
#+BEGIN_SRC scheme
  (define (entry tree) (car tree))

  (define (left-branch tree) (cadr tree))

  (define (right-branch tree) (caddr tree))

  (define (make-node entry left right)
    (list entry left right))

  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((= x (entry set)) #t)
          ((< x (entry set))
           (element-of-set? x (left-branch set)))
          ((> x (entry set))
           (element-of-set? x (right-branch set)))))

  (define (adjoin-set x set)
    (cond ((null? set) (make-node x '() '()))
          ((= x (entry set)) set)
          ((< x (entry set))
           (make-node (entry set)
                      (adjoin-set x (left-branch set))
                      (right-branch set)))
          ((> x (entry set))
           (make-node (entry set)
                      (left-branch set)
                      (adjoin-set x (right-branch set))))))

  (define (tree->list-1 tree)
    (if (null? tree)
        '()
         (append (tree->list-1 (left-branch tree))
                 (cons (entry tree)
                       (tree->list-1 (right-branch tree))))))

  (define (tree->list-2 tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
          result-list
          (copy-to-list (left-branch tree)
                        (cons (entry tree)
                              (copy-to-list (right-branch tree)
                                            result-list)))))
    (copy-to-list tree '()))


  (define test-tree (list->tree (list 1 2 3 4 5 6 7)))
  (define test-tree2 (list->tree (list 1 3 5 7 9 11)))
  (define test-tree3 (list->tree (list 1 7 5 3 11 9)))


  (define (list->tree elements)
    (car (partial-tree elements (length elements))))

  (define (partial-tree elts n)
    (if (= n 0)
        (cons '() elts)
        (let ((left-size (quotient (- n 1) 2)))
          (let ((left-result (partial-tree elts left-size)))
            (let ((left-tree (car left-result))
                  (non-left-elts (cdr left-result))
                  (right-size (- n (+ left-size 1))))
              (let ((this-entry (car non-left-elts))
                    (right-result (partial-tree (cdr non-left-elts)
                                                right-size)))
                (let ((right-tree (car right-result))
                      (remaining-elts (cdr right-result)))
                  (cons (make-node this-entry left-tree right-tree)
                        remaining-elts))))))))
#+END_SRC

а. Для всякого ли дерева эти процедуры дают одинаковый результат? Если нет, то как их
результаты различаются? Какой результат дают эти две процедуры для деревьев с рисунка
2.16?

б. Одинаков ли порядок роста этих процедур по отношению к числу шагов, требуемых для
преобразования сбалансированного дерева с n элементами в список? Если нет, которая из
них растет медленнее?

Добавлены вспомогательный функции из мана. Оригинальная ~make-tree~ переименована
в ~make-node~, поскольку это лучше отражает ее суть.
Для построения дерева из списка использована ~list->tree~, представленная в следующем
упражнении.

Для множества {1, 3, 5, 7, 9, 11}, представленного бинарными диревьямис рисунка 2.16 не
найдено различий пи использовании ~tree->list-1~ и ~tree->list-2~ (для ~test-tree~
тоже).

~tree->list-1~ представляет собой нехвостовую рекурсию. То есть по достижению дна
рекурсии м еще будем вынуждены откатываться назад по стеку. Хранение всех переменных на
каждом вызове рекурсии требует памяти, чем больше элементов дерева, тем больше вызовов
рекурсии, тем больше памяти.

~tree->list-2~ представляет собой хвостовую рекурсию, то есть не производить никаких
вычислений по достижению дна рекурсии, а возвращает конечный результат. Это не требует
хранения всех переменных на каждомй итерации рекурсии, соответственно, меньше
расходуется ресурсов. Я думаю, что эта функция будет расти медленнее.

~Упражнение 2.64~
Следующая процедура ~list->tree~ преобразует упорядоченный список в сбалансированное би-
нарное дерево. Вспомогательная процедура ~partial-tree~ принимает в качестве аргументов
целое число n и список по крайней мере из n элементов, и строит сбалансированное дерево
из первых n элементов дерева.
Результат, который возвращает ~partial-tree~, — это пара (построенная
через cons), car которой есть построенное дерево, а cdr — список элементов,
не включенных в дерево.

а. Дайте краткое описание, как можно более ясно объясняющее работу ~partial-tree~.
Нарисуйте дерево, которое ~partial-tree~ строит из списка (1 3 5 7 9 11).

б. Каков порядок роста по отношению к числу шагов, которые требуются процедуре
~list->tree~ для преобразования дерева из n элементов?

#+BEGIN_SRC scheme
  (define (entry tree) (car tree))

  (define (left-branch tree) (cadr tree))

  (define (right-branch tree) (caddr tree))

  (define (make-node entry left right)
    (list entry left right))

  ;; возвращает car от результата partial-tree, который является динарным деревом
  (define (list->tree elements)
    (car (partial-tree elements (length elements))))


  (define (partial-tree elts n)
    ;; если элементы кончились
    (if (= n 0)
        (cons '() elts)
        ;; возвращает разность от деления
        ;; предполагаемый размер левой ветки
        (let ((left-size (quotient (- n 1) 2)))
          ;; строим левую ветку
          (let ((left-result (partial-tree elts left-size)))
            ;; получаем элементы для левой ветки
            (let ((left-tree (car left-result))
                  ;; получаем элементы, которые в левую ветку не вошли
                  (non-left-elts (cdr left-result))
                  ;; получаемразмер правой ветки
                  (right-size (- n (+ left-size 1))))
              ;; получаем первый элемент из элементов, не вошедших в левую ветку
              (let ((this-entry (car non-left-elts))
                    ;; строим правую ветку
                    (right-result (partial-tree (cdr non-left-elts)
                                                right-size)))
                ;; получаем правую ветку
                (let ((right-tree (car right-result))
                      ;; получаем элементы, не вошедшие в правую ветку
                      (remaining-elts (cdr right-result)))
                  ;; соединяем все в дерево и присоединяем элменты, не вошедшие в ветку
                  (cons (make-node this-entry left-tree right-tree)
                        remaining-elts))))))))
#+END_SRC

Итак, процедура ~partial-tree~ возвращает конс-пару, где car - это построенное дерево,
а cdr - элементы, не вошедшие в него.
~partial-tree~ принимает в качестве аргумента список элементов и длину списка. Все
вместе это позволяет создать отдельно левую и правые ветки, а затем соединить их от
корня: делим исходное кол-во элементов примерно поровну, помещаем первую половину
элементов в левую ветку, а оставшиеся - в правую.

Я думаю, что данная процедура имеет порядок роста O(n), поскольку нам необходимо
обработать кажды элемент списка по одному разу, сколько бы их ни было.

~Упражнение 2.65.~
Используя результаты упражнений 2.63 и 2.64, постройте реализации ~union-set~ и
~intersection-set~ порядка Θ(n) для множеств, реализованных как (сбалансированные)
бинарные деревья.

Для ~union-set~ нам требуется проверять, не повторяются ли элементы в деревьях
и создать новое дерево на основе 2х предыдущих. Сначала получим список элементов после
обхода обоих деревьев, а затем создадим дерево из этого списка.


#+BEGIN_SRC scheme

  (define (tree->list tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
          result-list
          (copy-to-list (left-branch tree)
                        (cons (entry tree)
                              (copy-to-list (right-branch tree)
                                            result-list)))))
    (copy-to-list tree '()))

  (define (union-tree tree1 tree2)
    (define (union-set set1 set2)
      (cond ((and (null? set1) (null? set2)) '())
            ((null? set1) set2)
            ((null? set2) set1)
            (else
             (let ((x1 (car set1)) (x2 (car set2)))
               (cond ((= x1 x2)
                      (cons x1 (union-set (cdr set1) (cdr set2))))
                     ((< x1 x2)
                      (cons x1 (union-set (cdr set1) set2)))
                     (else
                      (cons x2 (union-set set1 (cdr set2)))))))))
    (let* ((tree1-list (tree->list tree1))
           (tree2-list (tree->list tree2))
           (new-list (union-set tree1-list tree2-list)))
      (list->tree new-list)))

  (define (intersection-tree tree1 tree2)
    (define (element-of-set? x set)
      (cond ((null? set) #f)
            ((= x (car set)) #t)
            ((< x (car set)) #f)
            (else (element-of-set? x (cdr set)))))
    (define (intersection-set set1 set2)
      (cond ((or (null? set1) (null? set2)) '())
            ((element-of-set? (car set1) set2)
             (cons (car set1)
                   (intersection-set (cdr set1) set2)))
            (else (intersection-set (cdr set1) set2))))
    (let* ((tree1-list (tree->list tree1))
           (tree2-list (tree->list tree2))
           (new-list (intersection-set tree1-list tree2-list)))
      (list->tree new-list)))


  (define test-tree1 (list->tree (list 8 9 10 11 17 19)))
  (define test-tree2 (list->tree (list 1 3 5 7 9 11)))
#+END_SRC

Для написания ~union-tree~ я воспользовалась ~tree->list-2~ (поскольку она
использует звостовую рекурсию) из упр. 2.63, чтоб сформировать списки из деревьев,
но переименовала в ~tree->list~ для ясности. Затем уже написанную версию
~union-set~ для объединения 2х множеств, получила новый список и из него составила
новое дерево.

В ~intersection-tree~ логика аналогичная, только к тому же использована версия
~element-of-set?~ для упорядоченных списков, а не бинарных деревьев.

~Упражнение 2.66.~
Реализуйте процедуру lookup для случая, когда множество записей организовано в виде
бинарного дерева, отсортированного по числовым значениям ключей.
