#+STARTUP: showall indent hidestars

* Chapter 1
:PROPERTIES:
:ORDERED:  t
:END:

Ниже приведена последовательность выражений. Какой результат
напечатает интерпретатор в ответ на каждое из них?
Предполагается, что выражения вводятся в том же порядке, в каком они написаны.

~Упражнение 1.1~

#+BEGIN_SRC scheme
  (+ 5 3 4)
  ;; => 12

  (- 9 1)
  ;; => 8

  (/ 6 2)
  ;; => 3

  (+ (* 2 4) (- 4 6))
  ;; => 6

  (define a 3)
  ;; => 3

  (define b (+ a 1))
  ;; => 4

  (+ a b (* a b))
  ;; => 19

  (= a b)
  ;; => 4

  (if (and (> b a) (< b (* a b)))
      b
      a)
  ;; => a (т.е. 4)

  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
  ;; => 6

  (+ 2
     (if (> b a)
         b
         a))
  ;; => 6

  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))

  ;; => -5 (поскольку a = b, то сработает выражение else)

#+END_SRC

~Упражение 1.2~

Переведите выражение в префиксную форму:

5 + 4 + (2 − (3 − (6 + 4/5)))
____________________________
     3(6 − 2)(2 − 7)

(4/5 в данном контексте означает дробь "четыре пятых")

#+BEGIN_SRC scheme

    (/ (+ 4 5 (- 2 (- 3 (+ 6 (/ 4 5)))))
       (* 3 (- 6 2) (- 2 7)))

#+END_SRC

~Упражнения 1.3~

Определите процедуру, которая принимает в качестве аргументов три числа
и возвращает сумму квадратов двух бо́льших из них.
#+BEGIN_SRC scheme

  (define (sum-of-biggest-squares a b c)
    (cond ((and (> a b) (> b c)) (+ (* a a) (* b b)))
          ((and (> b a) (> c b)) (+ (* b b) (* c c)))
          ((and (> c a) (> a b)) (+ (* a a) (* c c)))
          ((and (> a c) (> b a)) (+ (* a a) (* b b)))
          ((and (> b c) (= a b)) (+ (* b b) (* c c)))
          ((and (> a b) (= c b)) (+ (* a a) (* b b)))
          (else (a b c))))

#+END_SRC

~Упражнение 1.4~

Заметим, что наша модель вычислений разрешает существование комбинаций, операторы кото-
рых — составные выражения. С помощью этого наблюдения опишите, как работает следующая
процедура:

#+BEGIN_SRC scheme

  (define (a-plus-abs-b a b)
    ((if (> b 0)
         +
         -)
     a b))

#+END_SRC

Ответ: в зависимости от того, больше b нуля или нет, форма if вернет предикат
"+" или "-", а возвращенный предикат будет применен к числам a и b.

~Упражнений 1.5~

Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком
вычислений он
работает, аппликативным или нормальным. Бен определяет такие две процедуры:

#+BEGIN_SRC scheme
  (define (p) (p))
  (define (test x y)
    (if (= x 0)
        0
        y))

  ;; Затем он вычисляет выражение

  (test 0 (p))
#+END_SRC

Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок
вычислений? Какое поведение он увидит, если интерпретатор использует нормальный
порядок?
Объясните Ваш ответ. (Предполагается, что правило вычисления особой формы if одинаково
независимо от того, какой порядок вычислений используется.
Сначала вычисляется выражение-предикат, и результат определяет,
нужно ли вычислять выражение-следствие или альтернативу.)

Ответ: мой интерпритатор использует нормальный порядок.

При аппликативном порядке интерпритор сначала подстатавит все значения в параметры
процедуры и только потом вычислит.

Процедура P - это рекурсивный выозов самой себя без конца.
аппликативный порядок даже не запустит процедуру.

Нормальный же порядок сначала вычисляет то, что вычислить можно сразу, затем выполняет
подстановку значений, если в этом есть необходимость и вычисляет новое выражение. И так
до тех пор, пока выражение не будет вычислено полностью.

Таким образом мы зациклимся навечно.

~Упражнение 1.6~

Лиза П. Хакер не понимает, почему if должна быть особой формой. «Почему нельзя просто
определить ее как обычную процедуру с помощью cond?» — спрашивает она. Лизина подруга
Ева Лу Атор утверждает, что, разумеется, можно, и определяет новую версию if:
#+BEGIN_SRC scheme

  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))

#+END_SRC

Обрадованная Лиза переписывает через new-if программу вычисления квадратного корня.
Что получится, когда Лиза попытается использовать эту процедуру для вычисления
квадратных корней? Объясните.
#+BEGIN_SRC scheme

  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (define (square x) (* x x))

  (define (average x y)
    (/ (+ x y) 2))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (good-enough? guess x)
    ;; возводим предполагаемый корень числа в квадрат,
    ;; вычитаем его из заданного числа
    ;; молучаем модуль разости
    ;; проверям, меньше ли он 0.001
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (square guess) x)) 0.001))

  ;; поиск корня с допустимой погрешностью
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (new-if (good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))

  ;; считаем, что корень любого числа = 1
  (define (sqrt x)
    ;; вызываем основную процедуру
    (sqrt-iter 1.0 x))
#+END_SRC

Ответ: при запуске процедуры с new-if я получила ошибку о переполнении стека.
Проблема в том, что срабатывают оба ветвления cond, это означает, возвращаемое
значение предиката (вызов good-enogh? в нашем случае) не интерпритируется
как "истина".


~Упражнение 1.7~
Проверка good-enough?, которую мы использовали для вычисления квадратных корней, будет
довольно неэффективна для поиска квадратных корней от очень маленьких чисел. Кроме
того, в настоящих компьютерах арифметические операции почти всегда вычисляются
с ограниченной точностью. Поэтому наш тест оказывается неадекватным и для очень больших
чисел. Альтернативный подход к реализации good-enough? состоит в том, чтобы следить,
как от одной итерации к другой изменяется guess, и остановиться, когда изменение
оказывается небольшой долей значения приближения.
Разработайте процедуру вычисления квадратного корня, которая использует такой
вариант проверки на завершение. Верно ли, что на больших и маленьких числах она
работает лучше?

Ответ: неверно, поскольку процедура вынуждена вызывать саму себя одинаковое кол-во
раз для good-enough? и my-good-enough?
#+BEGIN_SRC scheme
  (define (my-good-enough? guess x)
    (display "iteration\n")
    (< (abs (- (square (improve guess x)) (square guess))) 0.001))

  ;; вызов с определенной в мане процедурой
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))

  ;; вызов с моей процедурой
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (my-good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))
#+END_SRC

~Упражнение 1.8~

Метод Ньютона для кубических корней основан на том, что если Y является приближением к
кубическому корню из X, то мы можем получить лучшее приближение по формуле:

x/(y * y) + 2y
______________
      3

С помощью этой формулы напишите процедуру вычисления кубического корня, подобную проце-
дуре для квадратного корня.

Чтоб узнать кубический корень из X, нужно разделить X на Y в квадрате, прибавить к
получившемуся значению Y, умноженный на 2, и все это поделить на 3.

Как найти Y?

Предположим, что Y = 1.0

#+BEGIN_SRC scheme
  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (define (square x) (* x x))

  (define (cube x) (* x x x))

  ;; (define (my-average x y)
  ;;   (/ (+ x y) 3))

  (define (formula-realization guess x)
    ( / (+ (/ x (square guess )) (* 2 guess ))
        3))

  ;; (define (improve guess x)
  ;;   (average guess (/ x guess)))

  (define (good-enough? guess x)
    ;; возводим предполагаемый корень числа в квадрат,
    ;; вычитаем его из заданного числа
    ;; молучаем модуль разости
    ;; проверям, меньше ли он 0.001
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (cube (formula-realization guess x)) x))
       0.001))

  (define (my-good-enough? guess x)
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (cube (formula-realization guess x)) (cube guess))) 0.001))

  ;; поиск корня с допустимой погрешностью
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (my-good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (formula-realization guess x) x)))

  ;; считаем, что корень любого числа = 1
  (define (sqrt x)
    ;; вызываем основную процедуру
    (sqrt-iter 1.0 x))

#+END_SRC

~Упражнение 1.9~

Каждая из следующих двух процедур определяет способ сложения двух положительных целых
чисел с помощью процедур inc, которая добавляет к своему аргументу 1, и dec, которая
отнимает от своего аргумента 1.

Используя подстановочную модель, проиллюстрируйте процесс, порождаемый каждой из этих
процедур, вычислив (+ 4 5). Являются ли эти процессы итеративными или рекурсивными?

#+BEGIN_SRC scheme
  (define (+ a b)
    (if (= a 0)
        b
        (inc (+ (dec a) b))))

  (define (+ a b)
    (if (= a 0)
        b
        (+ (dec a) (inc b))))
#+END_SRC

Ответ: первая процедура - это линейный рекурсивный процесс. Вторая - итеративный
линейный процесс, он же хвостовая рекурсия.

~Упражнение 1.10~

Следующая процедура вычисляет математическую функцию, называемую функцией Аккермана.

Каковы значения следующих выражений?
(A 1 10) => 1024
(A 2 4)  => 65536
(A 3 3)  => 65536
#+BEGIN_SRC scheme
  (define (A x y)
    (display "----\n")
    (display "x:")
    (display x)
    (display "\n")
    (display "y:")
    (display y)
    (display "\n")
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))
#+END_SRC


Рассмотрим следующие процедуры, где A — процедура, определенная выше:
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))

Дайте краткие математические определения функций, вычисляемых процедурами f, g и h для
положительных целых значений n.

~Шпаргалка по fib~
#+BEGIN_SRC scheme
  (define (fib n sp)
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (cond ((= n 0) (let ((answer 0))
                     (space sp)
                     (display "first\n")
                     0))
          ((= n 1) (let ((answer 1))
                     (space sp)
                     (display "second\n")
                     1))
          (else (let ((answer 10))
                  (space sp)
                  (display "else\n")
                  (+ (fib (- n 1) (+ 1 sp))
                     (fib (- n 2) (+ 1 sp)))))))

  (define (fib n sp)
    (fib-iter 1 0 n sp))

  (define (fib-iter a b count sp)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1) (+ sp 1))))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))
#+END_SRC

~Упражнение 1.11~

Функция f определяется правилом:
f (n) = n, если n < 3, и f (n) = f (n − 1) + f (n − 2) + f (n − 3), если n ≥ 3.
Напишите процедуру, вычисляющую f с помощью рекурсивного процесса.
Напишите процедуру, вычисляющую f с помощью итеративного процесса.

#+BEGIN_SRC scheme
  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (f n sp)
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (if (< n 3)
        n
        (+ (f (- n 1) (+ sp 1)) (f (- n 2) (+ sp 1)) (f (- n 3) (+ sp 1)))))

  (define (iter-f a b c count sp)
    (space sp)
    (display "A:")
    (display a )
    (display "\n")
    (space sp)
    (display "B:")
    (display b )
    (display "\n")
    (space sp)
    (display "C:")
    (display c )
    (display "\n")
    (space sp)
    (display "count:")
    (display count )
    (display "\n")
    (if (= count 0)
        c
        (iter-f (+ a b c) a b (- count 1) (+ sp 1))))

  (define (f n sp)
    (iter-f 2 1 0 n sp))
#+END_SRC

~Упражнение 1.12~

Дан треугольник Паскаля (см. стр. 57)

Все числа по краям треугольника равны 1, а каждое число внутри треугольника равно сумме
двух чисел над ним. Напишите процедуру, вычисляющую элементы треугольника Паскаля с
помощью рекурсивного процесса.

PS скорее всего имеется в виду вычисление суммы коэфициентов. Т.е. надо опираться на
следующее:
сумма биномиальных коэффициентов равна числу 2, возведенному в степень, равную
показателю степени бинома Ньютона. Т.е. сумма коэфициэнтов третьей строчки треугольника
Паскаля будет равна 8, поскольку 2 в третьей степени = 8.

 #+BEGIN_SRC scheme
   ;; n = строка треугольника Паскаля. Нумерция строк наинчается от нуля.
   ;; k = кол-во элементов в строке. Всегда равно номеру строки + 1
   (define (paskal n)
     (p n (+ n 1)))

   (define (p n k)
     (if (or (= n 0) (= n k))
         1
         (+ (p (- n 1) (- k 1))
            (p (- n 1) k))))
#+END_SRC

~Упражнение 1.13~
Докажите, что Fib(n) есть целое число, ближайшее к φ в степени n / √5,
где φ = (1 + √5)/2. Указание: пусть ψ = (1 − √5)/2.
С помощью  определения чисел Фибоначчи (см. раздел 1.2.2) и индукции докажите,
что Fib(n) = (φ в степени n − ψ в степени n )/ √5.

Определение числел Фибоначчи: каждое последующее число = сумме предыдущих двух:
F(n) = 0, если n = 0
F(n) = 1, если n = 1
F(n) = F(n - 1) + F (n - 2) во всех остальных случаях

φ = (1 + √5)/2 - это формула золотого сечения

Полагаю, что под индукцией понимается математическая индукция, т.е. если базис индукции
верен (будем считать его 1 или же P1), то верно и Pn, а значит справедливо будет
сказать, что верно Pn + 1. Иллюстрация этого утверждения - принцип домино: если упала
первая косточка домино, то упадут и все последующие.

Значит, нам нужно доказать, что
Fib(1) есть целое число, ближайшее к φ в степени 1 /√5, где φ = (1 + √5)/2  -  это
будет базис нашей индукции.

Воспользуемся определенными в ~упражнениеи 1.7~ функциями, чтоб извлекать квадратные
корни.
 #+BEGIN_SRC scheme
   (define (abs x)
     (cond ((> x 0) x)
           ((= x 0) 0)
           ((< x 0) (- x))))

   (define (square x) (* x x))

   (define (average x y)
     (/ (+ x y) 2))

   (define (improve guess x)
     (average guess (/ x guess)))

   (define (good-enough? guess x)
     ;; возводим предполагаемый корень числа в квадрат,
     ;; вычитаем его из заданного числа
     ;; молучаем модуль разости
     ;; проверям, меньше ли он 0.001
     (< (abs (- (square guess) x)) 0.001))

   ;; поиск корня с допустимой погрешностью
   (define (sqrt-iter guess x)
     ;; корень нашли?
     (if (good-enough? guess x)
         ;; да, вернуть корень
         guess
         ;; иначе считаем дальше
         (sqrt-iter (improve guess x)
                    x)))

   ;; считаем, что корень любого числа = 1
   (define (sqrt x)
     ;; вызываем основную процедуру
     (sqrt-iter 1.0 x))
#+END_SRC

#+BEGIN_SRC scheme
  (define (fib n)
    (fib-iter 1 0 n))

  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))

  ;; вычисление фи
  (define (fi)
    ( / (+ 1 (sqrt 5)) 2))

  ;; вычисление пси
  (define (psi)
    ( / (- 1 (sqrt 5)) 2))

  ;; возведение числа в степень (написано криво, я знаю)
  (define (extent x pr-x n)
    (cond ((= n 0) 1)
          ((= n 1) x)
          (else (extent (* x pr-x) pr-x (- n 1)))))

  ;; если базис индукции верен, вычисляем условие с n
  ;; внимаение, наблюдается погрешность приблиительно на 0.001, которая становится выше
  ;; на больших числах
  ;; P.S. формально вычисление условия с n не требуется, т.к. если базис индукции
  ;; верен, то и условие с n верно
  (define (proof n)
    (if (= (fib 1) ( / (- (extent (fi) (fi) 1) (extent (psi) (psi) 1)) (sqrt 5)))
        (if (or (> (- (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
                   0.1)
                (< (- (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
                   0.1)
                (= (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5))))

            #t
            (let ((f #f))
              (display (fib n))
              (display "\n")
              (display ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
              (display "\n")
              f))))

#+END_SRC
