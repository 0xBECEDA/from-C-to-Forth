`
#+STARTUP: showall indent hidestars

* Chapter 1
:PROPERTIES:
:ORDERED:  t
:END:

Ниже приведена последовательность выражений. Какой результат
напечатает интерпретатор в ответ на каждое из них?
Предполагается, что выражения вводятся в том же порядке, в каком они написаны.

~Упражнение 1.1~

#+BEGIN_SRC scheme
  (+ 5 3 4)
  ;; => 12

  (- 9 1)
  ;; => 8

  (/ 6 2)
  ;; => 3

  (+ (* 2 4) (- 4 6))
  ;; => 6

  (define a 3)
  ;; => 3

  (define b (+ a 1))
  ;; => 4

  (+ a b (* a b))
  ;; => 19

  (= a b)
  ;; => 4

  (if (and (> b a) (< b (* a b)))
      b
      a)
  ;; => a (т.е. 4)

  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
  ;; => 6

  (+ 2
     (if (> b a)
         b
         a))
  ;; => 6

  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))

  ;; => -5 (поскольку a = b, то сработает выражение else)

#+END_SRC

~Упражение 1.2~

Переведите выражение в префиксную форму:

5 + 4 + (2 − (3 − (6 + 4/5)))
____________________________
     3(6 − 2)(2 − 7)

(4/5 в данном контексте означает дробь "четыре пятых")

#+BEGIN_SRC scheme

    (/ (+ 4 5 (- 2 (- 3 (+ 6 (/ 4 5)))))
       (* 3 (- 6 2) (- 2 7)))

#+END_SRC

~Упражнения 1.3~

Определите процедуру, которая принимает в качестве аргументов три числа
и возвращает сумму квадратов двух бо́льших из них.
#+BEGIN_SRC scheme

  (define (sum-of-biggest-squares a b c)
    (cond ((and (> a b) (> b c)) (+ (* a a) (* b b)))
          ((and (> b a) (> c b)) (+ (* b b) (* c c)))
          ((and (> c a) (> a b)) (+ (* a a) (* c c)))
          ((and (> a c) (> b a)) (+ (* a a) (* b b)))
          ((and (> b c) (= a b)) (+ (* b b) (* c c)))
          ((and (> a b) (= c b)) (+ (* a a) (* b b)))
          (else (a b c))))

#+END_SRC

~Упражнение 1.4~

Заметим, что наша модель вычислений разрешает существование комбинаций, операторы кото-
рых — составные выражения. С помощью этого наблюдения опишите, как работает следующая
процедура:

#+BEGIN_SRC scheme

  (define (a-plus-abs-b a b)
    ((if (> b 0)
         +
         -)
     a b))

#+END_SRC

Ответ: в зависимости от того, больше b нуля или нет, форма if вернет предикат
"+" или "-", а возвращенный предикат будет применен к числам a и b.

~Упражнений 1.5~

Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком
вычислений он
работает, аппликативным или нормальным. Бен определяет такие две процедуры:

#+BEGIN_SRC scheme
  (define (p) (p))
  (define (test x y)
    (if (= x 0)
        0
        y))

  ;; Затем он вычисляет выражение

  (test 0 (p))
#+END_SRC

Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок
вычислений? Какое поведение он увидит, если интерпретатор использует нормальный
порядок?
Объясните Ваш ответ. (Предполагается, что правило вычисления особой формы if одинаково
независимо от того, какой порядок вычислений используется.
Сначала вычисляется выражение-предикат, и результат определяет,
нужно ли вычислять выражение-следствие или альтернативу.)

Ответ: мой интерпритатор использует нормальный порядок.

При аппликативном порядке интерпритор сначала подстатавит все значения в параметры
процедуры и только потом вычислит.

Процедура P - это рекурсивный выозов самой себя без конца.
аппликативный порядок даже не запустит процедуру.

Нормальный же порядок сначала вычисляет то, что вычислить можно сразу, затем выполняет
подстановку значений, если в этом есть необходимость и вычисляет новое выражение. И так
до тех пор, пока выражение не будет вычислено полностью.

Таким образом мы зациклимся навечно.

~Упражнение 1.6~

Лиза П. Хакер не понимает, почему if должна быть особой формой. «Почему нельзя просто
определить ее как обычную процедуру с помощью cond?» — спрашивает она. Лизина подруга
Ева Лу Атор утверждает, что, разумеется, можно, и определяет новую версию if:
#+BEGIN_SRC scheme

  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))

#+END_SRC

Обрадованная Лиза переписывает через new-if программу вычисления квадратного корня.
Что получится, когда Лиза попытается использовать эту процедуру для вычисления
квадратных корней? Объясните.
#+BEGIN_SRC scheme

  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (define (square x) (* x x))

  (define (average x y)
    (/ (+ x y) 2))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (good-enough? guess x)
    ;; возводим предполагаемый корень числа в квадрат,
    ;; вычитаем его из заданного числа
    ;; молучаем модуль разости
    ;; проверям, меньше ли он 0.001
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (square guess) x)) 0.001))

  ;; поиск корня с допустимой погрешностью
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (new-if (good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))

  ;; считаем, что корень любого числа = 1
  (define (sqrt x)
    ;; вызываем основную процедуру
    (sqrt-iter 1.0 x))
#+END_SRC

Ответ: при запуске процедуры с new-if я получила ошибку о переполнении стека.
Проблема в том, что срабатывают оба ветвления cond, это означает, возвращаемое
значение предиката (вызов good-enogh? в нашем случае) не интерпритируется
как "истина".


~Упражнение 1.7~
Проверка good-enough?, которую мы использовали для вычисления квадратных корней, будет
довольно неэффективна для поиска квадратных корней от очень маленьких чисел. Кроме
того, в настоящих компьютерах арифметические операции почти всегда вычисляются
с ограниченной точностью. Поэтому наш тест оказывается неадекватным и для очень больших
чисел. Альтернативный подход к реализации good-enough? состоит в том, чтобы следить,
как от одной итерации к другой изменяется guess, и остановиться, когда изменение
оказывается небольшой долей значения приближения.
Разработайте процедуру вычисления квадратного корня, которая использует такой
вариант проверки на завершение. Верно ли, что на больших и маленьких числах она
работает лучше?

Ответ: неверно, поскольку процедура вынуждена вызывать саму себя одинаковое кол-во
раз для good-enough? и my-good-enough?
#+BEGIN_SRC scheme
  (define (my-good-enough? guess x)
    (display "iteration\n")
    (< (abs (- (square (improve guess x)) (square guess))) 0.001))

  ;; вызов с определенной в мане процедурой
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))

  ;; вызов с моей процедурой
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (my-good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))
#+END_SRC

~Упражнение 1.8~

Метод Ньютона для кубических корней основан на том, что если Y является приближением к
кубическому корню из X, то мы можем получить лучшее приближение по формуле:

x/(y * y) + 2y
______________
      3

С помощью этой формулы напишите процедуру вычисления кубического корня, подобную проце-
дуре для квадратного корня.

Чтоб узнать кубический корень из X, нужно разделить X на Y в квадрате, прибавить к
получившемуся значению Y, умноженный на 2, и все это поделить на 3.

Как найти Y?

Предположим, что Y = 1.0

#+BEGIN_SRC scheme
  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (define (square x) (* x x))

  (define (cube x) (* x x x))

  ;; (define (my-average x y)
  ;;   (/ (+ x y) 3))

  (define (formula-realization guess x)
    ( / (+ (/ x (square guess )) (* 2 guess ))
        3))

  ;; (define (improve guess x)
  ;;   (average guess (/ x guess)))

  (define (good-enough? guess x)
    ;; возводим предполагаемый корень числа в квадрат,
    ;; вычитаем его из заданного числа
    ;; молучаем модуль разости
    ;; проверям, меньше ли он 0.001
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (cube (formula-realization guess x)) x))
       0.001))

  (define (my-good-enough? guess x)
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (cube (formula-realization guess x)) (cube guess))) 0.001))

  ;; поиск корня с допустимой погрешностью
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (my-good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (formula-realization guess x) x)))

  ;; считаем, что корень любого числа = 1
  (define (sqrt x)
    ;; вызываем основную процедуру
    (sqrt-iter 1.0 x))

#+END_SRC

~Упражнение 1.9~

Каждая из следующих двух процедур определяет способ сложения двух положительных целых
чисел с помощью процедур inc, которая добавляет к своему аргументу 1, и dec, которая
отнимает от своего аргумента 1.

Используя подстановочную модель, проиллюстрируйте процесс, порождаемый каждой из этих
процедур, вычислив (+ 4 5). Являются ли эти процессы итеративными или рекурсивными?

#+BEGIN_SRC scheme
  (define (+ a b)
    (if (= a 0)
        b
        (inc (+ (dec a) b))))

  (define (+ a b)
    (if (= a 0)
        b
        (+ (dec a) (inc b))))
#+END_SRC

Ответ: первая процедура - это линейный рекурсивный процесс. Вторая - итеративный
линейный процесс, он же хвостовая рекурсия.

~Упражнение 1.10~

Следующая процедура вычисляет математическую функцию, называемую функцией Аккермана.

Каковы значения следующих выражений?
(A 1 10) => 1024
(A 2 4)  => 65536
(A 3 3)  => 65536
#+BEGIN_SRC scheme
  (define (A x y)
    (display "----\n")
    (display "x:")
    (display x)
    (display "\n")
    (display "y:")
    (display y)
    (display "\n")
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))
#+END_SRC


Рассмотрим следующие процедуры, где A — процедура, определенная выше:
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))

Дайте краткие математические определения функций, вычисляемых процедурами f, g и h для
положительных целых значений n.

~Шпаргалка по fib~
#+BEGIN_SRC scheme
  (define (fib n sp)
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (cond ((= n 0) (let ((answer 0))
                     (space sp)
                     (display "first\n")
                     0))
          ((= n 1) (let ((answer 1))
                     (space sp)
                     (display "second\n")
                     1))
          (else (let ((answer 10))
                  (space sp)
                  (display "else\n")
                  (+ (fib (- n 1) (+ 1 sp))
                     (fib (- n 2) (+ 1 sp)))))))

  (define (fib n sp)
    (fib-iter 1 0 n sp))

  (define (fib-iter a b count sp)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1) (+ sp 1))))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))
#+END_SRC

~Упражнение 1.11~

Функция f определяется правилом:
f (n) = n, если n < 3, и f (n) = f (n − 1) + f (n − 2) + f (n − 3), если n ≥ 3.
Напишите процедуру, вычисляющую f с помощью рекурсивного процесса.
Напишите процедуру, вычисляющую f с помощью итеративного процесса.

#+BEGIN_SRC scheme
  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (f n sp)
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (if (< n 3)
        n
        (+ (f (- n 1) (+ sp 1)) (f (- n 2) (+ sp 1)) (f (- n 3) (+ sp 1)))))

  (define (iter-f a b c count sp)
    (space sp)
    (display "A:")
    (display a )
    (display "\n")
    (space sp)
    (display "B:")
    (display b )
    (display "\n")
    (space sp)
    (display "C:")
    (display c )
    (display "\n")
    (space sp)
    (display "count:")
    (display count )
    (display "\n")
    (if (= count 0)
        c
        (iter-f (+ a b c) a b (- count 1) (+ sp 1))))

  (define (f n sp)
    (iter-f 2 1 0 n sp))
#+END_SRC

~Упражнение 1.12~

Дан треугольник Паскаля (см. стр. 57)

Все числа по краям треугольника равны 1, а каждое число внутри треугольника равно сумме
двух чисел над ним. Напишите процедуру, вычисляющую элементы треугольника Паскаля с
помощью рекурсивного процесса.

PS скорее всего имеется в виду вычисление суммы коэфициентов. Т.е. надо опираться на
следующее:
сумма биномиальных коэффициентов равна числу 2, возведенному в степень, равную
показателю степени бинома Ньютона. Т.е. сумма коэфициэнтов третьей строчки треугольника
Паскаля будет равна 8, поскольку 2 в третьей степени = 8.

 #+BEGIN_SRC scheme
   ;; n = строка треугольника Паскаля. Нумерция строк наинчается от нуля.
   ;; k = кол-во элементов в строке. Всегда равно номеру строки + 1
   (define (paskal n)
     (p n (+ n 1)))

   (define (p n k)
     (if (or (= n 0) (= n k))
         1
         (+ (p (- n 1) (- k 1))
            (p (- n 1) k))))
#+END_SRC

~Упражнение 1.13~
Докажите, что Fib(n) есть целое число, ближайшее к φ в степени n / √5,
где φ = (1 + √5)/2. Указание: пусть ψ = (1 − √5)/2.
С помощью  определения чисел Фибоначчи (см. раздел 1.2.2) и индукции докажите,
что Fib(n) = (φ в степени n − ψ в степени n )/ √5.

Определение числел Фибоначчи: каждое последующее число = сумме предыдущих двух:
F(n) = 0, если n = 0
F(n) = 1, если n = 1
F(n) = F(n - 1) + F (n - 2) во всех остальных случаях

φ = (1 + √5)/2 - это формула золотого сечения

Полагаю, что под индукцией понимается математическая индукция, т.е. если базис индукции
верен (будем считать его 1 или же P1), то верно и Pn, а значит справедливо будет
сказать, что верно Pn + 1. Иллюстрация этого утверждения - принцип домино: если упала
первая косточка домино, то упадут и все последующие.

Значит, нам нужно доказать, что
Fib(1) есть целое число, ближайшее к φ в степени 1 /√5, где φ = (1 + √5)/2  -  это
будет базис нашей индукции.

Воспользуемся определенными в ~упражнениеи 1.7~ функциями, чтоб извлекать квадратные
корни.
 #+BEGIN_SRC scheme
   (define (abs x)
     (cond ((> x 0) x)
           ((= x 0) 0)
           ((< x 0) (- x))))

   (define (square x) (* x x))

   (define (average x y)
     (/ (+ x y) 2))

   (define (improve guess x)
     (average guess (/ x guess)))

   (define (good-enough? guess x)
     ;; возводим предполагаемый корень числа в квадрат,
     ;; вычитаем его из заданного числа
     ;; молучаем модуль разости
     ;; проверям, меньше ли он 0.001
     (< (abs (- (square guess) x)) 0.001))

   ;; поиск корня с допустимой погрешностью
   (define (sqrt-iter guess x)
     ;; корень нашли?
     (if (good-enough? guess x)
         ;; да, вернуть корень
         guess
         ;; иначе считаем дальше
         (sqrt-iter (improve guess x)
                    x)))

   ;; считаем, что корень любого числа = 1
   (define (sqrt x)
     ;; вызываем основную процедуру
     (sqrt-iter 1.0 x))
#+END_SRC

#+BEGIN_SRC scheme
  (define (fib n)
    (fib-iter 1 0 n))

  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))

  ;; вычисление фи
  (define (fi)
    ( / (+ 1 (sqrt 5)) 2))

  ;; вычисление пси
  (define (psi)
    ( / (- 1 (sqrt 5)) 2))

  ;; возведение числа в степень (написано криво, я знаю)
  (define (extent x pr-x n)
    (cond ((= n 0) 1)
          ((= n 1) x)
          (else (extent (* x pr-x) pr-x (- n 1)))))

  ;; если базис индукции верен, вычисляем условие с n
  ;; внимаение, наблюдается погрешность приблиительно на 0.001, которая становится выше
  ;; на больших числах
  ;; P.S. формально вычисление условия с n не требуется, т.к. если базис индукции
  ;; верен, то и условие с n верно
  (define (proof n)
    (if (= (fib 1) ( / (- (extent (fi) (fi) 1) (extent (psi) (psi) 1)) (sqrt 5)))
        (if (or (> (- (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
                   0.1)
                (< (- (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
                   0.1)
                (= (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5))))

            #t
            (let ((f #f))
              (display (fib n))
              (display "\n")
              (display ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
              (display "\n")
              f))))

#+END_SRC


~Шпаргалка по размену монет~

#+BEGIN_SRC scheme

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (cc amount kinds-of-coins sp)
    (space sp)
    (display "amount:")
    (display amount)
    (display "\n")
    (space sp)
    (display "kinds-of-coins:")
    (display kinds-of-coins)
    (display "\n")
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+ (cc amount
                       (- kinds-of-coins 1) (+ sp 1))
                   (cc (- amount
                          (first-denomination kinds-of-coins))
                       kinds-of-coins (+ sp 1))))))

  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))

  (define (count-change amount)
    (cc amount 5 0))
#+END_SRC

~Упражнение 1.15~

Синус угла (заданного в радианах) можно вычислить, если воспользоваться приближением
sin x ≈ x при малых x и употребить тригонометрическое тождество (см. стр 59)
для уменьшения значения аргумента sin. (В этом упражнении мы будем считать, что угол
«достаточно мал», если он не больше 0.1 радиана.) Эта идея используется в следующих
процедурах:

#+BEGIN_SRC scheme
  (define (cube x) (* x x x))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (p x count sp)
    (space sp)
    (display "count:")
    (display count)
    (display "\n")
    (- (* 3 x) (* 4 (cube x))))

  (define (sine angle count)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0) (+ 1 count)) (+ count 1) (+ sp 1))))
#+END_SRC

а. Сколько раз вызывается процедура p при вычислении (sine 12.15)?
б. Каковы порядки роста в терминах количества шагов и используемой памяти
(как функция a) для процесса,
порождаемого процедурой sine при вычислении (sine a)?

Ответ: p выполнится 5 раз.

?

~Упражнение 1.16~

Напишите процедуру, которая развивается в виде итеративного процесса и реализует
возведение в степень за логарифмическое число шагов, как fast-expt.
(Указание: используя наблюдение, что (b^n/2 )^2 = (b^2 )^n/2 ,
храните, помимо значения степени n и основания b, дополнительную переменную состояния
a, и определите переход между состояниями так, чтобы произведение ab^n от
шага к шагу не менялось. Вначале значение a берется равным 1, а ответ получается
как значение a в момент окончания процесса.
В общем случае метод определения инварианта (invariant quantity), который не изменяется
при переходе между шагами, является мощным способом размышления о построении
итеративных алгоритмов.)

Первоначальный вариант fast-expt:
o
#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))
#+END_SRC

Первод задания на русский язык:
- функция должна реализовывать хвостовую рекурсию вместо линейной
- функция должна работать по тому же принципу, что и fast-expt: т.е. использовть
логарифмическое кол-во шагов, а не линейное
- функция должна использовать 3 переменные: n - значение степени,
 b - основание, а - переменная состояния
- переменная состояния - это, видимо, аккумулятор. Т.е. в нем будет накапливаться
значение, которое вернет функция. Изначально его значение = 1.
- дана подсказка: можно сначала разделить степень на два, возвести число в степень и
затем возвести результат в квадрат или сначала возвести число в квадрат, а затем
в разделенную на два степень.
- переход между состояниями, т.е. между итерациями/вызовами функции должен быть
  определен так, чтоб произведение от а*b^n не менялось (что имеется в виду?)
Возможный вариант:
- n делится на 2 на каждой итерации
- a = a * b на каждой итерации (здесь была ошибка: не на каждой итерации, а только
на последней. Т.е. акум все равно b, и только на последней итерации, когда
n = 1, мы перемножаем a и b, т.е. умножаем b на единицу, поскольку любой число
в степени 1 = то же самое число)

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (fast-expt b n)
    (my-fast-expt b n 1 0))

  (define (my-fast-expt b n a sp)
    (space sp)
    (display "a:")
    (display a)
    (display "\n")
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (space sp)
    (display "b:")
    (display b)
    (display "\n")
    (cond ((= n 0) a)
          ((even? n) (my-fast-expt (* b b) (/ n 2) a (+ 1 sp)))
          (else (my-fast-expt b (- n 1) (* a b) (+ 1 sp)))))

#+END_SRC
~Упражнение 1.17~

Алгоритмы возведения в степень из этого раздела основаны на повторяющемся
умножении. Подобным же образом можно производить умножение с помощью повторяющегося
сложения.
Следующая процедура умножения (в которой предполагается,
что наш язык способен только складывать, но не умножать) аналогична процедуре expt:

#+BEGIN_SRC scheme

  (define (* a b)
    (if (= b 0)
        0
        (+ a (* a (- b 1)))))

#+END_SRC

Этот алгоритм затрачивает количество шагов, линейно пропорциональное b.
Предположим теперь, что, наряду со сложением, у нас есть операции double,
которая удваивает целое число, и halve, которая делит (четное) число на 2.
Используя их, напишите процедуру, аналогичную fast-expt,
которая затрачивает логарифмическое число шагов.

Итак, нам фактически нужно реализовать процедуру умножения, не используя само
умножение и затратить на это логарифмическое кол-во шагов.
Если "b" четное, то мы делим b на 2, затем складываем "a" с самим собой до тех пор,
пока b не станет 0 (1?).

#+BEGIN_SRC scheme

  (define (double a)
    (+ a a))

  (define (halve a)
    (/ a 2))

  (define (even? n)
    (= (remainder n 2) 0))

  (define (multiple a b)
    (cond ((or (= b 0) (= a 0)) 0)
          ((= b 1) a)
          ((= a 1) b)
          ((even? b) (multiple (double a) (halve b)))
          (else (+ a (multiple a (- b 1))))))

#+END_SRC

~Упражнение 1.18~

Используя результаты упражнений 1.16 и 1.17, разработайте процедуру, которая порождает
итеративный процесс для умножения двух чисел с помощью сложения, удвоения и деления пополам,
и затрачивает логарифмическое число шагов.

Дана подсказка: данный алгоритм называется "метод русского крестьянина" или
"египетский" метод.

#+BEGIN_SRC scheme
  (define (double a)
    (+ a a))

  (define (halve a)
    (/ a 2))

  (define (even? n)
    (= (remainder n 2) 0))

  (define (new-multiple a b accum)
    (cond ((or (= b 0) (= a 0)) accum)
          ((= b 1) (+ a accum))
          ((= a 1) b)
          ((even? b) (new-multiple (double a) (halve b) accum))
          (else (new-multiple a (- b 1) (+ a accum)))))

  (define (multiple a b)
    (new-multiple a b 0))
#+END_SRC

~Упражнение 1.19~

уществует хитрый алгоритм получения чисел Фибоначчи за логарифмическое число шагов.
Вспомните трансформацию переменных состояния a и b процесса fib-iter из раздела 1.2.2

a ← a + b и b ← a. Назовем эту трансформацию T и заметим, что n-кратное применение T ,
начиная с 1 и 0, дает нам пару Fib(n + 1) и Fib(n). Другими словами, числа Фибоначчи
получаются путем применения T^n , n-ой степени трансформации T , к паре (1,0).
Теперь рассмотрим T как частный случай p = 0, q = 1 в семействе трансформаций T pq ,
где Tpq преобразует пару (a, b) по правилу a ← bq + aq + ap, b ← bp + aq.
Покажите, что двукратное применение трансформации Tpq равносильно однократному
применению трансформации Tp ′q ′ того же типа, и вычислите p ′ и q ′ через p и q.
Это дает нам прямой способ возводить такие трансформации в квадрат, и
таким образом, мы можем вычислить T n с помощью последовательного возведения в квадрат, как в
процедуре fast-expt. Используя все эти идеи, завершите следующую процедуру, которая
дает результат за логарифмическое число шагов.

Перевод на русский язык:
есть некая трансформация, которая называется Т. Она работает так:  a ← a + b и b ← a
Му говорим что применение этой трансформации какое-то кол-во раз к числам 1 0 дает
нам в конечном итоге формулу Фибоначи, а вернее, пару Fib(n + 1) и Fib(n). Иными
словами можно сказать, что числа Фибоначчи получаются, если применить трансформацию Т
заданное кол-во раз, т.е. Т^n к паре 1 и 0.

Теперь скажем, что это частный случай в целом семестве трансформаций Tpq, где
p = 0, q = 1.
Семейство этих трансформаций работает по правилу: a ← bq + aq + ap, b ← bp + aq,
преобразовывая таким образом а и b.

Задание: у нас есть семейство трансформаций Tpq и какая-то конкретная трансформация
этого семейства Tp ′q ′, т.е. за p ′q` скрыты реальные числа.
Нам нужно вычислить их через p и q, зная, что однократное применение Tp ′q ′
будет равносильно двукратному применению Tpq, т.е. p ′и q ′ - в 2 раза больше, чем p и
q.

#+BEGIN_SRC scheme
  (define (fib n)
    (fib-iter 1 0 0 1 n 0))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (fib-iter a b p q count sp)
    (space sp)
    (display "a:")
    (display a)
    (display "\n")
    (space sp)
    (display "b:")
    (display b)
    (display "\n")
    (space sp)
    (display "p:")
    (display p)
    (display "\n")
    (display "q:")
    (display q)
    (display "\n")
    (space sp)
    (display "count:")
    (display count)
    (display "\n")
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (* p p) (* q q))
                     (+ (* 2 p q) (* q q))
                     (/ count 2) (+ sp 1)))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1) (+ sp 1)))))
#+END_SRC

~Упражнение 1.20~

Процесс, порождаемый процедурой, разумеется, зависит от того, по каким правилам
работает интерпретатор. В качестве примера рассмотрим итеративную процедуру gcd,
приведенную выше. Предположим, что мы вычисляем эту процедуру с помощью нормального
порядка, описанного в разделе 1.1.5.
(Правило нормального порядка вычислений для if описано в упражнении 1.5.)
Используя подстановочную модель для нормального порядка, проиллюстрируйте процесс,
порождаемый при вычислении (gcd 206 40) и укажите, какие операции вычисления остатка
действительно выполняются. Сколько операций remainder выполняется на самом деле при вычислении
(gcd 206 40) в нормальном порядке? При вычислении в аппликативном порядке?

#+BEGIN_SRC scheme

(define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

#+END_SRC

Итак, нормальный порядок вычислений будет сначала подставит все аргументы и только
потом запустит процедуру "«полная подстановка, затем редукция".If будет работать
одинаково и при аппликативном, и при нормальном порядке.

Апликативный порядок будет осуществляться:

Даны аргументы 206 и 40. Их можно сразу подставить и запустить процедуру gcd.
Сработает ветка if-a false, т.к. 40 != 0. Процедура remainder получит аргументы
206 и 40,вернет остаток от деления, запустится рекурсивный вызов gcd и так будет до тех пор, пока
b не окажется = 0. Иными словами, мы будем сначала вычислять аргументы, а затем
запускать процедуру.

При нормальном порядке аргументы remainder не будут вычислены.
Проще показать это через код:
#+BEGIN_SRC scheme
;; доделать!
  ;; первый вызов
  (gcd 206 40 ) ->

  (if (= 40 0)
      206
      (gcd 40 (remainder 206 40))) ->

  ;; рекурсивый вызов 1
  (gcd 40 (remainder 206 40)) ->

  (if (= (remainder 206 40) 0)
      40
      (gcd (remainder 206 40) (remainder 40
                                         (remainder 206 40)))) ->
  ;; рекурсивный вызов 2
  (gcd (remainder 206 40) (remainder 40
                                     (remainder 206 40))) ->

  (if (= (remainder 40
                    (remainder 206 40)) 0)

      (remainder 206 40)
      (gcd (remainder 40
                      (remainder 206 40))
           (remainder (remainder 206 40)
                      (remainder 40
                                 (remainder 206 40))))) ->




#+END_SRC



~Шпаргалка по тесту Ферма~

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  ;; принимает основание, степень и модуль
  (define (expmod base exp m)
    ;; если степень = 0, вернуть 1
    (cond ((= exp 0) 1)
          ;; если степень четная,
          ((even? exp)
           ;; рекурсивно вызываем с процедуру с степенью поделенной на 2,
           ;; когда достигнем дна рекурсии, отктимся назад, получим число, возведенное
           ;; в степень, деленную на 2 и возведем его в квадрат (см алгоритм fast-expt)
           ;; затем передадим результат и модуль в процедуру reminder,
           ;; которая вернет нам остаток от деления данного числа на модуль
           (remainder (square (expmod base (/ exp 2) m))
                      m))
          ;; если степень не четная, отнимаем от степени 1, рекурсивно вызываем процедуру,
          ;; достигаем дна рекурсии, откатываем назад, умножаем полученный результат
          ;; основание и передаем все в remainder, чтоб, опять же, получить остаток
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))

  ;; вызов exmod  с рандомным числом от "a" до n-1
  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

  ;; если тест Ферма прошел заданное кол-во раз, мы считаем, что число n простое
  (define (fast-prime? n times)
    (cond ((= times 0) #t)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else #f)))
#+END_SRC


~Упражнение 1.21~

С помощью процедуры smallest-divisor найдите наименьший делитель следующих чисел:
199, 1999, 19999.

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))
#+END_SRC

Для числа 199 - наименьший делитель само число, т.к. это простое число, для 1999 - само
число по аналогичной причине (вообще-то наименьший делитель для них должен быть 1)

Для числа 19999 ответ 7, т.к. это непростое число.


~Упражнение 1.22~
Бо́льшая часть реализаций Лиспа содержат элементарную процедуру runtime, которая
возвращает целое число, показывающее, как долго работала система (например, в
миллисекундах).

Следующая процедура timed-prime-test, будучи вызвана с целым числом n, печатает n и
проверяет, простое ли оно. Если n простое, процедура печатает три звездочки и количество
времени, затраченное на проверку.

Используя эту процедуру, напишите процедуру search-for-primes, которая проверяет на
простоту все нечетные числа в заданном диапазоне. С помощью этой процедуры найдите
наименьшие три простых числа после 1000; после 10 000; после 100 000; после 1 000 000.
Посмотрите, сколько времени затрачивается на каждое простое число.
Поскольку алгоритм проверки имеет порядок роста Θ(√n), Вам следовало бы ожидать,
что проверка на простоту чисел, близких к 10 000, занимает в 10 раз больше времени, чем
для чисел, близких к 1000. Подтверждают ли это Ваши замеры времени?
Хорошо ли поддерживают предсказание √n данные для 100 000 и 1 000 000?
Совместим ли Ваш результат с предположением, что программы на Вашей машине затрачивают
на выполнение задач время, пропорциональное числу шагов?


#+BEGIN_SRC scheme
  (define (report-prime start-time end-time)
    (display " *** ")
    (display (- (cdr end-time) (cdr start-time)))
    (display "\n")
    #t)

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime start-time (gettimeofday))
        #f))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (gettimeofday)))

#+END_SRC

Отсутствует процедура runtime, пришлось заменить на такой "кустарный" таймер.
gettimeofday пару значений: секунды и микросекунды с 1.1.1970.

Добавила возвращаемые значение #t, если число простое, и #f - если нет, так легче
написать search-for-primes.

Процедура принимает диапазон, в котором должна найти простые числа, и кол-во этих
простых чисел.
#+BEGIN_SRC scheme
  (define (search-for-primes start-num end-num count)
    (cond ((= (remainder start-num 2) 0) (search-for-primes (+ 1 start-num) end-num count))
          ((or (= count 0) (= start-num end-num)) (display "finished\n"))
          ((timed-prime-test start-num)
           (search-for-primes (+ 2 start-num) end-num (- count 1)))
          (else (search-for-primes (+ 2 start-num) end-num count))))

#+END_SRC

Форматный вывод:
1009 *** 11
1013 *** 14
1019 *** 10

10007 *** 65
10009 *** 72
10037 *** 67

100003 *** 168
100019 *** 167
100043 *** 119

1000003 *** 546
1000033 *** 546
1000037 *** 679

Итак, если верить полученному выводу, то на поиск простых чисел, ближайших к
10 000, уходит не в 10 раз больше времени, чем для поиска простых чисел, ближайших к
1000. Возможно, дело во внутренней оптимизации.

Если я правильно понимаю обозначение Θ(√n), то число шагов будет расти как "квабратный
корень от n", т.е. кол-во шагов при n = 1000 приблизительно равно 32, при n = 10 000
кол-во шагов приблизительно равно 100, при n = 100 000 число шагов приблизительно 320,
при n = 1 000 000 приблизительно 1000. Т.е. чтоб найти три простых числа рядом
с 100 00 нужно в 10 раз меньше шагов чем для 1 000 000, и в 10 раз меньше шагов
нужно, чтоб найти три простых числа рядом с 1000, чем рядом 100 000.

Смотрим на вермя: для 1 000 000 понадобилось приблизительно в 10 раз больше времени,
чем для 10 000, для 100 000 понадобилось приблизительно в 10 раз больше времени, чем
для 1000.

Ответ: да, кол-во времени пропорционально кол-ву затрачиваемых шагов.

~Упражнение 1.23~
Процедура smallest-divisor в начале этого раздела проводит множество лишних проверок:
после того, как она проверяет, делится ли число на 2, нет никакого смысла проверять
делимость на другие четные числа. Таким образом, вместо последовательности
2, 3, 4, 5, 6 . . . , используемой для test-divisor, было бы лучше использовать
2, 3, 5, 7, 9 . . . .

Чтобы реализовать такое улучшение, напишите процедуру next,
которая имеет результатом 3, если получает 2 как аргумент, а иначе возвращает свой
аргумент плюс 2.
Используйте (next test-divisor) вместо (+ test-divisor 1) в
smallest-divisor.

Используя процедуру timed-prime-test с модифицированной версией smallest-divisor,
запустите тест для каждого из 12 простых чисел, найденных в упражнении 1.22.
Поскольку эта модификация снижает количество шагов проверки вдвое, Вы должны ожидать
двукратного ускорения проверки. Подтверждаются ли эти ожидания?
Если нет, то каково наблюдаемое соотношение скоростей двух алгоритмов, и как Вы
объясните то, что оно отличается от 2?

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (next test-divisor)
    (if (= test-divisor 2)
        3
        (+ test-divisor 2)))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (next test-divisor)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))

#+END_SRC

Судя по форматному выводу, для первой тройки чисел отклонение составляет 2-3
милисекунды, со второй тройкой чисел тоже почти не изменилась, как и с третьей.
Больше всего изменения коснулись последней тройки:

было:  1000003 *** 546     стало:  1000003 *** 389
       1000033 *** 546             1000033 *** 389
       1000037 *** 679             1000037 *** 342

В принципе, мы можем сказать, что получили двухкратный прирост производительности, т.к.
я думаю, что остальные результаты мало изменились по причине хорошой оптимизации кода
внутри интерпритатора и при неоптимальной версии smallest-divisor. На более больших
числах внутренняя оптимизация работала хуже.

P.S. Проверено на более больших числах. Гипотеза не подтвердилась, процедура с
первоначальной  версией smallest-divisor работает даже быстрее, чем с
оптимальной. Возможно, это все шутки интерпритатора, т.к. процедуры сравнительно
небольшие.

~Упражнение 1.24~
Модифицируйте процедуру timed-prime-test из упражнения 1.22 так, чтобы она использовала
fast-prime? (метод Ферма) и проверьте каждое из 12 простых чисел, найденных в этом
упражнении.
Исходя из того, что у теста Ферма порядок роста Θ(log n), то какого соотношения
времени Вы бы ожидали между проверкой на простоту поблизости от 1 000 000 и
поблизости от 1000?
Подтверждают ли это Ваши данные? Можете ли Вы объяснить наблюдаемое несоответствие,
если оно есть?

#+BEGIN_SRC scheme
  (define (report-prime start-time end-time)
    (display " *** ")
    (display (- (cdr end-time) (cdr start-time)))
    (display "\n")
    #t)

  (define (start-prime-test n start-time)
    (if (fast-prime? n 5)
        (report-prime start-time (gettimeofday))
        #f))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (gettimeofday)))

#+END_SRC

Итак, если алгоритм растет как Θ(log n), то он растет медленнее, чем Θ(√n), т.к.
если n = 9, то логарифм от по основанию 3 равен 2 от 9. А вот квадратный корень из 9
= 3. 2 < 3, поэтому я думаю, что Θ(log n) растет медленнее.

Исходя из этого предположения можно сказать, что timed-prime-test, использующий метод
Ферма, должен работать быстрее, чем прежняя версия.

предыдущий результат:
1000003 *** 389
1000033 *** 389
1000037 *** 342

новый результат, если ставить проверку 5 раз:
1000003 *** 163
1000033 *** 285
1000037 *** 198


Мы видим, что новая версия работает в полтора-два раза быстрее. Схожесть на более
маленьких числах я объясняю оптимизацией интерпритатора.

~Вопросы:~
Как рассчитать время при проверке чисел для 1000 и для 1 000 000, не загружая в
интерпритатор? Понятно, что для 1000 будет меньше, но как рассчитать точно?

Метод Ферма вероятностный. Т.е. он должен отработать несколько раз, чтоб мы могли
считать его результат достаточно достоверным, в то время как prime? отрабатывает только
1 раз. Я могу запустить метод Ферма 10 000 раз, получить результат как от prime?, но
только метод Ферма в будет работать сильно дольше, хотя логарифмический рост медленнее
чем O(квадратный корень от n). И как быть тогда?


~Упражнение 1.25~
Лиза П. Хакер жалуется, что при написании expmod мы делаем много лишней работы. В конце
концов, говорит она, раз мы уже знаем, как вычислять степени, можно просто написать.

#+BEGIN_SRC scheme
  (define (expmod base exp m)
    (remainder (fast-expt base exp) m))
#+END_SRC

Права ли она? Стала бы эта процедура столь же хорошо работать при проверке простых
чисел?
Объясните.

Я думаю, что права, поскольку fast-expt работает по тому же механизму, что оригинальная
expod. Я думаю, что у обоих алгоритмов рост O(log n).

~Упражнение 1.26~

У Хьюго Дума большие трудности в упражнении 1.24. Процедура fast-prime? у него работает
медленнее, чем prime?. Хьюго просит помощи у своей знакомой Евы Лу Атор. Вместе изучая
код Хьюго, они обнаруживают, что тот переписал процедуру expmod с явным использованием
умножения вместо того, чтобы вызывать square:


#+BEGIN_SRC scheme
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (remainder (* (expmod base (/ exp 2) m)
                         (expmod base (/ exp 2) m))
                      m))
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))
#+END_SRC


Хьюго говорит: «Я не вижу здесь никакой разницы». «Зато я вижу, — отвечает Ева. —
Переписав процедуру таким образом, ты превратил процесс порядка Θ(log n) в процесс порядка
Θ(n)».
Объясните.

Процедура ~square~
#+BEGIN_SRC scheme
  (define (square x) (* x x))
#+END_SRC

Ответ: Хьюго исполняет одни и те же вычисления дважды, а затем умножает результат
вычислений друг на друга. Да, формально это дает тот же ответ, что при использовании
square, только вот в оригинальной процедуре вычисление проводится один раз и по мере
отката рекурсии назад мы возводим каждое промежуточное значение в квадрат, включая
результат от самого первого рекурсивного вызова. Это позволяет в два раза скорее
производить вычисление.

~Упражнение 1.27~
Покажите, что числа Кармайкла, перечисленные в сноске 47, действительно «обманывают»
тест Ферма: напишите процедуру, которая берет целое число n и проверяет, правда ли a^n
равняется a по модулю n для всех a < n, и проверьте эту процедуру
на этих числах Кармайкла.

Числа Кормайкла 561, 1105, 1729, 2465, 2821 и 6601.

Я взяла процедуры из теста Ферма и слегка их изменила.
#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (remainder (square (expmod base (/ exp 2) m))
                      m))
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))

  (define (cormaickle-test n a)
    (cond ((= a n) #t)
          ((= (expmod a n n) a) (cormaickle-test n (+ 1 a)))
          (else #f)))
#+END_SRC

~Упражнение 1.28~
Один из вариантов теста Ферма, который невозможно обмануть, называется тест
Миллера–Рабина (Miller-Rabin test) (Miller 1976; Rabin 1980).
Он основан на альтернативной формулировке Малой теоремы Ферма, которая состоит в том,
что если n — простое число, а "a" — произвольное положительное целое число,
меньшее n, то a в n − 1-ой степени равняется 1 по модулю n.

Проверяя простоту числа  n методом Миллера–Рабина, мы берем случайное число a < n
и возводим его в (n − 1)-ю степень по модулю n с помощью процедуры expmod.
Однако когда в процедуре expmod мы проводим возведение в квадрат, мы проверяем,
не нашли ли мы «нетривиальный квадратный корень из 1 по модулю n»,
то есть число, не равное 1  или n − 1, квадрат которого по модулю n равен 1.
Можно доказать, что если такой нетривиальный квадратный корень из 1 существует,
то n не простое число. Можно, кроме того, доказать, что если n — нечетное
число, не являющееся простым, то по крайней мере для половины чисел a < n
вычисление a n−1 с помощью такой процедуры обнаружит нетривиальный квадратный корень
из 1 по модулю n (вот почему тест Миллера–Рабина невозможно обмануть).

Модифицируйте процедуру expmod так, чтобы она сигнализировала обнаружение
нетривиального квадратного корня из 1, и используйте ее для реализации теста
Миллера–Рабина с помощью процедуры, аналогичной fermat-test.
Проверьте свою процедуру на нескольких известных Вам простых и составных числах.
Подсказка: удобный способ заставить expmod подавать особый сигнал — заставить
ее возвращать 0.

Альтернативная формулировка малой теоремы Ферма:
a^(n - 1) = 1 (mod n)

Первая проверка:
«нетривиальный квадратный корень из 1 по модулю n» = чило в диапазоне от 2 до n - 2,
чей квадрат = 1 ( mod m), т.е. надо возвести число в квадрат, разделить на n, разделить
1 на n и сравнить остатки этих чисел. Если остатки равны, то исходное число не
простое.

Вторая проверка: если число нечетное и не простое, то минимум для половины чисел
a < n первая проверка даст положительный результат.

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (check n m)
    (if (and (not (= n 1))
             (not (= n (- m 1)))
             (= (remainder (square n) m)  1))
        0
        (remainder (square n) m)))

  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (check (expmod base (/ exp 2) m) m))
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))

  (define (try-it a n)
    (= (expmod a (- n 1) n) 1))

  (define (m-r-test-iter n a positiv)
    (if (= a (- n 1))
        (> positiv (/ n 2))
        (if (try-it a n)
            (m-r-test-iter n (+ a 1) (+ 1 positiv))
            (m-r-test-iter n (+ a 1) positiv))))

  (define (m-r-test n)
    (m-r-test-iter n 1 0))
#+END_SRC


~Упражнение 1.29~
Правило Симпсона — более точный метод численного интегрирования, чем представленный
выше.

Представленный выше вариант:
#+BEGIN_SRC scheme
  (define (integral f a b dx)
    (define (add-dx x) (+ x dx))
    (* (sum f (+ a (/ dx 2)) add-dx b)
       dx))
#+END_SRC

С помощью правила Симпсона интеграл функции f между a и b приближенно вычисляется в
виде:

h[y0 + 4y1 + 2y2 + 4y3 + 2y4 + . . . + 2y n−2 + 4yn−1 + yn ]
3

где h = (b − a)/n, для какого-то четного целого числа n, а yk = f(a + kh).
(Увеличение n повышает точность приближенного вычисления.)
Определите процедуру, которая принимает в качестве аргументов f, a, b и n,
и возвращает значение интеграла, вычисленное по правилу Симпсона.
С помощью этой процедуры проинтегрируйте cube между 0 и 1 (с n = 100 и n = 1000) и
сравните результаты с процедурой integral, приведенной выше.

- n > 0
- h = (b − a)/n - это один шаг
- yk = f(a + kh); параметр функции f - это a + kh; k - коэфициент от 0 до n
  (предположительно)
находи Y через функцию, затем умножаем на k. Если коэфициент четный, все это умножается
на 2, если нечетный, то на 4, за исключением случая, когда k = 0 или k=n, тогда ничего
не умножаем
- a = нижний порог интегрирования (что бы это не значило)
- b = верхний порог интегрирования
- f - какая-то функция (в нашем случае будет cube)

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (inc n)
    (+ 1 n))

  (define (simpson f a b n)
    (define (h)
      (/ (- b a) n))
    (define (funk k)
      (define (multiplier)
        (cond ((or (= k 0) (= k n)) 1)
              ((even? k) 2)
              (else 4)))
      (* (multiplier) (f (+ a (* k (h))))))
    (* (/ (h) 3)
       (sum funk 0 inc n)))

#+END_SRC

~Упражнение 1.30~
Процедура sum порождает линейную рекурсию. Ее можно переписать так, чтобы суммирование
выполнялось итеративно.

Оригинал:
#+BEGIN_SRC scheme

(define (sum term a next b)
    (if (> a b)
        0
        (+ (term a)
           (sum term (next a) next b))))

#+END_SRC

Мой вариант:
#+BEGIN_SRC scheme
  (define (my-sum term a next b)
    (define (iter a result)
      (if (> a b)
          result
          (iter (next a) (+ result (term a)))))
    (iter a 0))
#+END_SRC

~Упражнение 1.31~
Процедура sum — всего лишь простейшая из обширного множества подобных абстракций,
которые можно выразить через процедуры высших порядков. Напишите аналогичную
процедуру под названием product, которая вычисляет произведение значений функции
в точках на указанном интервале.
Покажите, как с помощью этой процедуры определить factorial.
Кроме того, при помощи product вычислите приближенное значение пи по формуле (см
стр. 73)

Реализовать в двух вариантах: хвостовая и нехвостовая рекурсия.

Формула факториала:
n! = n · (n − 1) · (n − 2) · · · 3 · 2 · 1

Процедура факториала:
#+BEGIN_SRC scheme

  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))

#+END_SRC

#+BEGIN_SRC scheme
  ;; нехвостовая рекурсия
  (define (product f a b next)
    (if (> a b )
        1
        (* (f a)
           (product f (next a) b next))))

  ;; хвостовая рекурсия
  (define (product f a b next)
    (define iter (a result)
      (if (> a b )
          result
          (iter (next a) (* result (term a))))))

  ;; определение факториала
  (define (my-factorial n)
    (define (inc n)
      (+ 1 n ))
    (define (identity x)
      x)
    (product identity 1 n inc))

  ; нахождение pi по формуле Уоллиса
  (define (pi n)
    (define (step x)
      (/ (* x x) (* (- x 1) (+ x 1))))
    (define (pi-next x)
      (+ x 2))
    (* 2.0 (product step 2 n pi-next)))
#+END_SRC


~Упражнение 1.32~
Покажите, что sum и product (упражнение 1.31) являются частными случаями еще более
общего понятия, называемого накопление (accumulation), которое комбинирует множество
термов с помощью некоторой общей функции накопления
(accumulate combiner null-value term a next b)
Accumulate принимает в качестве аргументов те же описания термов и диапазона,
что и sum с product, а еще процедуру combiner (двух аргументов),
которая указывает, как нужно присоединить текущий терм к результату накопления
предыдущих, и null-value, базовое значение, которое нужно использовать, когда термы
закончатся. Напишите accumulate и покажите, как и sum, и product можно определить в
виде простых вызовов accumulate.

Написать как хвостовую и нехвостовую рекурсию.

#+BEGIN_SRC scheme
  ;; хвостовая рекурсия
  (define (accumulate combiner null-value term a next b)
    (define (iter a accum)
      (if (> a b)
          accum
          (iter (next a) (combiner (term a) accum))))
    (iter a null-value))

  ;; нехвостовая рекурсия
  (define (accumulate combiner null-value term a next b)
    (if (> a b )
        null-value
        (combiner (term a)
                   (accumulate combiner null-value
                               term (next a) next b))))

  (define (new-product term a b next)
    (accumulate * 1 term a next b))

  (define (new-sum term a b next)
    (accumulate + 0 term a next b))

  ;; вспомогательные функции, чтоб "поиграться"
  (define (identity x)
    x)

  (define (inc n)
    (+ n 1))

  (define (square x)
    (* x x))
#+END_SRC

~Упражнение 1.33~

Можно получить еще более общую версию accumulate, если ввести понятие
фильтра (filter) на комбинируемые термы. То есть комбинировать только те термы,
порожденные из значений диапазона, которые удовлетворяют указанному условию.
Получающаяся абстракция filtered-accumulate получает те же аргументы, что и accumulate,
плюс дополнительный одноаргументный предикат, который определяет фильтр.
Запишите filtered-accumulate в виде процедуры.
Покажите, как с помощью filtered-accumulate выразить следующее:
а. сумму квадратов простых чисел в интервале от a до b (в предположении, что процедура
prime? уже написана);
б. произведение всех положительных целых чисел меньше n, которые просты по отношению к
n (то есть всех таких положительных целых чисел i < n, что НОД(i, n) = 1).

#+BEGIN_SRC scheme
  (define (filtered-accumulate combiner null-value term a next b filter)
    (define (iter a accum)
      (cond (( > a b) accum)
            ((filter a)
             (iter (next a) (combiner (term a) accum)))
            (else (iter (next a) accum))))
    (iter a null-value 0))

  ;; вспомогательные процедуры для подпунктов а и б
  (define (divides? a b)
    (= (remainder b a) 0))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))

  ;; решение для a
  (define (sum-squares-primes a b )
    (define (inc x)
      (+ 1 x))
    (define (square x) (* x x))
    (filtered-accumulate + 0 square a inc b prime?))

  ;; решение для б
  (define (product-primes-for-n n)
    (define (gcd a b)
      (if (= b 0)
          a
          (gcd b (remainder a b))))
    (define (identity x)
      x)
    (define (inc x)
      (+ 1 x))
    (define (prime-for-n? g)
      (= (gcd g n) 1))
    (filtered-accumulate * 1 identity 1 inc n prime-for-n?))
#+END_SRC

~Упражнение 1.34~
Допустим, мы определили процедуру
#+BEGIN_SRC scheme
  (define (f g)
    (g 2))

  ;; тогда:
  (f square)
  => 4

  (f (lambda (z) (* z (+ z 1))))
  => 6
#+END_SRC

Что случится, если мы (извращенно) попросим интерпретатор вычислить комбинацию (f f)?
Объясните.

Ответ: мой интерпритатор выдал ошибку, думаю, дело в том, что функция должна принимать
1 аргумент. Первый вызов получает в качестве аргумента f функцию f. Функция f
подставляется вместо g, получает в качестве аргумента 2. Мы опускаемся на уровень
вложенности ниже, снова подставляем вместо g переданный параметр. В нашем случае
интерпритатор ожидает, что g - это одноаргументная процедура или предикат, но вместо
этого получает число. Отсюда ошибка.


~Упражнение 1.35~
Покажите, что золотое сечение φ (раздел 1.2.2) есть неподвижная точка трансформации
x→  1 + 1/x, и используйте этот факт для вычисления фи с помощью процедуры fixed-point.

φ^2 = φ + 1 - это формула золотого сечения

#+BEGIN_SRC scheme
  (define tolerance 0.00001)

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

  (fixed-point (lambda (x)
                 (+ 1 (/ 1 x)))
               1.0)

#+END_SRC

~Упражнение 1.36~
Измените процедуру fixed-point так, чтобы она печатала последовательность приближений,
которые порождает, с помощью примитивов newline и display, показанных в упражнении
1.22.

Затем найдите решение уравнения x^x = 1000 путем поиска неподвижной точки
x → log(1000)/ log(x). (Используйте встроенную процедуру Scheme log, которая вычисляет
натуральные логарифмы.) Посчитайте, сколько шагов это занимает при использовании
торможения усреднением и без него. (Учтите, что нельзя начинать fixed-point со значения 1,
поскольку это вызовет деление на log(1) = 0.)

Воспользовалась форматом, поскольку он удобнее.
#+BEGIN_SRC scheme
  (define tolerance 0.00001)

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (format #t "next ~A\n" next)
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

  (define (average x y)
    (/ (+ x y) 2))

  ;; с торможением (работает быстрее)
  (fixed-point (lambda (x)
                 (average x (/ (log 1000) (log x))))
               2.0)

  ;; без
  (fixed-point (lambda (x)
                 (/ (log 1000) (log x)))
               2.0)
#+END_SRC

~Упражнение 1.37~
Бесконечная цепная дробь имеет вид: (см стр. 82)

В качестве примера можно показать, что расширение бесконечной цепной дроби при всех Ni
и Di , равных 1, дает 1/φ, где φ — золотое сечение (описанное в разделе 1.2.2). Один из
способов вычислить цепную дробь состоит в том, чтобы после заданного количества
термов оборвать вычисление. Такой обрыв — так называемая конечная цепная дробь.

Предположим, что n и d — процедуры одного аргумента (номера элемента i),
возвращающие Ni и Di элементов цепной дроби. Определите процедуру cont-frac так,
чтобы вычисление (cont-frac n d k) давало значение k-элементной конечной цепной дроби.
Проверьте свою процедуру, вычисляя приближения к 1/φ с помощью

#+BEGIN_SRC scheme

  (cont-frac (lambda (i) 1.0)
             (lambda (i) 1.0)
             k)
#+END_SRC

Если Ваша процедура cont-frac порождает рекурсивный процесс, напишите вариант, кото-
рый порождает итеративный процесс. Если она порождает итеративный процесс, напишите
вариант, порождающий рекурсивный процесс.

Перевод:
- цепная дробь - это дробь, у которой в знаменателе стоит другая дробь, а у того
тоже стоит дробь и т.д. И так либо пока не встретим конец, тогда это будет конечная
цепная дробь, либо мы конца не будет, и тогда дробь бесконечная.
- если Ni = 1 или Di = 1, то мы имеем 1/φ, где φ — золотое сечение (почему?)
- n и d - это процедуры, принимающие 1 аргумент. Этот аргумент - коэфициент,т.е. i
Процедуры должны вернуть значение N и D с этим коэфициентом.
- процедура cont-frac принимает 2 функции и 1 аргумент, который будет аргументом
для этих функций

#+BEGIN_SRC scheme
  ;; нехвостовая рекурсия
  (define (cont-frac n d k)
    (define (rec i)
      (/ (n i) (+ (d i)
                  (if (> i k )
                      1
                      (rec (+ 1 i))))))
    (rec 1))

  ;; хвостовая
  (define (cont-frac n d k)
    (define (iter i accum)
      (if (> i k)
          accum
          (iter (+ 1 i) (/ (n i) (+ (d i) accum)))))
    (iter 1 1))

  ;; достаточно k = 13, чтоб получить 4 правильных знака после запятой
  (define (g-r k)
    (cont-frac (lambda (i) 1.0)
               (lambda (i) 1.0)
               k))



#+END_SRC

~Упражнение 1.38~
В 1737 году швейцарский математик Леонард Эйлер опубликовал статью De functionibus
Continuis, которая содержала расширение цепной дроби для e − 2, где e — основание
натуральных логарифмов. В этой дроби все N i равны 1, а D i последовательно
равны 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, . . .
Напишите программу, использующую Вашу процедуру cont-frac из упражнения 1.37 для
вычисления e на основании формулы Эйлера.


#+BEGIN_SRC scheme
  ;; вариант по найденной в интернете формуле
  (define (euler-e k)
    (let ((e (cont-frac (lambda (i) 1.0)
                        (lambda (i) (- (* i 4) 2))
                        k)))
      (+ 2 e)))

  ;; подсмотренное
  (define (euler-e k)
    (+ 2 (cont-frac (lambda (i) 1.0)
               (lambda (i)
                 (if (= (remainder i 3) 2)
                     (* 2 (/ (+ i 1) 3))
                     1))
               k)))

  #+END_SRC

~Упражнение 1.39~
Представление тангенса в виде цепной дроби было опубликовано в 1770 году немецким
математиком Й.Х. Ламбертом (см. стр 82), где x дан в радианах. Определите процедуру
(tan-cf x k), которая вычисляет приближение к тангенсу на основе формулы Ламберта.
K указывает количество термов, которые требуется вычислить, как в упражнении 1.37.

#+BEGIN_SRC scheme
  (define (tan-cf x k)
    (define (iter x y i k)
      (- y
         (if (> i k)
             0
             (iter x (+ y 2) (+ i 1) k))))
    (/ x (iter (* x x) 1 1 k)))
#+END_SRC

~Упражнение 1.40~
Определите процедуру cubic, которую можно было бы использовать совместно с процедурой
newtons-method в выражениях вида (newtons-method (cubic a b c) 1)
для приближенного вычисления нулей кубических уравнений x^3 + ax^2 + bx + c.

#+BEGIN_SRC scheme
  (define dx 0.00001)

  (define tolerance 0.00001)

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))

  (define (deriv g)
    (lambda (x)
      (/ (- (g (+ x dx)) (g x))
         dx)))

  (define (newton-transform g)
    (lambda (x)
      (- x (/ (g x) ((deriv g) x)))))

  (define (newtons-method g guess)
    (fixed-point (newton-transform g) guess))

  (define (cube x)
    (* x x x))
  (define (square x)
    (* x x))

  (define (cubic a b c)
    (lambda (x)
      (+ (cube x) (* a (square x)) (* b x) c)))

  (newtons-method (cubic 0 0 -8) 1)
#+END_SRC

~Упражнение 1.41~
Определите процедуру double, которая принимает как аргумент процедуру с одним
аргументом и возвращает процедуру, которая применяет исходную процедуру дважды.
Например, если процедура inc добавляет к своему аргументу 1, то (double inc)
должна быть процедурой, которая добавляет 2. Скажите, какое значение возвращает
(((double (double double)) inc) 5)

#+BEGIN_SRC scheme
  (define (double g)
    (lambda (x)
      (g (g x))))

  (define (inc x)
    (+ x 1))

  ((double inc) 1)
#+END_SRC

(((double (double double)) inc) 5) => 21

Чтобы 5 превратилась в 21, нужно, чтоб inc отработал 16 раз (21 - 5 = 16)
Соответственно, нужно, чтоб double сработал 8 раз, что мы и имеем.
Поскольку мой интерпритатор использует нормальный порядок, то сначала
мы подставим все полученные лямбды от в места вызова double (лямбды
окажутся вложенными друг в друга), а затем передадим туда процедуру inc и
аргумент 5, который будет увеличиваться при подъеме от самого низкого уровня
вложенности до самого высокого.

~Упражнение 1.42~
Пусть f и g — две одноаргументные функции. По определению, композиция (composition) f и
g есть функция x → f (g(x)).
Определите процедуру compose которая реализует
композицию.
Например, если inc — процедура, добавляющая к своему аргументу 1,
((compose square inc) 6) => 49

#+BEGIN_SRC scheme
  (define (compose f g)
    (lambda (x)
      (f (g x))))

  (define (inc x)
    (+ x 1))

  (define (square x)
    (* x x))
#+END_SRC

~Упражнение 1.43~
Если f есть численная функция, а n — положительное целое число, то мы можем построить
n-кратное применение f , которое определяется как функция, значение которой в точке x
равно f (f (. . . (f (x)) . . .)).
Например, если f есть функция x → x + 1, то n-кратным применением f
будет функция x → x + n. Если f есть операция возведения в квадрат, то n-кратное
применение f есть функция, которая возводит свой аргумент в 2n-ю степень.
Напишите процедуру, которая принимает в качестве ввода процедуру, вычисляющую f ,
и положительное целое n, и возвращает процедуру, вычисляющую n-кратное применение f .
Требуется, чтобы Вашу процедуру можно было использовать в таких контекстах:
((repeated square 2) 5) => 625
Подсказка: может оказаться удобно использовать compose из упражнения 1.42.

Иными словами, процедра должна принимать функцию и кол-во раз, сколько эту функцию
надо применить к аргументу. А возвращать должна процеудуру, которая применяет
фнкцию к аргументу заданное кол-во раз.
#+BEGIN_SRC scheme
  (define (inc x)
    (+ x 1))

  (define (square x)
    (* x x))

  (define (repeated f n)
    (lambda (x)
      (define (test x n)
        (if (= n 0)
            x
            (test (f x) (- n 1))))
      (test x n)))

  ((repeated square 2) 5) => 625
  ((repeated inc 19) 5) => 24

#+END_SRC

~Упражнение 1.44~
Идея сглаживания (smoothing a function) играет важную роль в обработке сигналов. Если f
— функция, а dx — некоторое малое число, то сглаженная версия f есть функция, значение
которой в точке x есть среднее между f (x − dx), f (x) и f (x + dx).
Напишите процедуру smooth, которая в качестве ввода принимает процедуру,
вычисляющую f , и возвращает процедуру, вычисляющую сглаженную версию f . Иногда бывает
удобно проводить повторное сглаживание (то есть сглаживать сглаженную функцию и т.д.),
получая n-кратно сглаженную функцию (n-fold smoothed function).
Покажите, как породить n-кратно сглаженную функцию с помощью smooth и
repeated из упражнения 1.43.

#+BEGIN_SRC scheme
  (define (inc x)
    (+ x 1))

  (define (square x)
    (* x x))

  (define (smooth f)
    (define dx 0.01)
    (lambda (x)
      (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))

  (define (repeated f n)
    (lambda (x)
      (define (test x n)
        (if (= n 0)
            x
            (test (f x) (- n 1))))
      (test x n)))

  ((repeated (smooth square) 2) 5)
#+END_SRC

~Упражнение 1.45~.
В разделе 1.3.3 мы видели, что попытка вычисления квадратных корней путем наивного
поиска неподвижной точки y → x/y не сходится, и что это можно исправить путем торможения
усреднением. Тот же самый метод работает для нахождения кубического корня как
неподвижной точки y → x/y^2 , заторможенной усреднением.
К сожалению, этот процесс не работает для корней четвертой степени — однажды
примененного торможения усреднением недостаточно, чтобы заставить сходиться процесс
поиска неподвижной точки y → x/y^3 . С другой стороны, если мы применим торможение
усреднением дважды (т.е. применим торможение усреднением к результату торможения
усреднением от y → x/y^3 ), то поиск неподвижной точки начнет сходиться. Проделайте
эксперименты, чтобы понять, сколько торможений усреднением нужно, чтобы вычислить
корень n-ой степени как неподвижную точку на основе многократного торможения усреднением
функции y → x/y n−1 . Используя свои результаты для того, напишите простую процедуру
вычисления корней n-ой степени с помощью процедур fixed-point, average-damp и repeated
из упражнения 1.43. Считайте, что все арифметические операции, какие Вам понадобятся,
присутствуют в языке как примитивы.

#+BEGIN_SRC scheme
  (define (inc x)
    (+ x 1))

  (define (square x)
    (* x x))

  (define tolerance 0.00001)

  (define (fixed-point f first-guess)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    (define (try guess)
      (let ((next (f guess)))
        (if (close-enough? guess next)
            next
            (try next))))
    (try first-guess))


  (define (average x y)
    (/ (+ x y) 2))

  ;; вычисляет среднее между иксом и результатом, который мернет функция с параметром
  ;; икс
  (define (average-damp f)
    (lambda (x) (average x (f x))))

  (define (repeated f n)
    (lambda (x)
      (define (test x n)
        (if (= n 0)
            x
            (test (f x) (- n 1))))
      (test x n)))

  ((repeated sqrt 2) 16)

  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))

  (define (log2 x)
      (/ (log x) (log 2)))

  (define (nth-root-empirical n x)
    (define (f y) (/ x (fast-expt y (- n 1))))
    (define damp-count (floor (log2 n)))
    (fixed-point ((repeated average-damp damp-count) f) 1.0))
#+END_SRC

~Упражнение 1.46~
Некоторые из вычислительных методов, описанных в этой главе, являются примерами
чрезвычайно общей вычислительной стратегии, называемой пошаговое улучшение
(iterative improvement). Пошаговое улучшение состоит в следующем: чтобы что-то
вычислить, нужно взять какое-то  начальное значение, проверить, достаточно ли оно
хорошо, чтобы служить ответом, и если нет, то улучшить это значение и продолжить
процесс с новым значением. Напишите процедуру iterative-improve, которая принимает
в качестве аргументов две процедуры: проверку, достаточно ли хорошо значение,
и метод улучшения значения. Iterative-improve должна возвращать процедуру,
которая принимает начальное значение в качестве аргумента и улучшает его, пока оно не
станет достаточно хорошим.
Перепишите процедуру sqrt из раздела 1.1.7 и процедуру fixed-point из раздела 1.3.3 в
терминах iterative-improve.

#+BEGIN_SRC scheme
  (define (iterative-improve check method)
    (lambda (x)
      (define (try x)
        (let ((next (method x)))
          (format #t "x ~A next ~A\n" x next)
          (if (check x next)
              next
              (try next))))
      (try x)))

  (define (new-fixed-point f first-guess)
    (define tolerance 0.00001)
    (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
    ((iterative-improve close-enough? f) first-guess))

  (define (new-sqrt x)
    (define tolerance 0.00001)
    (define (average x y)
      (/ (+ x y) 2))
    ((iterative-improve (lambda (guess next)
                          (format #t "guess ~A next ~A x ~A\n" guess next x)
                          (< (abs (- (square next) x))
                             tolerance))
                        (lambda (guess)
                          (average guess (/ x guess)))) 1.0))

#+END_SRC

~Упражнение 2.1~
Определите улучшенную версию mul-rat, которая принимала бы как положительные, так и
отрицательные аргументы. Make-rat должна нормализовывать знак так, чтобы в случае, если
рациональное число положительно, то и его числитель, и знаменатель были бы
положительны, а если оно отрицательно, то чтобы только его числитель был отрицателен.

#+BEGIN_SRC scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (numer x) (car x))
  (define (denom x) (cdr x))

  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))

  (define (make-rat n d)
    (let ((g (gcd n d)))
      (if (< g 0)
          (cons (/ n (abs g)) (/ d g))
          (cons (/ n g) (/ d g)))))

#+END_SRC


~Упражнение 2.2~
Рассмотрим задачу представления отрезков прямой на плоскости. Каждый отрезок
представляется как пара точек: начало и конец. Определите конструктор make-segment
и селекторы start-segment и end-segment, которые определяют представление отрезков
в терминах точек. Далее, точку можно представить как пару чисел: координата x и
координата y. Соответственно, напишите конструктор make-point и селекторы x-point и
y-point, которые определяют такое представление. Наконец, используя свои селекторы и
конструктор, напишите процедуру midpoint-segment, которая принимает отрезок в качестве
аргумента и возвращает его середину (точку,координаты которой являются средним
координат концов отрезка). Чтобы опробовать эти процедуры, Вам потребуется способ
печатать координаты точек:
#+BEGIN_SRC scheme

  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))

#+END_SRC

Есть какая-то плоскость. На ней располагаются отрезки. Каждый отрезок - это начальная
и конечная точка.
#+BEGIN_SRC scheme
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")\n"))

  (define (y-point point)
    (cdr point))

  (define (x-point point)
    (car point))

  (define (make-point x y)
    (cons x y))

  (define (start-segment segment)
    (car segment))

  (define (end-segment segment)
    (cdr segment))

  (define (make-segment start end)
    (cons start end))

  (define (midpoint-segment segment)
    (let ((start (start-segment segment))
          (end (end-segment segment)))
      (print-point (make-point (/ (+ (x-point start) (x-point end)) 2)
                               (/ (+ (y-point start) (y-point end)) 2)))))

  (midpoint-segment (cons (cons 10 20) (cons 30 80)))
#+END_SRC

~Упражнение 2.3~
Реализуйте представление прямоугольников на плоскости. (Подсказка: Вам могут
потребоваться результаты упражнения 2.2.) Определите в терминах своих конструкторов
и селекторов процедуры, которые вычисляют периметр и площадь прямоугольника.
Теперь реализуйте другое представление для прямоугольников. Можете ли Вы спроектировать
свою систему с подходящими барьерами абстракции так, чтобы одни и те же процедуры
вычисления периметра и площади работали с любым из Ваших представлений?

#+BEGIN_SRC scheme
  (define (P sqaure-figure)
    (let* ((length-segment (car sqaure-figure))
           (height-segment (cdr sqaure-figure))
           (start-length (start-segment length-segment))
           (end-length (end-segment length-segment))
           (start-height (start-segment height-segment))
           (end-height (end-segment height-segment))
           (length (- (x-point end-length) (x-point start-length)))
           (height (- (y-point end-height) (y-point start-height))))
      (* (+ length height) 2)))

  (define (square sqaure-figure)
    (let* ((length-segment (car sqaure-figure))
           (height-segment (cdr sqaure-figure))
           (start-length (start-segment length-segment))
           (end-length (end-segment length-segment))
           (start-height (start-segment height-segment))
           (end-height (end-segment height-segment))
           (length (- (x-point end-length) (x-point start-length)))
           (height (- (y-point end-height) (y-point start-height))))
      (* length height)))


  ;; P и S квадрата
  (P (cons (cons (make-point 10 20) (make-point 40 20))
           (cons (make-point 40 20) (make-point 40 50))))

  (square (cons (cons (make-point 10 20) (make-point 40 20))
                (cons (make-point 40 20) (make-point 40 50))))

  ;; P и S прямоугольника
  (P (cons (cons (make-point 10 20) (make-point 40 20))
           (cons (make-point 40 20) (make-point 40 80))))

  (square (cons (cons (make-point 10 20) (make-point 40 20))
                (cons (make-point 40 20) (make-point 40 80))))
#+END_SRC

~Упражнение 2.4~
Вот еще одно процедурное представление для пар. Проверьте для этого представления, что
при любых двух объектах x и y (car (cons x y)) возвращает x.

Каково соответствующее определение cdr?
(Подсказка: Чтобы проверить, что это работает, используйте подстановочную модель из
раздела 1.1.5.)

#+BEGIN_SRC scheme
  (define (test-cons x y)
    ;; видимо m - это процедура от двух аргументов
    (lambda (m)
      (m x y)))

  (define (test-car z)
    ;; лямбда принимает 2 аргумента
    ;; и возвращает первый
    (z (lambda (p q) p)))

  (define (test-cdr z)
    ;; лямбда принимает 2 аргумента
    ;; и возвращает второй11
    (z (lambda (p q) q)))


  (test-car (test-cons 1 2))
  (test-cdr (test-cons 1 2))
#+END_SRC

~Упражнение 2.5~
Покажите, что можно представлять пары неотрицательных целых чисел, используя только
числа и арифметические операции, если представлять пару a и b как произведение 2^a
3^b. Дайте соответствующие определения процедур cons, car и cdr.

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))

  (define (crazy-cons a b)
    (* (fast-expt 2 a) (fast-expt 3 b)))

  (define (crazy-car pair)
    (find-value 2 pair))

  (define (find-value base value)
    (define (iter value count)
      (if (= (remainder value base) 0)
          (iter (/ value base) (+ 1 count))
          count))
    (iter value 0))

#+END_SRC

~Упражнение 2.6~
Если представление пар как процедур было для Вас еще недостаточно сумасшедшим, то
заметьте, что в языке, который способен манипулировать процедурами, мы можем обойтись
и без чисел (по крайней мере, пока речь идет о неотрицательных числах), определив
0 и операцию прибавления 1 так:

#+BEGIN_SRC scheme
  (define zero
    (lambda (f) (lambda (x) x)))

  ((zero +) 4)

  ;; n - какая-то функция, которая принимает другую фукцию на вход
  (define (add-1 n)
    (lambda (f)
      (lambda (x)
        (f ((n f) x)))))

  (add-1 zero)
  (lambda (f)
    (lambda (x)
      (f (((lambda (f) (lambda (x) x)) f) x))))

  (lambda (f)
    (lambda (x)
      (f ((lambda (x) x) x))))

  (define (one f)
    (lambda (f)
      (lambda (x) (f x))))

  (add-1 one)
  (define (two f)
    (lambda (f)
      (lambda (x)
        (f (((lambda (f)
               (lambda (x) (f x))) f) x)))))

  n раз применить s к применённому m раз s к z
  (add-1 add-1)
  (define (Plus m n)
    (lambda (f x)
      (m f (n f x))))
#+END_SRC

Такое представление известно как числа Чёрча (Church numerals), по имени его
изобретателя, Алонсо Чёрча, того самого логика, который придумал λ-исчисление.
Определите one (единицу) и two (двойку) напрямую (не через zero и add-1).
(Подсказка: вычислите (add-1 zero) с помощью подстановки.)
Дайте прямое определение процедуры сложения +
(не в терминах повторяющегося применения add-1).

~Упражнение 2.7.~
Программа Лизы неполна, поскольку она не определила, как реализуется абстракция
интервала.
Вот определение конструктора интервала:
(define (make-interval a b) (cons a b))
Завершите реализацию, определив селекторы upper-bound и lower-bound.

исходник:
#+BEGIN_SRC scheme
  (define (make-interval a b)
    (cons a b))

  (define (upper-bound n)
    (cdr n))

  (define (lower-bound n)
    (car n))

  (define (add-interval x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (upper-bound y)))
          (p4 (* (upper-bound x) (lower-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (div-interval x y)
    (mul-interval x
                  (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))

#+END_SRC

~Упражнение 2.8~
Рассуждая в духе Лизы, опишите, как можно вычислить разность двух интервалов. Напишите
соответствующую процедуру вычитания, называемую sub-interval.

#+BEGIN_SRC scheme
  (define (sub-interval x y)
    (cond ((and (> (lower-bound x) (lower-bound y))
                (> (upper-bound x) (upper-bound y)))
           (make-interval (- (lower-bound x) (lower-bound y))
                          (- (upper-bound x) (upper-bound y))))
          ((and (< (lower-bound x) (lower-bound y))
                (< (upper-bound x) (upper-bound y)))
           (make-interval (- (lower-bound y) (lower-bound x))
                          (- (upper-bound y) (upper-bound x))))
          ((and (> (lower-bound x) (lower-bound y))
                (< (upper-bound x) (upper-bound y)))
           (make-interval (- (lower-bound x) (lower-bound y))
                          (- (upper-bound y) (upper-bound x))))
          (else (make-interval (- (lower-bound y) (lower-bound x))
                               (- (upper-bound x) (upper-bound y))))))
#+END_SRC

~Упражнение 2.9~
Радиус (width) интервала определяется как половина расстояния между его верхней и
нижней границами. Радиус является мерой неопределенности числа, которое обозначает
интервал. Есть такие математические операции, для которых радиус результата зависит
только от радиусов интервалов-аргументов, а есть такие, для которых радиус результата
не является функцией радиусов аргументов.
Покажите, что радиус суммы (или разности) двух интервалов зависит только от
радиусов интервалов, которые складываются (или вычитаются). Приведите примеры, которые
показывают, что для умножения или деления это не так.

Предположим есть интервал (2 . 8) Его радиус будет равен 3, посольку это половина
расстояния от 2 до 8.

#+BEGIN_SRC scheme
  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))

  (define A (cons 2.0 5.0))
  (define B (cons 4.0 8.0))

  ;; радиусы равны
  (width (add-interval A B))
  (+ (width A) (width B))

  ;; радиусы не равны
  (width (mul-interval A B))
  (* (width A) (width B))

#+END_SRC

~Упражнение 2.10.~
Бен Битобор, системный программист-эксперт, смотрит через плечо Лизы и замечает:
неясно, что должно означать деление на интервал, пересекающий ноль.
Модифицируйте код Лизы так, чтобы программа проверяла это условие и сообщала об ошибке,
если оно возникает.

#+BEGIN_SRC scheme

(define (my-div-interval x y)
    (if (or (<= (lower-bound x) 0) (<= (lower-bound y) 0)
            (<= (upper-bound y) 0)  (<= (upper-bound x) 0))
        (display "error!\n")
        (let ((p1 (/ (lower-bound x) (lower-bound y)))
              (p2 (/ (lower-bound x) (upper-bound y)))
              (p3 (/ (upper-bound x) (upper-bound y)))
              (p4 (/ (upper-bound x) (lower-bound y))))
          (make-interval (min p1 p2 p3 p4)
                         (max p1 p2 p3 p4)))))

#+END_SRC

~Доделать! Упражнение 2.11~
Проходя мимо, Бен делает туманное замечание: «Если проверять знаки концов интервалов,
можно разбить mul-interval на девять случаев, из которых только в одном требуется
более двух умножений». Перепишите эту процедуру в соответствии с предложением Бена.

- проверить знаки на концах интервалов
- реализовать конд, в котором будет 9 случаев
- 9ый - else, в котором будет более 2х умножений

#+BEGIN_SRC scheme
  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (upper-bound y)))
          (p4 (* (upper-bound x) (lower-bound y))))
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))


  (define A (cons 2.0 5.0))
  (define B (cons 4.0 8.0))

  (define (mul-interval x y)
    (let ((p1 (* (lower-bound x) (lower-bound y)))
          (p2 (* (lower-bound x) (upper-bound y)))
          (p3 (* (upper-bound x) (upper-bound y)))
          (p4 (* (upper-bound x) (lower-bound y))))
      (format #t "p1 ~A p2 ~A p3 ~A p4 ~A\n" p1 p2 p3 p4)
      (make-interval (min p1 p2 p3 p4)
                     (max p1 p2 p3 p4))))

  (define (my-mul-interval x y)
    (cond ((and (< (lower-bound x) 0) (> (upper-bound y) 0) (> (upper-bound x) 0))
           (make-interval (* (lower-bound x) (upper-bound y)) (* (upper-bound y)
                                                                 (upper-bound x))))
          ((and (< (lower-bound y) 0) (> (upper-bound x) 0) (> (upper-bound y) 0))
           (make-interval (* (lower-bound y) (upper-bound x)) (* (upper-bound y)
                                                                 (upper-bound x))))
          ((and (> (lower-bound x) 0) (< (upper-bound y) 0) (> (upper-bound x) 0)
                (> (lower-bound y) 0))
                (make-interval (* (lower-bound x) (upper-bound y)) (* (lower-bound y)
                                                                      (upper-bound x))))
          ((and (> (lower-bound x) 0) (< (upper-bound y) 0) (> (upper-bound x) 0)
                (> (lower-bound y) 0))
           (make-interval (* (lower-bound x) (upper-bound y)) (* (lower-bound y)
                                                                 (upper-bound x))))


#+END_SRC

~Упражнение 2.12~
Определите конструктор make-center-percent, который принимает среднее значение и по-
грешность в процентах и выдает требуемый интервал. Нужно также определить селектор
percent, который для данного интервала выдает погрешность в процентах.
Селектор center остается тем же, что приведен выше.

#+BEGIN_SRC scheme
  (define (make-center-width c w)
    (make-interval (- c w) (+ c w)))

  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))

  (define (width i)
    (/ (- (upper-bound i) (lower-bound i)) 2))

  (define (percent i)
    (let* ((c (center i))
           (inaccuracy (- (upper-bound i) c)))
           (* (/ inaccuracy c) 100)))

  (define (make-center-percent c p)
    (let ((inaccuracy (* (/ c 100) p)))
      (make-interval (- c inaccuracy) (+ c inaccuracy))))

#+END_SRC

~Упражнение 2.13~
Покажите, что, если предположить, что погрешность составляет малую долю величины
интервала, то погрешность в процентах произведения двух интервалов можно получить
из погрешности в процентах исходных интервалов по простой приближенной формуле.
Задачу можно упростить, если предположить, что все числа положительные.

- берем интервалы с небольшой погрешностью
- умножаем интервалы друг на друга
- получаем погрешность в процентах
- считаем погрешность в процентах у одного исходного интервала и у другого
- доказать, что погрешность у интервала-произведения можно получить из
  интервалов-исходников по приближенной формуле (какой?)

#+BEGIN_SRC scheme
  (define A (make-center-percent 40.0 3.0))
  (define B (make-center-percent 30.0 3.0))

  ;; процент погрешности при произведении 2х исходных интервалов примерно = проценту
  ;; погрешности при складывании погрешностей и исходных интервалов
  ;; (если изначальная погрешность не более 10%)
  (percent (mul-interval A B))
  (+ (percent A) (percent B))

#+END_SRC

~Упражнение 2.14~
Покажите, что Дайко прав. Исследуйте поведение системы на различных арифметических
выражениях. Создайте несколько интервалов A и B и вычислите с их помощью выражения A/A
и A/B. Наибольшую пользу Вы получите, если будете использовать интервалы, радиус которых
составляет малую часть от среднего значения.
Исследуйте результаты вычислений в форме центр/проценты.
(См. упр 2.12)

То есть надо найти интервалы с небольшим разбросом и работать с ними.

#+BEGIN_SRC scheme

  (define (par1 r1 r2)
    (div-interval (mul-interval r1 r2)
                  (add-interval r1 r2)))

  (define (par2 r1 r2)
    (let ((one (make-interval 1 1)))
      (div-interval one
                    (add-interval (div-interval one r1)
                                  (div-interval one r2)))))

  ;; Проверка:
  (define A (cons 2 5))
  (define B (cons 4 8))

  (percent (par2 A A))
  = 42.857142857142854

  (percent (par2 A B))
  = 39.53488372093024

  (percent (par1 A B))
  = 83.09859154929579

  (percent (par1 A A))
  = 87.96992481203006

  (center (par1 A A))
  = 3.325

  (center (par2 A A))
  = 1.75

  (center (par2 A B))
  = 2.205128205128205

  (center (par1 A B))
  = 3.6410256410256405
#+END_SRC

~Упражнение 2.15~
Ева Лу Атор, другой пользователь Лизиной программы, тоже заметила, что алгебраически
эквивалентные, но различные выражения могут давать разные результаты. Она говорит, что
формула для вычисления интервалов, которая использует Лизину систему, будет
давать более узкие границы погрешности, если ее удастся записать так, чтобы ни одна
переменная, представляющая неточную величину, не повторялась. Таким образом, говорит
она, par2 «лучше» как программа для параллельных резисторов, чем par1.
Права ли она? Почему?

Ответ: логично предположить, что чем больше неточных данных мы используем, тем больше
общая неточность результата. Поскольку par2 использует только 2 неточные величины
вместо четырех, мы можем сказать, что par2 лучше.

~Упражнение 2.16~
Объясните в общем случае, почему эквивалентные алгебраические выражения могут давать
разные результаты. Можете ли Вы представить себе пакет для работы с интервальной
арифметикой, который бы не обладал этим недостатком, или такое невозможно?
(Предупреждение: эта задача очень сложна.)

Ответ: например, дело может быть в особенностях хранения цифр с плавающей
запятой. Из-за, казалось бы, эквивалентных алгебраических действий, неточность может
накапливаться и приводить к разным результатам.

Решение подобной проблемы - это задать меру точности, т.е. сколько знаком после запятой
мы будем оставлять на каждом этапе вычисления.

~Упражнение 2.17.~
Определите процедуру last-pair, которая возвращает список, содержащий только последний
элемент данного (непустого) списка.
(last-pair (list 23 72 149 34))
= (34)

#+BEGIN_SRC scheme
  (define (last-pair lst)
    (list-ref lst (- (length lst) 1)))
#+END_SRC

~Упражнение 2.18~
Определите процедуру reverse, которая принимает список как аргумент и возвращает
список, состоящий из тех же элементов в обратном порядке:
(reverse (list 1 4 9 16 25))
(25 16 9 4 1)

#+BEGIN_SRC scheme
  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))
#+END_SRC

~Упражнение 2.19.~
Рассмотрим программу подсчета способов размена из раздела 1.2.2. Было бы приятно иметь
возможность легко изменять валюту, которую эта программа использует, так, чтобы можно
было, например, вычислить, сколькими способами можно разменять британский фунт.
Эта программа написана так, что знание о валюте распределено между процедурами
first-denomination и count-change (которая знает, что существует пять видов
американских монет). Приятнее было бы иметь возможность просто задавать список монет,
которые можно использовать при размене.
Мы хотим переписать процедуру cc так, чтобы ее вторым аргументом был список монет, а не
целое число, которое указывает, какие монеты использовать. Тогда у нас могли бы быть
списки, определяющие типы валют:
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
Можно было бы вызывать cc следующим образом:
(cc 100 us-coins)
= 292
Определите процедуры first-denomination, except-first-denomination и no-more? в
терминах элементарных операций над списковыми структурами. Влияет ли порядок списка
coin-values на результат, получаемый cc? Почему?
#+BEGIN_SRC scheme
  (define (no-more? coin-values)
    (if (null? coin-values)
        #t
        #f))

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))

  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else
           (+ (cc amount
                  (except-first-denomination coin-values))
              (cc (- amount
                     (first-denomination coin-values))
                  coin-values)))))

  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))

  (cc 100 us-coins)
#+END_SRC

Ответ: порядок в списке coin-values не влияет на результат, потому что важен не порядок
элементов, а их общее количество. Например, если в список добавить еще один элемент,
то количество вариантов размена изменится.

~Упражнение 2.20~
Используя точечную нотацию, напишите процедуру same-parity, которая принимает одно или
более целое число и возвращает список всех тех аргументов, у которых четность та же,
что у первого аргумента. Например,
(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)
(same-parity 2 3 4 5 6 7)
(2 4 6)

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (same-parity n . nums)
    (let ((lst (list n)))
      (define (iter nums new-lst)
        (cond ((null? nums) (reverse new-lst))
              ((and (even? (car nums)) (even? (car new-lst)))
               (iter (cdr nums) (cons (car nums) new-lst)))
              ((and (not (even? (car nums))) (not (even? (car new-lst))))
               (iter (cdr nums) (cons (car nums) new-lst)))
              (else (iter (cdr nums) new-lst))))
      (iter nums lst)))
#+END_SRC

~Упражнение 2.21~
Процедура square-list принимает в качестве аргумента список чисел и возвращает список
квадратов этих чисел.
(square-list (list 1 2 3 4))
(1 4 9 16)
Перед Вами два различных определения square-list. Закончите их, вставив пропущенные вы-
ражения:

#+BEGIN_SRC scheme
  ;; первый вариант решения без map
  (define (square-list items)
    (define (iter items lst)
      (if (null? items)
          (reverse lst)
          (iter (cdr items) (cons (* (car items) (car items)) lst))))
    (iter items (list)))

  ;; правильный вариант
  (define (square-list items)
    (if (null? items)
        #nil
        (cons (* (car items) (car items))
              (square-list (cdr items)))))

  (define (square-list items)
    (map (lambda (x)  (* x x))
         items))
#+END_SRC

~Упражнение 2.22~
Хьюго Дум пытается переписать первую из процедур square-list из упражнения 2.21 так,
чтобы она работала как итеративный процесс. К сожалению, такое определение square-list
выдает список результатов в порядке, обратном желаемому. Почему?
Затем Хьюго пытается исправить ошибку, обменяв аргументы cons, но этот вариант так же
не срабатывает, объясните, почему.

В первом случае список выходит перевернутым, поскольку элемент, который мы добавляем к
списку с помощью cons, добавляется в начало списка. Если же попытаться поменять
аргументы cons местами, то мы попытаемся приклеить элементк концу списка. Только конец
списка - это не его последний элемент, а nil. В результате мы получаем пару, а не
склеенный список.


~Упражнение 2.23.~
Процедура for-each похожа на map. В качестве аргументов она принимает процедуру и спи-
сок элементов. Однако вместо того, чтобы формировать список результатов, for-each
просто применяет процедуру по очереди ко всем элементам слева направо.
Результаты применения процедуры к аргументам не используются вообще — for-each
применяют к процедурам, которые осуществляют какое-либо действие вроде печати.
Например,
(for-each (lambda (x) (newline) (display x))
(list 57 321 88))
57
321
88
Значение, возвращаемое вызовом for-each (оно в листинге не показано) может быть каким
угодно, например истина. Напишите реализацию for-each.

#+BEGIN_SRC scheme
  (define (for-each fn lst)
    (if (null? lst)
        #nil
        (and (fn (car lst)) (for-each fn (cdr lst)))))
#+END_SRC

~Упражнение 2.24~
Предположим, мы вычисляем выражение (list 1 (list 2 (list 3 4))). Укажите, какой
результат напечатает интерпретатор, изобразите его в виде стрелочной диаграммы, а также
его интерпретацию в виде дерева (как на рисунке 2.6)

#+BEGIN_SRC scheme
  (list 1 (list 2 (list 3 4)))

  = (1 (2 (3 4)))
#+END_SRC

~Упражнение 2.25~
Укажите комбинации car и cdr, которые извлекают 7 из следующих списков:

#+BEGIN_SRC scheme
  ;; (1 3 (5 7) 9)

  (car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9))))))

  ;; ((7))

  (car (car (list (list 7))))

  ;; (1 (2 (3 (4 (5 (6 7))))))

  (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))))
#+END_SRC

~Упражнение 2.26~.
Допустим, мы определили x и y как два списка.
Какой результат напечатает интерпретатор в ответ на следующие выражения:
#+BEGIN_SRC scheme
  (define x (list 1 2 3))
  (define y (list 4 5 6))

  (append x y)
  = (1 2 3 4 5 6)

  (cons x y)
  = ((1 2 3) 4 5 6)

  (list x y)
  = ((1 2 3) (4 5 6))
#+END_SRC

~Упражнение 2.27.~
Измените свою процедуру reverse из упражнения 2.18 так, чтобы получилась процедура
deep-reverse, которая принимает список в качестве аргумента и возвращает в качестве
значения список, где порядок элементов обратный и подсписки также обращены.

#+BEGIN_SRC scheme
  ;; например:

  (define x (list (list 1 2) (list 3 4)))

  x
  = ((1 2) (3 4))

  (reverse x)
  = ((3 4) (1 2))

  (deep-reverse x)
  = ((4 3) (2 1))

  ;; решение:

  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))

  (define (deep-reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (reverse (car lst)) new-lst))))
    (iter lst (list)))
#+END_SRC

~Упражнение 2.28.~
Напишите процедуру fringe, которая берет в качестве аргумента дерево (представленное в
виде списка) и возвращает список, элементы которого — все листья дерева, упорядоченные
слева направо.

#+BEGIN_SRC scheme
  ;; Например

  (define x (list (list 1 2) (list 3 4)))

  (fringe x)
  = (1 2 3 4)

  (fringe (list x x))
  = (1 2 3 4 1 2 3 4)

  ;; решение
  (define (fringe lst)
    (if (pair? lst)
        (append (fringe (car lst)) (fringe (cdr lst)))
        (if (null? lst)
            #nil
            (list lst))))
#+END_SRC

~Упражнение 2.29~
Бинарный мобиль состоит из двух ветвей, левой и правой. Каждая ветвь представляет собой
стержень определенной длины, с которого свисает либо гирька, либо еще один бинарный
мобиль.
Мы можем представить бинарный мобиль в виде составных данных, соединив две ветви
(например, с помощью ~list~):

#+BEGIN_SRC scheme
(define (make-mobile left right)
(list left right))
#+END_SRC

Ветвь составляется из длины ~length~ (которая должна быть числом) и структуры
~structure~, которая может быть либо числом (представляющим простую гирьку),
либо еще одним мобилем

#+BEGIN_SRC scheme
(define (make-branch length structure)
(list length structure))
#+END_SRC

а. Напишите соответствующие селекторы ~left-branch~ и ~right-branch~, которые возвраща-
ют левую и правую ветви мобиля, а также ~branch-length~ и ~branch-structure~, которые
возвращают компоненты ветви.
б. С помощью этих селекторов напишите процедуру ~total-weight~, которая возвращает общий
вес мобиля.
в. Говорят, что мобиль сбалансирован, если момент вращения, действующий на его левую
ветвь, равен моменту вращения, действующему на правую ветвь (то есть длина левого
стержня, умноженная на вес груза, свисающего с него, равна соответствующему
произведению для правой стороны), и если все подмобили, свисающие с его ветвей,
также сбалансированы. Напишите предикат, который проверяет мобили на
сбалансированность.

Будем считать мобиль своеобразным неупорядоченным бинарным деревом.
Исходя из идеи, что соединение 2х веток с помощью list дает мобиль, скажем, что
левая ветка - это car, а правая - cdr списка.
Аналогично с компонентами ветви. Каждый узел ветви - эт длина + структура. Значит,
длина ветви (узла?) - это car текущего подсписка, а структура - cadr. Использование
cadr позволяет убрать один уровень вложенности.


~total-weight~ должна вернуть общий вес мобиля, т.е. пройтись по каждой структуре,
дойти до "гирек" и суммировать значения.


#+BEGIN_SRC scheme
  (define test-mobile
    (make-mobile (make-branch 10 (make-branch 10 (make-branch 10 13)))
                 (make-branch 10 (make-branch 10 (make-branch 10 18)))))

  (define test2-mobile
    (make-mobile (make-branch 10 (make-branch 10 (make-branch 10 (make-branch 10 20))))
                 (make-branch 10 (make-branch 10 (make-branch 10 18)))))

  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (cadr mobile))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (cadr branch))

  (define (total-weight mobile)
    (define (iter mobile)
      (cond ((and (pair? mobile)
                  (pair? (left-branch mobile))
                  (pair? (right-branch mobile)))
             (+ (iter (right-branch mobile))
                (iter (left-branch mobile))))
            ((and (pair? mobile) (pair? (right-branch mobile)))
                  (iter (right-branch mobile)))
            ((and (pair? mobile) (pair? (left-branch mobile)))
                  (iter (left-branch mobile)))
            (else (right-branch mobile))))
    (iter mobile))

  (define (balanced? mobile)
    (cond ((and (pair? mobile)
                (pair? (left-branch mobile))
                (pair? (right-branch mobile)))
           ( = (balanced? (right-branch mobile))
               (balanced? (left-branch mobile))))
          ((and (pair? mobile) (pair? (right-branch mobile)))
           (balanced? (right-branch mobile)))
          ((and (pair? mobile) (pair? (left-branch mobile)))
           (balanced? (left-branch mobile)))
          (else (*  (branch-length mobile) (branch-structure mobile)))))

#+END_SRC

г. Допустим, мы изменили представление мобилей, так что конструкторы теперь приняли
такой вид:

#+BEGIN_SRC scheme
(define (make-mobile left right)
(cons left right))

(define (make-branch length structure)
(cons length structure))
#+END_SRC

Как много пришлось поменять в остальной программе?
Ответ: пришлось поменять только селекторы.
#+BEGIN_SRC scheme
  (define (left-branch mobile)
    (car mobile))

  (define (right-branch mobile)
    (cdr mobile))

  (define (branch-length branch)
    (car branch))

  (define (branch-structure branch)
    (cdr branch))

#+END_SRC

~Упражнение 2.30~
Определите процедуру square-tree, подобную процедуре square-list из упражнения 2.21. А
именно, square-tree должна вести себя следующим образом:

#+BEGIN_SRC scheme
  (square-tree
   (list 1
         (list 2 (list 3 4) 5)
         (list 6 7)))
  = (1 (4 (9 16) 25) (36 49))

  (define (square-tree tree)
    (define (square x)
      (* x x))
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (square-tree sub-tree)
               (square sub-tree)))
         tree))

  (define (square-tree tree)
    (define (square x)
      (* x x))
    (cond ((null? tree) #nil)
          ((not (pair? tree)) (square tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))
#+END_SRC

~Упражнение 2.31~
Абстрагируйте свой ответ на упражнение 2.30, получая процедуру tree-map, так, чтобы
square-tree можно было определить следующим образом:
(define (square-tree tree) (tree-map square tree))

#+BEGIN_SRC scheme
  (define (square-tree tree)
    (define (square x)
      (* x x))
    (tree-map square tree))

  (define (tree-map fn tree)
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (tree-map fn sub-tree)
               (fn sub-tree)))
         tree))

#+END_SRC

~Упражнение 2.32.~
Множество можно представить как список его различных элементов, а множество его
подмножеств как список списков. Например, если множество равно (1 2 3), то множество его
подмножеств равно (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)).
Закончите следующее определение процедуры, которая порождает множество подмножеств
и дайте ясное объяснение, почему она работает:

#+BEGIN_SRC scheme
  (define (subsets s sp)
    (if (null? s)
        (list #nil)
        (let ((rest (subsets (cdr s) (+ 1 sp))))
          (space sp)
          (format #t "~A\n" rest)
          (space sp)
          (format #t "~A\n" s)
          (append rest (map (lambda (x)
                              (if (pair? s)
                                  (and (cons (cdr s) x) (cons (car s) x))
                                  (cons s x))) rest)))))
#+END_SRC

Сначала я предположила, что элементы, которые содержатся в ~rest~ нужно просто обернуть
в список. Но в ~rest~ перманентно содержится nil. Тогда я поняла, что элементы содержит
что-то еще. В нашем случае это ~s~, я подумала, что следует соединить элементы из  ~s~
и ~rest~ с помощью cons, результат был уже ближе, но все еще не тот.
Тогда я поняла, что в конечном результате есть закономерность: элементы из ~rest~
последовательно соединяется с ~car~ и ~cdr~ возвращенной последовательности, если это
последовательность. Так удалось написать верную лямбду.

О работе процедуры:
Чтобы образовать множество, нам нужно откатиться к концу исходной последовательности,
а затем начать последовательно комбинировать элементы друг с другом. Для этого мы
сначала рекурсивно вызваем ~subsets~ с cdr последовательности, таким образом мы доходим
до конца списка. Достигнув его, возвращаем nil, который попадает в ~rest~ как
возвращаемое значение рекурсии, и начинаем откатываться назад по стеку вызовов. Прежде
чем вызвать любую функцию, программе нужно запомнить состояние параметров, чтоб
вернуться к исходному состоянию стека, которое было до вызова функции, и корректно
продолжить работу. Соответственно, состояние ~s~, которая хранит в себе
последовательность, тоже сохраняется на стеке перед каждым рекурсивным вызовом. А при
откате назад значения восстанавливаются. Так в ~s~ постепенно попадает исходная
последовательность и и это позволяет написанной мною лямбде работать.


~Упражнение 2.33.~
Заполните пропущенные выражения, так, чтобы получились определения некоторых базовых
операций по работе со списками в виде накопления:

#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))


  (define (my-map p sequence)
    (accumulate (lambda (x y)
                  (cons (p x) y)) (list) sequence))

  (my-map (lambda (x) (*  x x)) (list 1 2 3 4))

  ;; вторая последовательность является базовым значением для
  ;; нового append, поскольку если первая последовательность окажется пустой
  ;; реальный append вернет вторую
  (define (my-append seq1 seq2)
    (accumulate cons seq2 seq1))

  (my-append (list 1 2 3 4) (list 4 5 6 7))

  ;; достигнув конца списка мы возвращаем 0, который при откате назад по стеку
  ;; вызовов будет восприниматься как возвращаемое значение вызова и займет место параметра Y
  (define (my-length sequence)
    (accumulate (lambda (x y)
                 (+ y 1)) 0 sequence))

  (my-length (list 1 2 3 4))
#+END_SRC

~Упражнение 2.34.~
Вычисление многочлена с переменной x при данном значении x можно сформулировать в виде
накопления. Мы вычисляем многочлен
AnX^n + An−1X^n−1 + . . . + A1x + A0
по известному алгоритму, называемому схема Горнера (Horner’s rule).

(. . . (AnX + An−1 )X + . . . + A1 )X + A0 )

Другими словами, мы начинаем с An , умножаем его на x, и так далее, пока не достигнем
A0.
Заполните пропуски в следующей заготовке так, чтобы получить процедуру, которая
вычисляет многочлены по схеме Горнера. Предполагается, что коэффициенты многочлена
представлены в виде последовательности, от A0 до An .

#+BEGIN_SRC scheme

  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms)
                  (+ this-coeff (* x higher-terms)))
                0
                coefficient-sequence))

  ;; Например, чтобы вычислить 1 + 3x + 5x^3 + x^5 в точке x = 2, нужно ввести
  ;; возможно, нули стоят потому, что нет икса в первой степени...
  (horner-eval 2 (list 1 3 0 5 0 1))
#+END_SRC

~Упражнение 2.35~
Переопределите count-leaves из раздела 2.2.2 в виде накопления.

Видимо, map должна собрать все листья (т.е. все непары)  и вернуть последовательность,
состоющую из листьев, после чего мы посчитаем их количество. Идея оказалась неверной.
Во-первых, map не может работать с деревьями, нужно было рекурсивно обойти дерево на
каждой итерации прохода по дереву. Но даже после того, как это удалось реализовать,
список результатов, возвращенный map, содержал вложенные списки. С которыми не может
работать и accumulate, поэтому пришлось рекурсивно обходить список и при подсчете
листов. В общем, громоздко, не понятно, не работало.

Нужно было разделить дерево на подпоследовательности и возвращать не список листьев,
а список единиц, где единица - это каждый найденный лист. Т.к. map проходит по
подпоследовательности и, встретив лист, записывает в список результатов 1. А затем все
значения в списке суммируются.


#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (format #t "~A\n" sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  ;; исходный вариант
  (define (count-leaves x)
    (cond ((null? x) 0)
          ((not (pair? x)) 1)
          (else (+ (count-leaves (car x))
                   (count-leaves (cdr x))))))
  ;; новый вариант
  (define (count-leaves tree)
    (accumulate + 0 (map (lambda (x)
                           (if (pair? x)
                               (count-leaves x)
                               1))
                         tree)))

#+END_SRC


~Упражнение 2.36.~
Процедура ~accumulate-n~ подобна ~accumulate~, только свой третий аргумент она
воспринимает как последовательность последовательностей, причем предполагается,
что все они содержат одинаковое количество элементов. Она применяет указанную процедуру
накопления ко всем первым элементам последовательностей, вторым элементам
последовательностей и так далее, и возвращает последовательность результатов.
Например, если ~s~ есть последовательность, состоящая из четырех последовательностей,
((1 2 3) (4 5 6) (7 8 9) (10 11 12)), то значением (accumulate-n + 0 s)
будет последовательность (22 26 30).
Заполните пробелы в следующем определении accumulate-n.

Ясно, что в ~accumulate-n~ третьим аргументом всегда должна быть последовательность
последовательностей. Cитуация, когда car последовательности оказался
пустым списком, возможно только если список стал похож на (()).

Это значит, что нужно постепенно вытаскивать из каждого подсписка по элементу,
пока они не станут пустыми.

Вариант написать 2 процедуры: одна выстаскивает каждый раз из всех подсписков списка,
другая делает то же, но с cdr. Так пришла идея использовать ~map~

#+BEGIN_SRC scheme
  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        #nil
        (cons (accumulate op init (map (lambda (x)
                                         (car x)) seqs))
              (accumulate-n op init (map (lambda (x)
                                           (cdr x)) seqs)))))

  (define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))

  (accumulate-n + 0 s)
#+END_SRC

~Упражнение 2.37.~
Заполните пропуски в следующих процедурах для вычисления остальных матричных операций.

#+BEGIN_SRC scheme
  (define mat (list (list 1 2 3) (list 4 5 6)))
  (define vec (list 10 11 12))
  (define mat2 (list (list 1 2 3) (list 4 5 6) (list 7 8 9)))

  ;; скалярное произведение
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))

  ;; произведение матрицы и вектора
  ;; чтоб умножить матрицу на ветор, нужно умножить первый компонент вектора
  ;; на все первые элементы строк матрицы, потом так же второй и т.д., а потом сложить
  ;; значения в каждой строке матрицы. Так получится новый вектор.
  (define (matrix-*-vector m v)
    (map (lambda (x)
           (dot-product v x)) m))

  ;; транспозиция матрицы
  ;; для получения транспонированной матрицы из исходной нужно каждую строчку исходной
  ;; матрицы записать в виде столбца в том же порядке
  (define (transpose mat)
    (accumulate-n (lambda (x y)
                    (cons x y)) #nil mat))

  ;; произведение матриц
  ;; кол-во строк в матрице А должно совпадать с кол-вом столбцов в матрице В
  (define mat-A (list (list 1 2 2) (list 3 1 1)))
  (define mat-B (list (list 4 2) (list 3 1) (list 1 5)))

  ;; сначала я думала, что надо задать 2 идентичные по размеру матрицы, но потом поняла, что
  ;; следует задавать матрицы так, как мы бы делали от руки, т.к. по правилу, описанному выше
  ;; А транспозиция превратит вторую матрицу в идентичную первой по размеру. И таким образом
  ;; мы сможем представить матрицы как набор векторов.
  ;; А раз это набор векторов, то можно использовать скалярное произведение. Все завернуто в
  ;; в list, чтоб можно было использовать append, тогда все красиво выводится.
  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (x)
             (append (list (dot-product (car cols) x)) (list (dot-product (cadr cols) x))))
           m)))
#+END_SRC

~Упражнение 2.38.~
Процедура accumulate известна также как fold-right (правая свертка), поскольку она
комбинирует первый элемент последовательности с результатом комбинирования
всех элементов справа от него.
Существует также процедура fold-left (левая свертка), которая подобна
fold-right, но комбинирует элементы в противоположном направлении.
Каковы значения следующих выражений?

Укажите свойство, которому должна удовлетворять op, чтобы для любой последовательности
fold-right и fold-left давали одинаковые результаты.

Ответ: op должно быть коммутативно, т.е. чтоб порядок аргументов для предиката не имел
значения

#+BEGIN_SRC scheme
    (define (fold-left op initial sequence)
      (define (iter result rest)
        (if (null? rest)
            result
            (iter (op result (car rest))
                  (cdr rest))))
      (iter initial sequence))

    ;; раз fold-right подобна accumulate, то и выражения я проверяла с помощью accumulate
    (fold-right / 1 (list 1 2 3))
    = 3/2

    (fold-left / 1 (list 1 2 3))
    = 1/6

    (fold-right list #nil (list 1 2 3))
    = (1 (2 (3 #nil)))

    (fold-left list #nil (list 1 2 3))
    = (((#nil 1) 2) 3)


  ;; Пример для ответа:
  (accumulate * 1 (list 1 2 3))
  (fold-left * 1 (list 1 2 3))
#+END_SRC

~Упражнение 2.39~
Закончите следующие определения reverse (упражнение 2.18) в терминах процедур fold-
right и fold-left из упражнения 2.38.

#+BEGIN_SRC scheme
  (define (reverse lst)
    (define (iter lst new-lst)
      (if (null? lst)
          new-lst
          (iter (cdr lst) (cons (car lst) new-lst))))
    (iter lst (list)))

  (define (reverse-right sequence)
    (accumulate (lambda (x y) (append y (list x))) #nil sequence))

  (define (reverse-left sequence)
    (fold-left (lambda (x y) (cons y x)) #nil sequence))
#+END_SRC

~Упражнение 2.40.~
Определите процедуру unique-pairs, которая, получая целое число n, порождает последова-
тельность пар (i, j), таких, что 1 ≤ j < i ≤ n. С помощью unique-pairs упростите данное
выше определение prime-sum-pairs.

i = n - 1 или n
j = диапазон от 1<=j до i - 1
нужно породить пары i и j. 2 вложенных чикла, которые будут выполняться, пока i не
достигнет значение n и n-1

для каждого целого i ≤ n перечислить целые числа j < i, и для каждых таких i и j
породить пару (i, j)

Фактически меня просят разбить процедуру на подпроцедуры, чтоб ее стало проще
воспринимать.

У автора процедура ~enumerate-interval~ встроена в стандарт его схемы, мне же ее
пришлось написать.

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))

  ;; отсюда начинается определение процедуры мана. Все функции до этого места вспомогательны,
  ;; рассчитано, что они уже залиты в интерпритатор, поэтому они просто используются по ходу
  ;; книги

  (define (prime-sum? pair)
    (prime? (+ (car pair) (cadr pair))))

  (define (flatmap proc seq)
    (accumulate append #nil (map proc seq)))

  (define (make-pair-sum pair)
    (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

  (define (enumerate-interval start end)
    (if (< start end)
        (cons start (enumerate-interval (+ 1 start) end))
        (list end)))

  ;; исходный вариант
  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum?
                 (flatmap
                  ;; сюда попадает последовательность
                  (lambda (i)
                    ;; для каждого i получаем пару (i j), где j всегда меньше i
                    (map (lambda (j) (list i j))
                         (enumerate-interval 1 (- i 1))))
                  ;; порождаем последовательность от 1 до n
                  (enumerate-interval 1 n)))))


  (define (unique-pairs n)
    (flatmap
     ;; сюда попадает последовательность
     (lambda (i)
       ;; для каждого i получаем пару (i j), где j всегда меньше i
       (map (lambda (j) (list i j))
            (enumerate-interval 1 (- i 1))))
     ;; порождаем последовательность от 1 до n
     (enumerate-interval 1 n)))

  ;; мой вариант
  (define (prime-sum-pairs n)
    (map make-pair-sum
         (filter prime-sum?
                 (unique-pairs n))))
#+END_SRC

~Упражнение 2.41.~
Напишите процедуру, которая находит все такие упорядоченные тройки различных
положительных целых чисел i, j и k, меньших или равных данному целому числу n,
сумма которых равна данному числу s.

i, j ,k <= n
найти такие i j k, которые при сложении дадут s. собрать их в последоватлеьность
значит, надо сгенерировать 3 последовтаельности, где числа <=n.
затем попробовать сложить
Пусть последовательности разворачиваются в разных порядках: две от n до 1,
а одна от 1 до n

#+BEGIN_SRC scheme
  (define (new-enumerate-interval end start)
    (if (> end start)
        (cons end (new-enumerate-interval (- end 1) start))
        (list start)))

  (define (flatmap proc seq)
    (accumulate append #nil (map proc seq)))

  ;; вариант с грязным хаком
  ;; как состоит в использовании cond. но так есть возможность предусмотреть все варианты
  (define (find-sum s n)
    (define (sum? seq)
      (format #t "i ~A j ~A k ~A\n" (car seq) (cadr seq) (cadr (cdr seq)))
      (= s (+ (car seq) (cadr seq) (cadr (cdr seq)))))
    (filter sum?
            (flatmap
             (lambda (i)
               (map (lambda (j k)
                      (cond ((sum? (list (+ i) j k)) (list (+ i) j k))
                            ((sum? (list i (+ 1 j) k)) (list i (+ j) k))
                            ((sum? (list i (- j 1) k)) (list i (- j 1) k))
                            ((sum? (list (- i 1) j k)) (list (- i) j k))
                            (else (list i j k))))
                    (enumerate-interval 1 n) (new-enumerate-interval n 1)))
             (new-enumerate-interval n 1))))


  ;; подсмотренный вариант без грязного хака
  ;; но мне кажется, что мой более правильный в плане того, что у меня
  ;; i, j , k могут быть = n, а у этого решения j и k никогда не будут = n
  ;; к тому же, у него отсутствуют некоторые варианты слагаемых суммы
  ;; если, к примеру, вызвать (triples-with-sum 10 8), то будут отсутствовать варианты
  ;; (6 2 2), (8 1 1) и т.д. а у меня они есть ;)

  (define (unique-triples n)
    (flatmap (lambda (i)
               (flatmap (lambda (j)
                          (map (lambda (k) (list i j k))
                               (enumerate-interval 1 (- j 1))))
                        (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n)))

  (define (triples-with-sum s n)
  (filter (lambda (t) (= (accumulate + 0 t) s))
                    (unique-triples n)))
#+END_SRC


~Упражнение 2.42.~
В «задаче о восьми ферзях» спрашивается, как расставить на шахматной доске восемь
ферзей так, чтобы ни один из них не бил другого (то есть никакие два ферзя не должны
находиться на одной вертикали, горизонтали или диагонали).
Один из способов решать эту задачу состоит в том, чтобы идти поперек доски,
устанавливая по ферзю в каждой вертикали. После того, как k − 1 ферзя мы уже
разместили, нужно разместить k-го в таком месте, где он не бьет ни одного из тех,
которые уже находятся на доске. Этот подход можно сформулировать рекурсивно:
предположим, что мы уже породили последовательность из всех возможных способов
разместить k − 1 ферзей на первых k − 1 вертикалях доски. Для каждого из этих способов
мы порождаем расширенный набор позиций, добавляя ферзя на каждую горизонталь k-й
вертикали. Затем эти позиции нужно отфильтровать, оставляя только те, где
ферзь на k-й вертикали не бьется ни одним из остальных. Продолжая этот процесс, мы
породим не просто одно решение, а все решения этой задачи.

Это решение мы реализуем в процедуре ~queens~, которая возвращает последовательность ре-
шений задачи размещения n ферзей на доске n × n. В процедуре queens есть внутренняя
процедура ~queen-cols~, которая возвращает последовательность всех способов разместить
ферзей на первых k вертикалях доски.
В этой процедуре ~rest-of-queens~ есть способ размещения k − 1 ферзя на первых k − 1
вертикалях, а ~new-row~ — это горизонталь, на которую предлагается поместить ферзя с k-й
вертикали.
Завершите эту программу, реализовав представление множеств позиций ферзей на доске,
включая процедуру ~adjoin-position~, которая добавляет нового ферзя на определенных
горизонтали и вертикали к заданному множеству позиций, и empty-board, которая
представляет пустое множество позиций. Еще нужно написать процедуру safe?,
которая для множества позиций определяет, находится ли ферзь с k-й вертикали в
безопасности от остальных. (Заметим, что нам требуется
проверять только то, находится ли в безопасности новый ферзь — для остальных ферзей
безопасность друг от друга уже гарантирована.)

Бередом доску 8 на 8. Расставляем на ней 7 ферзей по вертикалям (пофиг, что сейчас они
все бьют друг друга). Теперь нужно придумать, как поставить восьмого ферзя так, чтоб
его не могли быть ни один из уже стоящих на доске.

Как это сделать? Нужна рекурсия.
- мы уже разместили всех ферзей по вертикалям всеми возможными способами
- для каждого из этих вариантов мы получаем набор вариантов, добавляя по ферзю на
  каждую горизонталь текущей вертикали.
- затем фильтруем позици, оставляя только те, где ферзь на конкретной вертикали не
  бьется никаким из остальных ферзей

Функция filter похожа на map, но: работает с последовательностями, которые состоят из
подпоследовательностей. Применяет к подспискам предикат, и если предикат дает t,
включает подсписок в список результатов

Написать safe, adjoin-position и empty-board
Сначала мы получаем пустые вертикали (видимо).



#+BEGIN_SRC scheme
  ;; возвращает последовательность, которая отображает все варианты постановки ферзей
  ;; принимает число клеток доски по вертикали или горизонтали
  ;; т.е. если ввести 8, то мы получим доску 8х8
  (define (queens board-size)
    ;; возвращает последовательность, которая отображает все варианты
    ;; расстановки ферзей по вертикали
    (define (queen-cols k)
      (if (= k 0)
          ;; empty-board должна представлять пустое множество позиций
          ;; видимо, должна эмулировать пустую доску
          (list empty-board)
          (filter
           ;; предикат фильтра
           (lambda (positions)
             (format #t "lambda k ~A positions ~A\n" k positions)
             (safe? k positions))
           ;; это должно вернуть некую последовательность из всех
           ;; вариантов расстановки ферзей
           (flatmap
            ;; rest-of-queens - это последовательность (?)
            ;; способов расставить k - 1 ферзей на k-1 вертикалях
            (lambda (rest-of-queens)
              ;; new-row - горизонталь, на которую нужно поставить ферзя
              ;; с конкретной вертикали
              (map (lambda (new-row)
                     ;; adjoin-position добавляет нового ферзя на определенную клетку
                     (adjoin-position new-row k rest-of-queens))
                   ;; это список горизонталей
            (queen-cols (- k 1))))))
                   (enumerate-interval 1 board-size)))
    ;; первый вызов функции
    (queen-cols board-size))

  (define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        ;; empty-board должна представлять пустое множество позиций
        ;; видимо, должна эмулировать пустую доску
        (list empty-board)
         (flatmap
          ;; rest-of-queens - это последовательность (?)
          ;; способов расставить k - 1 ферзей на k-1 вертикалях
          (lambda (rest-of-queens)
            ;; new-row - горизонталь, на которую нужно поставить ферзя
            ;; с конкретной вертикали
            (map (lambda (new-row)
                   ;; adjoin-position добавляет нового ферзя на определенную клетку
                   (adjoin-position new-row k rest-of-queens))
                 ;; это список горизонталей
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1)))))
  (queen-cols board-size))

  (define (even? n)
    (= (remainder n 2) 0))

  (filter (lambda (pair)
            (format #t "~A\n" pair)
            (even? (+ (car pair) (cadr pair))))
            (list (list 2 3) (list 3 3) (list 5 3)))

  ;; предположим так мы ставим ферзя на заданную позицию
  (define (adjoin-position new-row k rest-of-queens)
    (cons new-row rest-of-queens))

  ;; у нее нет никаких аргументов. с чем она может работать?
  ;; предположим, что пустое множество - это nil
  (define empty-board
    (list))

  ;; как проверить, стоит ли ферзь в безопасности?
  (define (safe? k positions)
    (format #t "lambda k ~A positions ~A\n" k positions)
    (not (or (= k (car positions)) (= k (cdr positions)))))

 #+END_SRC

~Упражнение 2.44.~
Определите процедуру up-split, которую использует corner-split. Она подобна right-
split, но только меняет местами роли below и beside.

beside - получает на вход 2 процедуры отрисовки и порождает отрисовку, которая
рисует в правой половине листа рисунок первой отрисовки, а в левой - второй

below - получает на вход 2 процедуры отрисовки и порождает отрисовку, которая
рисует в верхней половине листа рисунок первой отрисовки, а в нижней - второй

#+BEGIN_SRC scheme
  ;; позволяет дробить рисунок вправо, т.е. левую половину листа будет занимать сам паттерн,
  ;; следующее изображение паттерна будет занимать правую верхнюю четверть листа, потом
  ;; половину от нижней четверти и т.д. пока лист не кончится
  (define (right-split painter n)
    (if (= n 0)
        painter
        (let ((smaller (right-split painter (- n 1))))
          (beside painter (below smaller smaller)))))

  (define (up-split (painter n))
    (if (= n 0)
        painter
        (let ((smaller (up-split painter (- n 1))))
          (below painter (beside smaller smaller)))))

  ;; порождает сбалансированные узоры, позволяя наращивать их вверх
  (define (corner-split painter n)
    (if (= n 0)
        painter
        (let ((up (up-split painter (- n 1)))
              (right (right-split painter (- n 1))))
          (let ((top-left (beside up up))
                (bottom-right (below right right))
                (corner (corner-split painter (- n 1))))
            (beside (below painter top-left)
                    (below bottom-right corner))))))

#+END_SRC

~Упражнение 2.45.~
Right-split и up-split можно выразить как разновидности общей операции разделения.
Определите процедуру split с таким свойством, что вычисление

(define right-split (split beside below))
(define up-split (split below beside))

порождает процедуры right-split и up-split с таким же поведением, как и определенные
ранее.

сплит - общая операция разделения. нам явно нужна рисовлка, которую мы будем делить и
указание, как мы ее будем делить
получает 2 аргумента на вход
должен быть рекурсивный проход
при этом right-split и up-split перестали получать на вход аргументы.
аргументы beside и below - это 2 рисовлки у каждой
значит, split должна породить другую процедуру, которая принимает на вход
рисовалку-паттерн и кол-во раз, которое скажет нам, сколько раз разделить картинку,
а затем отрисует наш паттерн так, как мы укажем на входе split

#+BEGIN_SRC scheme

  (define (split painter1 painter2)
      (define (split-iter patern-paiter n)
        (if (= n 0)
            patern-paiter
            (let ((smaller (split patern-paiter (- n 1))))
              (painter1 patern-paiter (painter2 smaller smaller))
              )))
      split-iter)

#+END_SRC

~Упражнение 2.46.~

Двумерный вектор v, идущий от начала координат к точке, можно представить в виде пары,
состоящей из x-координаты и y-координаты. Реализуйте абстракцию данных для векторов,
написав конструктор ~make-vect~ и соответствующие селекторы ~xcor-vect~ и ~ycor-vect~.
В терминах своих селекторов и конструктора реализуйте процедуры ~add-vect~, ~sub-vect~
и ~scale-vect~, которые выполняют операции сложения, вычитания векторов и умножения
вектора на скаляр.

#+BEGIN_SRC scheme
  (define (make-vect x y)
    (cons x y))

  (define (xcor-vect v)
    (car v))

  (define (ycor-vect v)
    (cdr v))

  (define (add-vect v1 v2)
    (make-vect (+ (xcor-vect v1) (xcor-vect v2))
               (+ (ycor-vect v1) (ycor-vect v2))))

  (define (sub-vect v1 v2)
    (make-vect (- (xcor-vect v1) (xcor-vect v2))
               (- (ycor-vect v1) (ycor-vect v2))))

  (define (scale-vect v scale)
    (make-vect (* scale (xcor-vect v))
               (* scale (ycor-vect v))))

  (define v1 (make-vect 3 7))
  (define v2 (make-vect 2 4))

  (ycor-vect v1)
  (xcor-vect v2)
  (add-vect v1 v2)
  (sub-vect v1 v2)
  (scale-vect v1 3)
#+END_SRC

~Упражнение 2.47.~
Вот два варианта конструкторов для рамок.
К каждому из этих конструкторов добавьте соответствующие селекторы, так, чтобы получить
реализацию рамок.

цитата из мана:
каким образом представляются рамки; нужно только сказать, что
есть конструктор make-frame, который принимает три вектора и выдает рамку, и что
есть еще три селектора, ~origin-frame~, ~edge1-frame~ и ~edge2-frame~

видимо, нужно написать такие селекторы, чтоб можно было получить из списка, который
представляет собой рамку, origin, edge1 и edge2

#+BEGIN_SRC scheme
  ;; вариант 1
  (define (make-frame origin edge1 edge2)
    (list origin edge1 edge2))

  (define (origin-frame frame)
    (car frame))

  (define (edge1-frame frame)
    (cadr frame))

  (define (edge2-frame frame)
    (cdr (cdr frame)))

  (define frame1 (make-frame (make-vect 0 3) (make-vect 1 8) (make-vect 2 6)))
  (origin-frame frame1)
  (edge1-frame frame1)
  (edge2-frame frame1)

  ;; вариант 2
  (define (make-frame origin edge1 edge2)
    (cons origin (cons edge1 edge2)))

  ;; первые два селектора идентичны у первого и второго вариантов
  (define (edge2-frame frame)
    (cadr (cdr frame)))
#+END_SRC

~Упражнение 2.48.~
Направленный отрезок на плоскости можно представить в виде пары векторов: вектор от
начала координат до начала отрезка и вектор от начала координат до конца отрезка.
Используйте свое представление векторов из упражнения 2.46 и определите
представление отрезков с конструктором ~make-segment~ и селекторами ~start-segment~ и
~end-segment~.

#+BEGIN_SRC scheme
  (define (make-segment v1 v2)
    (make-vect v1 v2))

  (define (start-segment segment)
    (xcor-vect segment))

  (define (end-segment segment)
    (ycor-vect segment))

  (define segment (make-segment (make-vect 3 4) (make-vect 8 10)))

  (start-segment segment)
  (end-segment segment)
#+END_SRC

~Упражнение 2.49.~
С помощью segments->painter определите следующие элементарные рисовалки:

а. Рисовалку, которая обводит указанную рамку.
б. Рисовалку, которая рисует «Х», соединяя противоположные концы рамки.
в. Рисовалку, которая рисует ромб, соединяя между собой середины сторон рамки.
г. Рисовалку wave.

Рисовалка "х":
чтоб соединить противоположные концы рамки, нужно получить вектор, параллельный вектору
edge2, так мы получим третью сторону рамки, от которой можно провести линию по
диагонали
edge3 - назовем новую сторону так, от edge2 будет отличаться только координатой икс:
игреки у них будут одинаковые. Коодината иксбудет совпадать с edge1
после того, как мы получим третью сторону, останется соединить координату вектор
третьей стороны и ветор orgigin, образовав отрезок таким образом, а затем вектор edge2
и edge1. Так полчится нарисовать "x".

Рисовалка "ромб":
для рисовалки нам понадобятся все 4 строны рамки. найдем середину у каждой стороны,
затем создадим отрезки и передадим в процеудуру

Рисовалка wave.
Из решения последуюих упражнений стало ясно, что нужно передавать функции отрисовки
коркнетные координаты (от 0 до 1), а не переменные.
#+BEGIN_SRC scheme
  ;; frame-coord-map к рамке дает нам процедуру, которая,
  ;; получая вектор, возвращает тоже вектор. Если вектор-аргумент находится в единичном
  ;; квадрате, вектор-результат окажется в рамке.

  ;; чтоб получить рамку, надо иметь 3 ветора и единичный квадрат - это такой квадрат,
  ;; где сторона x >= 0, а y <=1. затем по вот такой формуле преобразуем это  рамку
  ;; Origin(Frame) + x · Edge 1 (Frame) + y · Edge 2 (Frame)

  ;; draw-line рисует отрезок между двумя точками. т.е. надо сформировать координаты
  ;; отрезка (два вектора) и передать ей

  ;; все процедуры для операций над векторами и сегментами следует искать в двух
  ;; предыдущих упражнениях
  (define (frame-coord-map frame)
    (lambda (v)
      (add-vect
       (origin-frame frame)
       (add-vect (scale-vect (xcor-vect v)
                             (edge1-frame frame))
                 (scale-vect (ycor-vect v)
                             (edge2-frame frame))))))

  (define (segments->painter segment-list)
    (lambda (frame)
      ;; применяем процедуру к каждому сегменту
      (for-each
       (lambda (segment)
         (draw-line
          ((frame-coord-map frame) (start-segment segment))
          ((frame-coord-map frame) (end-segment segment))))
       segment-list)))

  (define (rhomb frame)
    (let* ((edge3 (make-vect (xcor-vect (edge1-frame frame))
                             (ycor-vect (edge2-frame frame))))
           (edge4 (xcor-vect edge3)
                  (ycor-vect (edge2-frame frame)))
           (origin-edge1-middle (make-vect (/ (xcor-vect (edge1-frame frame)) 2)
                                           (ycor-vect (edge1-frame frame))))
           (edge1-edge3-middle (make-vect (xcor-vect edge3)
                                          (/ (ycor-vect edge3) 2)))
           (edge2-edge3-middle (make-vect (/ (xcor-vect edge3) 2)
                                          (ycor-vect edge3)))
           (origin-edge2-middle (make-vect (xcor-vect (origin-frame frame)))
                                           (/ (ycor-vect (edge2-frame frame)) 2)))

           (segm-list (list (make-segment origin-edge1-middle
                                          edge1-edge3-middle)
                            (make-segment edge1-edge3-middle
                                          edge2-edge3-middle)
                            (make-segment edge2-edge3-middle
                                          origin-edge2-middle)
                            (make-segment origin-edge2-middle
                                          origin-edge1-middle)))
           ((segments->painter segm-list) frame)))

  (define (cross frame)
    (let* ((edge3 (make-vect (xcor-vect (edge1-frame frame))
                             (ycor-vect (edge2-frame frame))))
           (segm-list (list (make-segment edge3 (origin-frame frame))
                            (make-segment (edge2-frame frame) (edge1-frame frame)))))
      ((segments->painter segm-list) frame)))

  (define (draw-frame frame)
    (let* ((edge3 (make-vect (xcor-vect (edge1-frame frame))
                             (ycor-vect (edge2-frame frame))))
           (edge4 (xcor-vect (edge3-frame frame))
                  (ycor-vect (edge2-frame frame)))
           (segm-list (list (make-segment (edge1-frame frame) (origin-frame frame))
                            (make-segment (edge2-frame frame) (origin-frame frame))
                            (make-segment (edge2-frame frame) edge3)
                            (make-segment (edge1-frame frame) edge3)))
           ((segments->painter segm-list) frame))))

  ;; чтоб не генерировать каждый отрезок, создадим вспомогательные функции. Например,
  ;; функцию, генерирующую ломанную линию

  ;; это довольно тупое задание, суть которого - приблизительно прикинуть координаты отрезков. Доделаю его позже.

  (define (wave frame)
  (let* ((head (make-vector

#+END_SRC

~попытка написать растор~

#+BEGIN_SRC scheme
  (define in (open-input-file "in.txt"))

  (read-line in)

  ;; написатьв файл
  (define draw
  (call-with-output-file "in.txt"
    (lambda (p)
      (format p " I am\n"))))

  ;; прочитать из файла
  (call-with-input-file "in.txt"
    (lambda (p)
      (let f ((x (read p)))
        (if (eof-object? x)
            '()
                      (cons x (f (read p)))))))

#+END_SRC

~Упражнение 2.50.~
Определите преобразование flip-horiz, которое обращает изображение вокруг
горизонтальной оси, а также преобразования, которые вращают рисовалки против
часовой стрелки на 180 и 270 градусов.

#+BEGIN_SRC scheme
  (define (transform-painter painter origin corner1 corner2)
    (lambda (frame)
      (let ((m (frame-coord-map frame)))
        (let ((new-origin (m origin)))
          (painter
           (make-frame new-origin
                       (sub-vect (m corner1) new-origin)
                       (sub-vect (m corner2) new-origin)))))))

  (define (rotate90 painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 0.0)))

  (define (rotate180 painter)
    (transform-painter painter
                       (make-vect 1.0 1.0)
                       (make-vect 0.0 1.0)
                       (make-vect 1.0 0.0)))

  (define (rotate270 painter)
    (transform-painter painter
                       (make-vect 0.0 1.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.0 1.0)))

  (define (flip-horiz painter)
    (transform-painter painter
                       (make-vect 1.0 0.0)
                       (make-vect 0.0 0.0)
                       (make-vect 1.0 1.0)))
#+END_SRC


~Упражнение 2.51.~
Определите для рисовалок операцию below. Below принимает в качестве аргументов две ри-
совалки. Когда получившейся рисовалке передается рамка, она рисует в нижней ее половине
при помощи первой рисовалки, а в верхней при помощи второй. Определите below двумя
способами — один раз аналогично процедуре beside, как она приведена выше, а второй раз
через beside и операции вращения (см. упражнение 2.50).

#+BEGIN_SRC scheme
  ;; beside из мана
  (define (beside painter1 painter2)
    (let ((split-point (make-vect 0.5 0.0)))
      (let ((paint-left
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                split-point
                                (make-vect 0.0 0.1)))
            (paint-right
             (transform-painter painter2
                                split-point
                                (make-vect 1.0 0.0)
                                (make-vect 0.5 1.0)))
            (lambda (frame)
              (paint-left frame)
              (paint-right frame))))))

  ;; вариант 1
  (define (below painter1 painter2)
    (let ((split-point (make-vect 0.0 0.5)))
      (let ((paint-down
             (transform-painter painter1
                                (make-vect 0.0 0.0)
                                (make-vect 1.0 0.0)
                                split-point))
            (paint-up
             (transform-painter painter2
                                split-point
                                (make-vect 1.0 0.5)
                                (make-vect 0.0 1.0)))
            (lambda (frame)
              (paint-down frame)
              (paint-up frame))))))

  (define (below painter1 painter2)
    (let* ((new-painter (beside (rotate270 painter1) (rotate270 painter2)))
           (below-painter (rotate90 new-painter)))
      (lambda (frame)
        (below-painter frame))))

#+END_SRC


~Упражнение 2.52.~
Измените предел квадрата рисовалки wave, показанный на рисунке 2.9, работая на каждом
из вышеописанных уровней. А именно:
а. Добавьте новые отрезки к элементарной рисовалке wave из упражнения 2.49 (например,
изобразив улыбку). (доделаю этот кусок, когда сделаю wave)
б. Измените шаблон, который порождает corner-split (например, используя только одну
копию образов up-split и right-split вместо двух).
в. Измените версию square-limit, использующую square-of-four, так, чтобы углы компо-
новались как-нибудь по-другому. (Например, можно сделать так, чтобы большой мистер
Роджерс выглядывал из каждого угла квадрата.)

#+BEGIN_SRC scheme
  ;; изначальный вариант
  ;; видимо цель не просто заполнить рамку изображениями, но и сделать
  ;; окаймовку изображением по краям рамки
  (define (corner-split painter n)
    (if (= n 0)
        painter
        ;; наращиваем изображение вверх
        (let ((up (up-split painter (- n 1)))
              ;; наращиваем изображение вправо
              (right (right-split painter (- n 1))))
          ;; наращиваем изображение влево
          (let ((top-left (beside up up))
                ;; наращиваем изображение вниз
                (bottom-right (below right right))
                ;; повторяем, пока не заполним всю рамку
                (corner (corner-split painter (- n 1))))
            (beside (below painter top-left)
                    (below bottom-right corner))))))

  ;; используем 1 копию образов вместо двух, как сказано в задании
  (define (corner-split painter n)
    (if (= n 0)
        painter
        (let ((up (up-split painter (- n 1)))
              (right (right-split painter (- n 1))))
          (let ((corner (corner-split painter (- n 1))))
            (beside (below painter up)
                    (below right corner))))))
  ;; задание "в"
  ;; изначальный вариант
  (define (square-of-four tl tr bl br)
    (lambda (painter)
      (let ((top (beside (tl painter) (tr painter)))
            (bottom (beside (bl painter) (br painter))))
        (below bottom top))))

  (define (square-limit painter n)
    (let ((combine4 (square-of-four flip-horiz identity
                                    rotate180 flip-vert)))
      (combine4 (corner-split painter n))))

  ;; мой вариант
  (define (square-limit painter n)
    (let ((combine4 (square-of-four flip-vert identity
                                    rotate180 flip-horiz)))
      (combine4 (corner-split painter n))))
#+END_SRC

~Упражнение 2.53.~
Что напечатает интерпретатор в ответ на каждое из следующих выражений?
#+BEGIN_SRC scheme
  (list 'a 'b 'c)
  = (a b c)

  (list (list 'george))
  = ((george))

  (cdr '((x1 x2) (y1 y2)))
  = ((y1 y2))

  (cadr '((x1 x2) (y1 y2)))
  =(y1 y2)

  (pair? (car '(a short list)))
  = #f

  (memq 'red '((red shoes) (blue socks)))
  = #f

  (memq 'red '(red shoes blue socks))
  =(red shoes blue socks)
#+END_SRC

~Упражнение 2.54.~
Предикат ~equal?~ для двух списков возвращает истину, если они содержат одни и те же
элементы в одинаковом порядке.
Например,
~(equal? '(this is a list) '(this is a list))~ истинно, но
~(equal? '(this is a list) '(this (is a) list))~ ложно.
Более точно, можно определить equal? рекурсивно в терминах базового равенства
символов eq?, сказав, что a равно b, если оба они символы и для них выполняется eq? либо
оба они списки и при этом верно, что (car a) равняется в смысле ~equal?~ (car b),
а (cdr a) равняется в смысле equal? (cdr b).
Пользуясь этой идеей, напишите ~equal?~ в виде процедуры.

- eq? берет 2 символа и проверяет, равны ли они (имеют один и тот же набор печатных
  знаков, которые стоят в одинаковом порядке)
- нужна рекурсия
- два списка равны если:
  символ "а" равен символу "б"
  либо они оба списки и при этом у них равны car-ы b cdr-ы
-
#+BEGIN_SRC scheme

  (define (equal? lst1 lst2)
    (cond ((and (not (pair? lst1)) (not (pair? lst2)) (eq? lst1 lst2)) #t)
          ((and (pair? lst1) (pair? lst1) (eq? (car lst1) (car lst2)))
           (equal? (cdr lst1) (cdr lst2)))
          (else #f)))

#+END_SRC

~Упражнение 2.55.~
Ева Лу Атор вводит при работе с интерпретатором выражение
~(car ''abracadabra)~
К ее удивлению, интерпретатор печатает quote. Объясните.

Ответ:
~quote~ предотвращает вычисление символа, следующего сразу за ней. Вторая ~'~ не дает
вычислиться ~abracadabra~, а стоящая перед ней первая ~quote~ не дает вычислиться
второй. Таким образом, последняя запятая попадает в список как символ, она не читается
интерпритатором как функция. Соответственно, ~сar~ полученного списка - это
невычисленная ~quote~.

~Упражнение 2.56.~
Покажите, как расширить простейшую программу дифференцирования так, чтобы она восприни-
мала больше разных типов выражений.
Добавьте еще одну проверку к программе ~deriv~ и определив соответствующие процедуры
exponentiation?, base, exponent и make-exponentiation (обозначать возведение в
степень можно символом **). Встройте правила, что любое выражение, возведенное в
степень 0, дает 1, а возведенное в степень 1 равно самому себе.

Полный код процедуры, представленный в мане:
#+BEGIN_SRC scheme
    (define (variable? x) (symbol? x))

    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))

    (define (make-sum a1 a2) (list '+ a1 a2))

    (define (make-product m1 m2) (list '* m1 m2))

    (define (sum? x)
      (and (pair? x) (eq? (car x) '+)))

    (define (addend s) (cadr s))

    (define (augend s) (caddr s))

    (define (product? x)
      (and (pair? x) (eq? (car x) '*)))

    (define (multiplier p) (cadr p))

    (define (multiplicand p) (caddr p))

    (define (=number? exp num)
      (and (number? exp) (= exp num)))

    (define (make-sum a1 a2)
      (cond ((=number? a1 0) a2)
            ((=number? a2 0) a1)
            ((and (number? a1) (number? a2)) (+ a1 a2))
            (else (list '+ a1 a2))))

    (define (make-product m1 m2)
      (cond ((or (=number? m1 0) (=number? m2 0)) 0)
            ((=number? m1 1) m2)
            ((=number? m2 1) m1)
            ((and (number? m1) (number? m2)) (* m1 m2))
            (else (list '* m1 m2))))

    (define (deriv exp var)
      (cond ((number? exp) 0)
            ((variable? exp)
             (if (same-variable? exp var) 1 0))
            ((sum? exp)
             (make-sum (deriv (addend exp) var)
                       (deriv (augend exp) var)))
            ((product? exp)
             (make-sum
              (make-product (multiplier exp)
                            (deriv (multiplicand exp) var))
              (make-product (deriv (multiplier exp) var)
                            (multiplicand exp))))
            (else
             (error "неизвестный тип выражения -- DERIV" exp))))

#+END_SRC

Мои дополнения:

#+BEGIN_SRC scheme
  ;; функция проверяет, является ли данное выражение возведением в степень
  ;; действуем по аналогии с суммой и произведением:
  (define (exponentiation? expr)
    (and (pair? expr) (eq? (car expr) '**)))

  ;; получаем основание из возведения в степень
  (define (base expr)
    (and (pair? expr) (cadr expr)))

  ;; полуаем экспоненту из возведения в степень
  (define (exponent expr)
    (and (pair? expr) (caddr expr)))

  ;; создаем выражение, которое возводит в заданную степень заданное число
  (define (make-exponentiation base exp)
    (list '** base exp))

  (define test (make-exponentiation 8 2))

  ;; дополненный вариант процедуры
  ;; прочитай про производные
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp)
           (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          ((exponentiation? exp)
           (make-sum
            (make-product (base exp)
                          (deriv (exponent exp) var))
            (make-product (deriv (exponent exp) var)
                          (base exp))))
          (else
           (error "неизвестный тип выражения -- DERIV" exp))))
#+END_SRC

~Упражнение 2.57.~
Расширьте программу дифференцирования так, чтобы она работала с суммами и
произведениями любого (больше двух) количества термов.
Тогда последний из приведенных выше примеров мог бы быть записан как
~(deriv '(* x y (+ x 3)) 'x)~
Попытайтесь сделать это, изменяя только представление сумм и произведений, не трогая
процедуру deriv. Тогда, например, процедура ~addend~ будет возвращать первое
слагаемое суммы, а ~augend~ сумму остальных.

#+BEGIN_SRC scheme
  ;; изначальный вариант
  (define (addend s) (cadr s))

  (define (augend s) (caddr s))

  (define (make-sum a1 a2)
    (list '+ a1 a2))

  ;; мой вариант
  ;; принимает неограниченное кол-во слагаемых
  (define (make-sum a1 . a2)
    (if (pair? a2)
        (append (list '+ a1) a2)
        (list '+ a1 a2)))

  ;; возвращает 1 слагаемое суммы
  (define (addend s) (cadr s))

  ;; возвращает сумму всех слагаемых кроме первого
  (define (augend s)
    (define (iter s)
      (if (null? s)
          0
          (+ (car s) (iter (cdr s)))))
    (iter (cddr s)))

  ;;тестовые примеры
  (define test (make-sum 1 2))

  (define test2 (make-sum 1 2 3 4))

#+END_SRC

~Упражнение 2.58.~
Предположим, что нам захотелось изменить программу дифференцирования так, чтобы она ра-
ботала с обычной математической нотацией, где + и * не префиксные, а инфиксные
операции.
Поскольку программа взятия производных определена в терминах абстрактных данных, мы
можем изменять представление выражений, с которыми она работает, меняя только предикаты,
селекторы и конструкторы, определяющие представление алгебраических выражений, с
которыми должен работать дифференциатор.
а. Покажите, как это сделать так, чтобы брать производные от выражений, представленных
в инфиксной форме, например (x + (3 * (x + (y + 2)))). Для упрощения задачи предполо-
жите, что + и * всегда принимают по два аргумента, и что в выражении расставлены все
скобки.
б. Задача становится существенно сложней, если мы разрешаем стандартную алгебраическую
нотацию, например (x + 3 * (x + y + 2)), которая опускает ненужные скобки и предпола-
гает, что умножение выполняется раньше, чем сложение. Можете ли Вы разработать
соответствующие предикаты, селекторы и конструкторы для этой нотации так, чтобы
наша программа взятия производных продолжала работать?

Вариант "а":
- раньше знаки умножения и сложения всегда стояли первым элементом списка, т.е.
(+ 1 2) или (* 1 (+ 2 8)) и т.д. А теперь они всегда будут стоять вторым элементом.
Таким образом надо только переделать конструкторы и селекторы, отвечающие за сложение и
умножение.
#+BEGIN_SRC scheme
  ;; инфиксная нотация
  (x + (3 * (x + (y + 2))))

  (define (make-sum a1 a2) (list a1 '+ a2))

  (define (make-product m1 m2) (list m1 '* m2))

  (define (sum? x)
    (and (pair? x) (eq? (cadr x) '+)))

  (define (addend s) (car s))

  (define (augend s) (caddr s))

  (define (product? x)
    (and (pair? x) (eq? (cadr x) '*)))

  (define (multiplier p) (car p))

  (define (multiplicand p) (caddr p))

  ;; тестовые примеры
  (define test (make-sum 2 4))

  (define test2 (make-product 3 5))

#+END_SRC

Вариант "б" с стандартной алгебраической нотацией
(это фактически инфиксная нотация, но без вспомогательных скобок. Тем не менее, знак
умножения или сложения окажется "между" своими аргументами, а не перед ними)

1. нужно разработать систему правил:
- внутрениие скобки решаются первыми, т.е. нужно дойти до самого глубокого уровня
  вложенности и начать от него
- установить приоритет операций: умножение и деление выполняются перывыми, сложение и
  вычитание - следом. Если у нас несколько операций умножения или сложения, то начинаем
  их применять слева направо
2. Для осуществления этой системы необходим проход по выражению. Необходима рекурсия.
Текущий элемент списка является парой?
Да!
- зайти внутрь подспика, вычислить его, вернуть значение вычисления, вернуться назад,
  если нет подсписка
Нет!
проверяем следующий элемент списка, пока они не кончатся

Фактически, нужно разработать экспертную систему
проблемы:
- пока не дошли до конца списка, ничего нельзя вычислить: мы не знаем, встретится ли нам
  приоритетная операция или уже можно вычислять, значит, придется проходить по
  выражению несколько раз (но можно сформировать новое, с уже вычисленными частями,
  использовать нехвостовую рекурсию)

#+BEGIN_SRC scheme
  ;; алгебраическая нотация
  (x + 3 * (x + y + 2))

  (define (make-sum a1 a2) (list a1 '+ a2))

  (define (make-product m1 m2) (list m1 '* m2))

  (define (sum? x)
    (and (pair? x) (eq? (cadr x) '+)))

  (define (addend s) (car s))

  (define (augend s) (caddr s))

  (define (product? x)
    (and (pair? x) (eq? (cadr x) '*)))

  (define (multiplier p) (car p))

  (define (multiplicand p) (caddr p))

  ;; тестовые примеры
  (define test (make-sum 2 4))

  (define test2 (make-product 3 5))

#+END_SRC

~Упражнение 2.59.~

Реализуйте операцию ~union-set~ для представления множеств в виде неупорядоченных
списков.
Union-set вычисляет объединение двух множеств, то есть множество, содержащее те
элементы, которые присутствуют хотя бы в одном из аргументов.

То есть два множества (1 2 3 4) и (4 5 6 2) соединятся в (1 2 3 4 5 6), видимо. Потому
что если бы была цель просто соединить два списка, подошла бы операция append. На это
так же указывает утверждение из мана, что "можно представить множество как список, в
котором ни один элемент не содержится более одного раза", таким образом множестве,
которое является результатом объединения, не должно содержаться повторяющихся
элементов.

- как проверить, встречался ли этот элемент?
использовать element-of-set?, который проверяет наличие элемента в множестве
добавить новый элемент можно с помощью adjoin-set

#+BEGIN_SRC scheme
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  (define (union-set set1 set2)
    (define (iter set new-set)
      (if (null? set)
          new-set
          (iter (cdr set) (adjoin-set (car set) new-set))))
    ;; добавляем элементы из первого множества
    (let ((uni-set (iter set1 (list))))
      ;; добавляем элементы из второго моножества
      (iter set2 uni-set)))

  (union-set (list 1 2 3 4) (list 2 3 4 5 6 7))

  (union-set (list 11 2 32 4) (list 22 3 4 42 5 6 7))
#+END_SRC

~Упражнение 2.60.~
Мы указали, что множество представляется как список без повторяющихся элементов. Допу-
стим теперь, что мы разрешаем повторяющиеся элементы. Например, множество {1, 2, 3}
могло бы быть представлено как список (2 3 2 1 3 2 2).
Разработайте процедуры ~element-of-set?~, ~adjoin-set~, ~union-set~ и
~intersection-set~, которые бы работали с таким представлением.
Как соотносится эффективность этих операций с эффективностью соответствующих процедур
для представления без повторений?
Существуют ли приложения, в которых Вы бы использовали скорее
это представление, чем представление без повторений?

Первый вывод: старое представление операций работает корректно на новом представлении
множеств.
Второй вывод: некоторые операции определить теперь проще, раз не надо проверять, был
элемент в множестве или нет. Так, например, для написания ~adjoin-set~ и ~union-set~
теперь не требуется проходить по всем множествам-аргументам, поскольку нет больше
проверки элементов на повторение. Соответственно, мы можем просто присоединить
необходимые элементы, что эффективнее и проще с точки зрения расходования ресурсов.
Но ~element-of-set?~ и ~intersection-set~ переписать невозможно, в результате с
повторяющимися элементами их сложность возрастает линейно.


#+BEGIN_SRC scheme
  ;; проверяет, есть ли элемент в множестве
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((equal? x (car set)) #t)
          (else (element-of-set? x (cdr set)))))

  ;; добавляет новый элемент в множество, если множество не содержит такой же
  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  ;;объяединяет неповторяющиеся элементы 2х множеств в одно
  (define (union-set set1 set2)
    (define (iter set new-set)
      (if (null? set)
          new-set
          (iter (cdr set) (adjoin-set (car set) new-set))))
    ;; добавляем элементы из первого множества
    (let ((uni-set (iter set1 (list))))
      ;; добавляем элементы из второго моножества
      (iter set2 uni-set)))

  ;;возвращает элементы, которые присуствуют в обоих множествах
  (define (intersection-set set1 set2)
    (cond ((or (null? set1) (null? set2)) '())
          ((element-of-set? (car set1) set2)
           (cons (car set1)
                 (intersection-set (cdr set1) set2)))
          (else (intersection-set (cdr set1) set2))))

  ;; новый вариант функций:
  (define (union-set set1 set2)
    (append set1 set2))

  (define (adjoin-set x set)
    (cons x set))

#+END_SRC

~Упражнение 2.61.~
Напишите реализацию ~adjoin-set~ для упорядоченного представления множеств.
По аналогии с ~element-of-set?~ покажите, как использовать упорядочение, чтобы
получить процедуру, которая в среднем требует только половину числа шагов,
которое требуется при неупорядоченном представлении.

Упорядоченные множества позволяют реализовать зачатки бинарного поиска.
~adjoin-set~ построено на ~element-of-set~, которое теперь использует в среднем
в половину меньше шагов. Соответственно, ~adjoin-set~ теперь тоже использует в
полоивну меньше шагов даже при том, что я ничего в нем не изменила.

Но есть и второй вариант, реализованный "с нуля".
#+BEGIN_SRC scheme
  ;; усовершенствованный вариант процедуры для упорядоченных множеств
  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((= x (car set)) #t)
          ((< x (car set)) #f)
          (else (element-of-set? x (cdr set)))))

  (define (adjoin-set x set)
    (if (element-of-set? x set)
        set
        (cons x set)))

  ;; второй вариант
  (define (adjoin-set x set)
    (cond ((or (null? set) (> x (car set))) (cons x set))
          ((= x (car set)) set)
          (else (adjoin-set x (cdr set)))))

  (define test (list 1 2 3 4 5 6 7 8))
#+END_SRC

~Упражнение 2.62.~
Дайте представление порядка Θ(n) для операции ~union-set~ с представлением в виде
упорядоченных списков.

В переводе на человеческий язык, от меня требуется реализация ~union-set~ для
упорядоченных списков, который будет расти линейно.

Внимание: в качестве аргументов моено передавать только упорядоченные списки, причем
упорядочены они должны быть "в одну сторону", т.е. в обоих числа должны располагаться от
меньшего к большему или от большего к меньшему, в противном случае новый список будет
неупорядоченным и может содержать повторяющиеся элементы.

#+BEGIN_SRC scheme
  (define (union-set set1 set2)
    (cond ((and (null? set1) (null? set2)) '())
          ((null? set1) set2)
          ((null? set2) set1)
          (else
           (let ((x1 (car set1)) (x2 (car set2)))
             (cond ((= x1 x2)
                    (cons x1 (union-set (cdr set1) (cdr set2))))
                   ((< x1 x2)
                    (cons x1 (union-set (cdr set1) set2)))
                   (else
                    (cons x2 (union-set set1 (cdr set2)))))))))

  (define set1 (list 2 8 9 13))

  (define set2 (list 1 5 8 10))
#+END_SRC

~Упражнение 2.63.~
Каждая из следующих двух процедур (~tree->list-1~ и ~tree->list-2~) преобразует
дерево в список.
#+BEGIN_SRC scheme
  (define (entry tree) (car tree))

  (define (left-branch tree) (cadr tree))

  (define (right-branch tree) (caddr tree))

  (define (make-node entry left right)
    (list entry left right))

  (define (element-of-set? x set)
    (cond ((null? set) #f)
          ((= x (entry set)) #t)
          ((< x (entry set))
           (element-of-set? x (left-branch set)))
          ((> x (entry set))
           (element-of-set? x (right-branch set)))))

  (define (adjoin-set x set)
    (cond ((null? set) (make-node x '() '()))
          ((= x (entry set)) set)
          ((< x (entry set))
           (make-node (entry set)
                      (adjoin-set x (left-branch set))
                      (right-branch set)))
          ((> x (entry set))
           (make-node (entry set)
                      (left-branch set)
                      (adjoin-set x (right-branch set))))))

  (define (tree->list-1 tree)
    (if (null? tree)
        '()
         (append (tree->list-1 (left-branch tree))
                 (cons (entry tree)
                       (tree->list-1 (right-branch tree))))))

  (define (tree->list-2 tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
          result-list
          (copy-to-list (left-branch tree)
                        (cons (entry tree)
                              (copy-to-list (right-branch tree)
                                            result-list)))))
    (copy-to-list tree '()))


  (define test-tree (list->tree (list 1 2 3 4 5 6 7)))
  (define test-tree2 (list->tree (list 1 3 5 7 9 11)))
  (define test-tree3 (list->tree (list 1 7 5 3 11 9)))


  (define (list->tree elements)
    (car (partial-tree elements (length elements))))

  (define (partial-tree elts n)
    (if (= n 0)
        (cons '() elts)
        (let ((left-size (quotient (- n 1) 2)))
          (let ((left-result (partial-tree elts left-size)))
            (let ((left-tree (car left-result))
                  (non-left-elts (cdr left-result))
                  (right-size (- n (+ left-size 1))))
              (let ((this-entry (car non-left-elts))
                    (right-result (partial-tree (cdr non-left-elts)
                                                right-size)))
                (let ((right-tree (car right-result))
                      (remaining-elts (cdr right-result)))
                  (cons (make-node this-entry left-tree right-tree)
                        remaining-elts))))))))
#+END_SRC

а. Для всякого ли дерева эти процедуры дают одинаковый результат? Если нет, то как их
результаты различаются? Какой результат дают эти две процедуры для деревьев с рисунка
2.16?

б. Одинаков ли порядок роста этих процедур по отношению к числу шагов, требуемых для
преобразования сбалансированного дерева с n элементами в список? Если нет, которая из
них растет медленнее?

Добавлены вспомогательный функции из мана. Оригинальная ~make-tree~ переименована
в ~make-node~, поскольку это лучше отражает ее суть.
Для построения дерева из списка использована ~list->tree~, представленная в следующем
упражнении.

Для множества {1, 3, 5, 7, 9, 11}, представленного бинарными диревьямис рисунка 2.16 не
найдено различий пи использовании ~tree->list-1~ и ~tree->list-2~ (для ~test-tree~
тоже).

~tree->list-1~ представляет собой нехвостовую рекурсию. То есть по достижению дна
рекурсии м еще будем вынуждены откатываться назад по стеку. Хранение всех переменных на
каждом вызове рекурсии требует памяти, чем больше элементов дерева, тем больше вызовов
рекурсии, тем больше памяти.

~tree->list-2~ представляет собой хвостовую рекурсию, то есть не производить никаких
вычислений по достижению дна рекурсии, а возвращает конечный результат. Это не требует
хранения всех переменных на каждомй итерации рекурсии, соответственно, меньше
расходуется ресурсов. Я думаю, что эта функция будет расти медленнее.

~Упражнение 2.64~
Следующая процедура ~list->tree~ преобразует упорядоченный список в сбалансированное би-
нарное дерево. Вспомогательная процедура ~partial-tree~ принимает в качестве аргументов
целое число n и список по крайней мере из n элементов, и строит сбалансированное дерево
из первых n элементов дерева.
Результат, который возвращает ~partial-tree~, — это пара (построенная
через cons), car которой есть построенное дерево, а cdr — список элементов,
не включенных в дерево.

а. Дайте краткое описание, как можно более ясно объясняющее работу ~partial-tree~.
Нарисуйте дерево, которое ~partial-tree~ строит из списка (1 3 5 7 9 11).

б. Каков порядок роста по отношению к числу шагов, которые требуются процедуре
~list->tree~ для преобразования дерева из n элементов?

#+BEGIN_SRC scheme
  (define (entry tree) (car tree))

  (define (left-branch tree) (cadr tree))

  (define (right-branch tree) (caddr tree))

  (define (make-node entry left right)
    (list entry left right))

  ;; возвращает car от результата partial-tree, который является динарным деревом
  (define (list->tree elements)
    (car (partial-tree elements (length elements))))


  (define (partial-tree elts n)
    ;; если элементы кончились
    (if (= n 0)
        (cons '() elts)
        ;; возвращает разность от деления
        ;; предполагаемый размер левой ветки
        (let ((left-size (quotient (- n 1) 2)))
          ;; строим левую ветку
          (let ((left-result (partial-tree elts left-size)))
            ;; получаем элементы для левой ветки
            (let ((left-tree (car left-result))
                  ;; получаем элементы, которые в левую ветку не вошли
                  (non-left-elts (cdr left-result))
                  ;; получаемразмер правой ветки
                  (right-size (- n (+ left-size 1))))
              ;; получаем первый элемент из элементов, не вошедших в левую ветку
              (let ((this-entry (car non-left-elts))
                    ;; строим правую ветку
                    (right-result (partial-tree (cdr non-left-elts)
                                                right-size)))
                ;; получаем правую ветку
                (let ((right-tree (car right-result))
                      ;; получаем элементы, не вошедшие в правую ветку
                      (remaining-elts (cdr right-result)))
                  ;; соединяем все в дерево и присоединяем элменты, не вошедшие в ветку
                  (cons (make-node this-entry left-tree right-tree)
                        remaining-elts))))))))
#+END_SRC

Итак, процедура ~partial-tree~ возвращает конс-пару, где car - это построенное дерево,
а cdr - элементы, не вошедшие в него.
~partial-tree~ принимает в качестве аргумента список элементов и длину списка. Все
вместе это позволяет создать отдельно левую и правые ветки, а затем соединить их от
корня: делим исходное кол-во элементов примерно поровну, помещаем первую половину
элементов в левую ветку, а оставшиеся - в правую.

Я думаю, что данная процедура имеет порядок роста O(n), поскольку нам необходимо
обработать кажды элемент списка по одному разу, сколько бы их ни было.

~Упражнение 2.65.~
Используя результаты упражнений 2.63 и 2.64, постройте реализации ~union-set~ и
~intersection-set~ порядка Θ(n) для множеств, реализованных как (сбалансированные)
бинарные деревья.

Для ~union-set~ нам требуется проверять, не повторяются ли элементы в деревьях
и создать новое дерево на основе 2х предыдущих. Сначала получим список элементов после
обхода обоих деревьев, а затем создадим дерево из этого списка.


#+BEGIN_SRC scheme

  (define (tree->list tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
          result-list
          (copy-to-list (left-branch tree)
                        (cons (entry tree)
                              (copy-to-list (right-branch tree)
                                            result-list)))))
    (copy-to-list tree '()))

  (define (union-tree tree1 tree2)
    (define (union-set set1 set2)
      (cond ((and (null? set1) (null? set2)) '())
            ((null? set1) set2)
            ((null? set2) set1)
            (else
             (let ((x1 (car set1)) (x2 (car set2)))
               (cond ((= x1 x2)
                      (cons x1 (union-set (cdr set1) (cdr set2))))
                     ((< x1 x2)
                      (cons x1 (union-set (cdr set1) set2)))
                     (else
                      (cons x2 (union-set set1 (cdr set2)))))))))
    (let* ((tree1-list (tree->list tree1))
           (tree2-list (tree->list tree2))
           (new-list (union-set tree1-list tree2-list)))
      (list->tree new-list)))

  (define (intersection-tree tree1 tree2)
    (define (element-of-set? x set)
      (cond ((null? set) #f)
            ((= x (car set)) #t)
            ((< x (car set)) #f)
            (else (element-of-set? x (cdr set)))))
    (define (intersection-set set1 set2)
      (cond ((or (null? set1) (null? set2)) '())
            ((element-of-set? (car set1) set2)
             (cons (car set1)
                   (intersection-set (cdr set1) set2)))
            (else (intersection-set (cdr set1) set2))))
    (let* ((tree1-list (tree->list tree1))
           (tree2-list (tree->list tree2))
           (new-list (intersection-set tree1-list tree2-list)))
      (list->tree new-list)))


  (define test-tree1 (list->tree (list 8 9 10 11 17 19)))
  (define test-tree2 (list->tree (list 1 3 5 7 9 11)))
#+END_SRC

Для написания ~union-tree~ я воспользовалась ~tree->list-2~ (поскольку она
использует звостовую рекурсию) из упр. 2.63, чтоб сформировать списки из деревьев,
но переименовала в ~tree->list~ для ясности. Затем уже написанную версию
~union-set~ для объединения 2х множеств, получила новый список и из него составила
новое дерево.

В ~intersection-tree~ логика аналогичная, только к тому же использована версия
~element-of-set?~ для упорядоченных списков, а не бинарных деревьев.

~Упражнение 2.66.~
Реализуйте процедуру ~lookup~ для случая, когда множество записей организовано в виде
бинарного дерева, отсортированного по числовым значениям ключей.

При написании воспользовалась логикой ~element-of-set?~ для упорядоченных списков.
Клчи в базе данных должны возрастать от меньшего к большему, а не наоборот.
Здесь присутствует процедура ~key~, код которой отсуствует в мане.

#+BEGIN_SRC scheme
  (define (lookup given-key set-of-records)
    (cond ((or (null? set-of-records)
               (<  given-key (key (car set-of-records)))) #f)
          ((equal? given-key (key (car set-of-records)))
           (car set-of-records))
          (else (lookup given-key (cdr set-of-records)))))
#+END_SRC


~Упражнение 2.67.~
Пусть нам даны дерево кодирования и пример сообщения.
Раскодируйте сообщение при помощи процедуры decode.

#+BEGIN_SRC scheme
  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
                    (make-code-tree
                     (make-leaf 'B 2)
                     (make-code-tree (make-leaf 'D 1)
                                     (make-leaf 'C 1)))))

  (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+END_SRC

Все процедуры из мана, касающиеся деревьев Хаффмана:

#+BEGIN_SRC scheme
    ;; создает лист,который содержитв  себе символ и частоту его употребления
    (define (make-leaf symbol weight)
      (list 'leaf symbol weight))

    (define (leaf? object)
      (eq? (car object) 'leaf))

    (define (symbol-leaf x) (cadr x))

    (define (weight-leaf x) (caddr x))

    (define (make-code-tree left right)
      (list left
            right
            (append (symbols left) (symbols right))
            (+ (weight left) (weight right))))

    (define (left-branch tree) (car tree))

    (define (right-branch tree) (cadr tree))

    (define (symbols tree)
      (if (leaf? tree)
          (list (symbol-leaf tree))
          (caddr tree)))

    (define (weight tree)
      (if (leaf? tree)
          (weight-leaf tree)
          (cadddr tree)))

    (define (choose-branch bit branch)
      (cond ((= bit 0) (left-branch branch))
            ((= bit 1) (right-branch branch))
            (else (error "плохой бит -- CHOOSE-BRANCH" bit))))

    (define (decode bits tree)
      (define (decode-1 bits current-branch)
        (if (null? bits)
            '()
             (let ((next-branch
                    (choose-branch (car bits) current-branch)))
               (if (leaf? next-branch)
                   (cons (symbol-leaf next-branch)
                         (decode-1 (cdr bits) tree))
                   (decode-1 (cdr bits) next-branch)))))
      (decode-1 bits tree))
#+END_SRC

Ответ:
(A D A B B C A)


~Упражнение 2.68.~
Процедура ~encode~ получает в качестве аргументов сообщение и дерево, и порождает список
битов, который представляет закодированное сообщение.

~encode-symbol~ — процедура, которую Вы должны написать, возвращает список битов, кото-
рый кодирует данный символ в соответствии с заданным деревом. Вы должны спроектировать
encode-symbol так, чтобы она сообщала об ошибке, если символ вообще не содержится в
дереве.
Проверьте свою процедуру, закодировав тот результат, который Вы получили в упражнении
2.67, с деревом-примером и проверив, совпадает ли то, что получаете Вы,
с исходным сообщением.

Итак, это обратная операция по отношению к ~decode~: имея дерево и сообщения, мне нужно
закодировать сообщение в биты.
Есть неявное присовение кодов буквам, т.е. у нас нет хэш-таблицы, например, где было бы
сказано, что код А - это 0, B- это 100 и т.д. Но это следует из построения самого
дерева и выбора пути. Если дерево из предыдущего упражнения будет переопределено другим
образом, то сообщение изменится, поскольку код буквы определяется по достижению листа,
где лежит эта буква. Например, чтоб достичь "B" ~decode~ должена "повернуть" один раз
направо и 2 раза налево, поскольку встреченный бит 1 означает выбор правой ветки, а 0 -
выбор левой ветки.

Следовательно, чтоб закодировать букву в в биты, нам нужно запомнить, куда мы
поворачивали, пока искали ту саму букву. Буква - это символ, для определения
соответствия между данной и искомой буквы будем пользоваться ~equal?~. Если достигли
нужную букву, возвращаем список "поворотов" в виде битов.

Сообщение об ошибке - это если мы достигли листа, но не нашли там искомую букву -
возвращаем false

#+BEGIN_SRC scheme

(define (elements-of-set? symbol set)
    (cond ((null? set) #f)
          ((equal? (car set) symbol) #t)
          (else (elements-of-set? symbol (cdr set)))))

  (define (encode-symbol letter tree)
    (define (test letter tree)
      (cond ((and (leaf? tree) (equal? (symbol-leaf tree) letter)) '())
            ((elements-of-set? letter (symbols (left-branch tree)))
             (cons 0 (test letter (left-branch tree))))
            ((elements-of-set? letter (symbols (right-branch tree)))
             (cons 1 (test letter (right-branch tree))))
            (else #f)))
    (test letter tree))

  (define (encode message tree)
    (if (null? message)
        '()
         (append (encode-symbol (car message) tree)
                 (encode (cdr message) tree))))

#+END_SRC

~Упражнение 2.69.~
Следующая процедура берет в качестве аргумента список пар вида символ-частота (где ни
один символ не встречается более, чем в одной паре) и порождает дерево кодирования по
Хаффману в соответствии с алгоритмом Хаффмана.

#+BEGIN_SRC scheme

  (define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

#+END_SRC

Приведенная выше процедура ~make-leaf-set~ преобразует список пар в упорядоченное множе-
ство пар. Вам нужно написать процедуру ~successive-merge~, которая при помощи
~make-code-tree~ сливает наиболее легкие элементы множества, пока не останется только
один элемент, который и представляет собой требуемое дерево Хаффмана.
(Эта процедура устроена немного хитро, но она не такая уж сложная. Если Вы видите,
что строите сложную процедуру, значит, почти наверняка Вы делаете что-то не то.
Можно извлечь немалое преимущество из того, что мы используем упорядоченное
представление для множеств.)

Видимо, упорядоченное множество пар - это пары, отсортирортированные от реже
встречающихся букв до чаще встречающихся. То есть дерево нужно построить не от корня, а
от листьев.

Поправка к заданию: это не просто пары, а "листья", сконструированные с помощью
~make-leaf~ , в противном случае процедуры ~symbols~ и ~weight~ внутри
~make-code-tree~ выдают ошибки, поскольку на вход лолжны получать списки вида
~(leaf A 4)~, а не ~(A 4)~ или ~(A . 4)~.


#+BEGIN_SRC scheme

  (define set (list (make-leaf 'D 1) (make-leaf 'C 1) (make-leaf 'B 2) (make-leaf 'A 4)))

  (define set2
    (list (make-leaf 'D 1) (make-leaf 'C 1) (make-leaf 'B 2) (make-leaf 'A 4)
          (make-leaf 'F 4) (make-leaf 'G 4)))


  (define (successive-merge set)
    (define (iter set tree)
      (cond ((null? set) tree)
            ((null? tree) (iter (cddr set) (make-code-tree (car set) (cadr set))))
            (else (iter (cdr set) (make-code-tree (car set) tree)))))
    (iter set '()))

#+END_SRC

~Упражнение 2.70.~
Нижеприведенный алфавит из восьми символов с соответствующими им относительными часто-
тами был разработан, чтобы эффективно кодировать слова рок-песен 1950-х
годов. (Обратите внимание, что «символы» «алфавита» не обязаны быть отдельными
буквами.)
A     2
BOOM  1
GET   2
JOB   2

NA    16
SHA   3
YIP   9
WAH   1

При помощи ~generate-huffman-tree~ (упр. 2.69) породите соответствующее дерево Хаффмана,
и с помощью encode закодируйте следующее сообщение:
Get a job
Sha na na na na na na na na
Get a job
Sha na na na na na na na na
Wah yip yip yip yip yip yip yip yip yip
Sha boom
Сколько битов потребовалось для кодирования? Каково наименьшее число битов, которое
потребовалось бы для кодирования этой песни, если использовать код с
фиксированной длиной для алфавита из восьми символов?

Придется написать ~make-leaf-set~ самой.
#+BEGIN_SRC scheme
  ;; получает на вход пару и множество, из которого ее надо удалить
  ;; если данной пары нет в множестве, возвращается исходное множество
  ;; в противном случае возвращается список без указанной пары
  (define (remove-elem pair set)
    (define (iter set list)
      (cond ((null? set) list)
            ((equal? (car pair) (car (car set))) (iter (cdr set) list))
            (else (iter (cdr set) (cons (car set) list)))))
    (iter set '()))

  ;; превращает список пар в список листьев, где каждый подсписок иммет вид
  ;; (leaf D 3)
  (define (list->list-of-leafs list)
    (define (iter list list-leafs)
    (if (null? list)
        list-leafs
        (iter (cdr list) (cons (make-leaf (car (car list))
                                          (cadr (car list)))
                               list-leafs))))
    (iter list '()))

  ;; принимает на вход неупорядоченный список,
  ;; возвращает успорядочееный список листьев по принципу от меньшего к большему
  (define (make-leaf-set pairs)
    (define (iter elem pairs list)
      ;; если список кончился, присоединяем оставшийся элемент к новому списку
      (cond ((null? pairs) (cons elem list))
            ;; если cdr первой пары списка <= cdr текущего элемента
            ((<= (cadr (car pairs)) (cadr elem))
             ;; заменяем текущий элемент первой парой списка
             (iter (car pairs) (cdr pairs) list))
            ;; иначе сравниваем текущий элемент со следующей парой
            (else (iter elem (cdr pairs) list))))
    (define (make-ordered-set set leaf-set)
      (if (null? set)
          leaf-set
          (let* ((new-list (iter (car set) set leaf-set))
                 (newest-leaf (car new-list)))
            (make-ordered-set (remove-elem newest-leaf set) new-list))))
    (list->list-of-leafs (make-ordered-set pairs '())))

  ;; тестовый пример
  (define test (list '(F 3) '(G 2) '(D 4) '(S 1)))

  ;; запуск
  (make-leaf-set test2)
#+END_SRC

Теперь можно и к самому заданию приступить.
#+BEGIN_SRC scheme
  (define (generate-huffman-tree pairs)
    (successive-merge (make-leaf-set pairs)))

  (define (successive-merge set)
    (define (iter set tree)
      (cond ((null? set) tree)
            ((null? tree) (iter (cddr set) (make-code-tree (car set) (cadr set))))
            (else (iter (cdr set) (make-code-tree (car set) tree)))))
    (iter set '()))

  (define alphabet  (list '(a 2) '(boom 1) '(Get 2) '(job 2)
                          '(na 16) '(Sha 3) '(yip 9) '(Wah 1)))

  (define message '(Get a job
                        Sha na na na na na na na na
                        Get a job
                        Sha na na na na na na na na
                        Wah yip yip yip yip yip yip yip yip yip
                        Sha boom))

  (define (make-message alphabet message)
    (let ((tree (generate-huffman-tree alphabet)))
      (encode message tree)))

#+END_SRC

Ответ: 87 битов потребовалось, чтоб закодировать сообщение.
'(1 1 1 0 1 1 1 1 0 1 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 1 1 0 1
 1 1 1 1 0 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
 0 1 0 1 0 1 1 0 1 1 1 1 1 1 1)

Так выглядит кодирование каждой "буквы" алфавита. В среднем каждой букве
нужно по 4 бита. Таким образом, если бы все коды имели фиксированную
длину в 4 бита, то ничего бы не изменилось. В закодированном сообщении
все так же было бы 87 символов.
job:
(1 1 1 1 1 0)
Wah:
(1 1 1 1 1 1 0)
yip:
(1 0)
Sha:
(1 1 0)
Get:
(1 1 1 0)
na:
(0)
a:
(1 1 1 1 0)

~Упражнение 2.71.~
Допустим, у нас есть дерево Хаффмана для алфавита из n символов, и
относительные частоты символов равны 1, 2, 4, . . . , 2^n−1 .
Изобразите дерево для n = 5; для n = 10. Сколько битов в таком
дереве (для произвольного n) требуется, чтобы закодировать самый частый
символ? Самый редкий символ?

Значит, если у нас 5 символов, наприммер, А B C D E, то A будет иметь относительную
частоту 1, B - 2, C - 4, D - 8, E - 16. Если символов 10, то 10ый символ
будет иметь относительную частоту 512, поскольку это 2^9.

В обоих деревьях понадобится всегда 1 бит для кодирования наиболее часто
встречающегося символа, поскольку такой символ будет в самом верху
дерева. А чтоб достичь самого редкого символа понадобится n-1 шагов.

~Упражнение 2.72.~
Рассмотрим процедуру кодирования, которую Вы разработали в упражнении
2.68. Каков порядок роста в терминах количества шагов,
необходимых для кодирования символа?
Не забудьте включить число шагов, требуемых для поиска символа в каждой следующей
вершине. Ответить на этот вопрос в общем случае сложно. Рассмотрите
особый случай, когда относительные частоты символов таковы, как описано в
упражнении 2.71, и найдите порядок роста (как функцию от n) числа шагов,
необходимых, чтобы закодировать самый частый и самый редкий символ алфавита.

Процедура в упражнении 2.68 работает следующим образом: с помощью
субпроцедуры ~symbols~ собираем с левой ветки символы и проверяем, есть
ли там наш, потом то же самое проделываем с правой веткой. В какой ветке
символ обнаружился, туда и сворачиваем. И продолжаем так, пока не найдем
символ.  Вопрос, что считать одним шагом?
Предположим, что на одну итерацию рекурсии приходится в худшем случае 5
операций: сбор символов с одной ветки, проверка, если символ в наборе
символов, то же саоме проделываем в другой веткой, и переход на новый
уровень рекурсии. В упражнении 2.71 мы выяснили, что достижение самого
редкого символа обходится в n-1 вызовов рекурсии. Значит, чтоб обозначить
кол-во шагов для поиска символа в самом худшем случае, нужно умножить
кол-во операций на каждом шаге рекурсии (в нашем случае это 5) на n-1,
где n - это кол-во элементов в дереве. В O-нотации это будет выглядеть
примерно так: О(n-1 * 5).

~Упражнение 2.73.~
В разделе 2.3.2 описывается программа, которая осуществляет символьное
дифференцирование:

#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          ((sum? exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product? exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          ;;Здесь можно добавить еще правила
          (else (error "неизвестный тип выражения -- DERIV" exp))))
#+END_SRC

Можно считать, что эта программа осуществляет диспетчеризацию по типу
выражения, которое требуется продифференцировать. В этом случае «меткой типа» элемента
данных является символ алгебраической операции (например, +), а операция, которую нужно
применить – deriv. Эту программу можно преобразовать в управляемый
данными стиль,  если переписать основную процедуру взятия производной в
виде

#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else ((get 'deriv (operator exp)) (operands exp)
                 var))))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))
#+END_SRC

а. Объясните, что происходит в приведенном фрагменте кода. Почему нельзя
включить в операцию выбора, управляемого данными, предикаты ~number?~ и ~variable?~?
б. Напишите процедуры для вычисления производных от суммы и произведения,
а также дополнительный код, чтобы добавить их к таблице, которой пользуется
приведенный фрагмент.
в. Выберите еще какое-нибудь правило дифференцирования, например для
возведения в степень (упражнение 2.56), и установите его в систему.
г. В этой простой алгебраической системе тип выражения — это
алгебраическая операция верхнего уровня. Допустим, однако, что мы индексируем процедуры
противоположным образом, так что строка диспетчеризации в ~deriv~ выглядит как
~((get (operator exp) 'deriv) (operands exp) var)~
Какие изменения потребуются в системе дифференцирования?

Ответы:
а) Если выражение - это число, возвращаем 0. Если выражение - это
переменная, причем там же самая, что и ~var~, то возвращаем 1, иначе 0.Ну
и если это ни то, ни другое, то мы получаем из таблицы с помощью
процедуры ~get~ содержимое ячейки, чей индекс - это ~deriv~, а тип - это
car выражения. Содержимому ячейки передается cdr выражения и
переменная. Предикаты ~number?~ и ~variable?~ работают с разными
представлениями данных, но не содержат в себе процедуру, по которой можно
произвести диспетчеризацию. Их включение в процедуру выбора просто не
имеет смысла.
б)
#+BEGIN_SRC scheme
  (define (deriv exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else ((get 'deriv (operator exp)) (operands exp)
                 var))))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (sum-product-package exp var)
    (define (variable? x) (symbol? x))
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))
    (define (make-sum a1 a2) (list '+ a1 a2))
    (define (make-product m1 m2) (list '* m1 m2))
    (define (addend s) (cadr s))
    (define (augend s) (caddr s))
    (define (multiplier p) (cadr p))
    (define (multiplicand p) (caddr p))
    (define (=number? exp num)
      (and (number? exp) (= exp num)))
    (define (make-sum a1 a2)
      (cond ((=number? a1 0) a2)
            ((=number? a2 0) a1)
            ((and (number? a1) (number? a2)) (+ a1 a2))
            (else (list '+ a1 a2))))
    (define (make-product m1 m2)
      (cond ((or (=number? m1 0) (=number? m2 0)) 0)
            ((=number? m1 1) m2)
            ((=number? m2 1) m1)
            ((and (number? m1) (number? m2)) (* m1 m2))
            (else (list '* m1 m2))))
  (define sum (exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))))
  (define product (exp var)
    (cond ((number? exp) 0)
          ((variable? exp) (if (same-variable? exp var) 1 0))
          (else (make-sum
                 (make-product (multiplier exp)
                               (deriv (multiplicand exp) var))
                 (make-product (deriv (multiplier exp) var)
                               (multiplicand exp))))))
  (put 'deriv '+ sum)
  (put 'deriv '* product)
#+END_SRC

в) - надо разобраться с диффурами

г)  Понадобится только изменить способ, с помощью которого мы заносим данные
в таблицу.

~Упражнение 2.74.~
Insatiable Enterprises, Inc. — децентрализованная компания-конгломерат,
которая состоит из большого количества независимых подразделений, раскиданных по всему
миру. Недавно вычислительные мощности компании были связаны умной
вычислительной сетью, создающей для пользователя иллюзию, что он работает
с единым компьютером. Президент компании, когда она в первый раз
пытается воспользоваться способностью системы осуществлять доступ к
файлам подразделений, с изумлением и ужасом обнаруживает, что, несмотря
на то, что все эти файлы реализованы в виде структур данных на Scheme,
конкретная структура данных отличается от подразделения к подразделению.
Спешно созывается совещание менеджеров подразделений, чтобы найти стратегию,
которая позволила бы собрать файлы в единую систему для удовлетворения
нужд главного офиса, и одновременно сохранить существующую автономию подразделений.

Покажите, как такую стратегию можно реализовать при помощи
программирования, управляемого данными. К примеру, предположим, что
сведения о персонале каждого подразделения устроены в виде единого файла,
который содержит набор записей, проиндексированных по имени служащего.
Структура набора данных от подразделения к подразделению различается. Более того,
каждая запись сама по себе — набор сведений (в разных подразделениях
устроенный по-разному), в котором информация индексируется метками вроде
address (адрес) или salary (зарплата).
В частности:

а. Для главного офиса реализуйте процедуру get-record, которая получает
запись, относящуюся к указанному служащему, из указанного файла персонала. Процедура
должна быть применима к файлу любого подразделения. Объясните, как должны
быть структурированы файлы отдельных подразделений.
В частности, какую информацию о типах нужно хранить?

б. Для главного офиса реализуйте процедуру get-salary, которая возвращает
зарплату указанного служащего из файла любого подразделения.
Как должна быть устроена запись, чтобы могла работать эта процедура?

в. Для главного офиса напишите процедуру find-employee-record. Она должна
искать в файлах всех подразделений запись указанного служащего и возвращать эту
запись. Предположим, что в качестве аргументов эта процедура принимает имя служащего и
список файлов всех подразделений.

г. Какие изменения требуется внести в систему, чтобы внести в центральную
систему информацию о новых служащих, когда Insatiable поглощает новую компанию?

а) Нам сказано, что данные о сотрудниках подразделения хранятся в едином
файле. Файл содержит в себе набор записей, доступ к конкретному набору записей
можно получить с помощью фамилии сотрудника, к которому относится этот набор.
При этом структура файла у всех подразделений различается, как и
структура набора записей сотрудника. Но при этом этот набор индексируется
метками типа "адрес" или "зп".

Чтобы унифицировать все это безобразие, я бы сказала, что файл каждого
подразделения должен быть представлен как таблица, где ячейка
индексируется фамилией сотрудника и названием подразделения (вдруг есть 2
человека с одной фамилией в разных подраделениях).
Ячейка каждого сотруднника тоже будет
представлять из себя таблицу, где ячейки будут индексироваться с помощью
ключевых слов, таких как "зп", "семейное положение" и т.д.

К сожалению, эта идея не очень укладывается в предложенные
задания. Поэтому мы видоизменим идею. Педположим у нас все по-прежнему
организованно так же разномастно, но мы создадим процедуры, которые
функционируют по-разному в зависимости от того, с каким типом они
работают, и положим их в общую таблицу. Таблица будет проиндексирована с
помощью названия операции и типа, с которым которым операция работает. А
внутри ячейка будет содержать саму операцию.

Предположим, есть 2 подраздения. Программисты и менеджеры. Файл
программистов построен в виде таблицы, где каждая ячейка
проиндексирована названием подразделения и именем сотрудника. А записи
менеджеров оформлены в виде списка с подсписками.

Создадим 2 процедуры получения записи для каждого подразделения отдельно
и положим их в таблицу:
#+BEGIN_SRC scheme
  (define (get-record-programmer office name)
    (get office name))

  (define Office_ND (предположим, здесь какая-то таблица))
  ;; внесем эту процедуру в таблицу:
  ;; процедура обобщенно называется get-record, работает она с типом работников из Office_ND
  ;; и содержит в себе get-record-programmer, которая и достанет нам имя сотрудника.
  (put 'get-record 'Office_ND get-record-programmer)


  ;; предположим, записи менеджеров устроены как списки списков. Нам нужно просто найти
  ;; подсписок, который начинается с имени сотруждника
  (define (get-record-manager office name)
    (cond ((null? office) #f)
          ((equal? name (car (car office))) (cdr (car office)))
          (else (get-record-manager (cdr office) name))))

  ;; проверим, что эта процедура работает (с предыдущей процедурой этого сделать нельзя,
  ;; поскольку процедура get не определена в манепока что

  (define Office-NY (list (list 'Leemann (list 'salary 1000) (list 'adress 195204))
                     (list 'Kandinsky (list 'salary 1300) (list 'adress 947181))
                     (list 'Grauman (list 'salary 1100) (list 'adress 197382))))


  (get-record-manager Office-NY 'Leemann)
  (get-record-manager Office-NY 'Grauman)
  (get-record-manager Office-NY 'Durkess)

  ;; положим эту процедуру в таблицу тоже
  (put 'get-record 'Office-NY get-record-manager)

#+END_SRC

В соответствии с этой логикой ~get-record~ будет выглядеть так:
#+BEGIN_SRC scheme
  (define (get-record office name)
    ;; получаем процедуру и передаем ей параметры: офис и имя сотрудника
    ((get 'get-record office) office name))
#+END_SRC

б) Раз мы научились получать набор записей сотрудника и в общем
ориентироваться в файле, теперь на основе этого можно получить зарплату.
Предположим, что несмотря на то, что набор записей сотрудника в отделах
организован по-разному (у программеров этот файл выглядит как таблица, а
у манагеров - как список списков), но сведения о конкретном сотруднике
организованны в виде списка.
Таким образом нам сначала надо получить набор записей конкретного
сотрудника, а уже потом вытащить оттуда зп.
#+BEGIN_SRC scheme
  (define (get-salary office name)
    ;; получили конкретную запись
    (let ((record ((get 'get-record office) office name)))
      ;;процедура для поиска зп
      (define (iter record)
        (cond ((null? record) #f)
              ((equal? 'salary (car (car record))) (cadr (car record)))
              (else (iter (cdr record)))))
      (iter record)))

  ;; проверка iter отдельно от основной процедуры
  (define (iter record)
    (cond ((null? record) #f)
          ((equal? 'salary (car (car record))) (cadr (car record)))
          (else (iter (cdr record)))))

  (define test (list (list 'salary 1000)
                     (list 'adress 'street_1) (list 'wife 'Angel)))

  (define test2 (list (list 'adress 'street_1)  (list 'salary 1000) (list 'wife 'Angel)))
#+END_SRC

в)
Для главного офиса напишите процедуру find-employee-record. Она должна
искать в файлах всех подразделений запись указанного служащего и возвращать эту
запись. Предположим, что в качестве аргументов эта процедура принимает имя служащего и
список файлов всех подразделений.

Я бы вместо списка файлов организовала бы общую таблицу, где каждая
ячейка была бы проиндексирована именем сотрудника и названием
подразделения. Но пусть будет список файлов, записи в которых
представлены списками.

#+BEGIN_SRC scheme
  (define (find-employee-record office-list name)
    ;; пытаемся получить запись сотрудника из текуего файла
    (let ((record ((get 'get-record (car office-list)) (car office-list) name)))
      ;; запись пустая и список подразделений кончится на след итерации? - #f
      (cond ((and (null? record) (null? (cdr office-list))) #f)
            ;; запись пустая, но список еще не кончился?  - ищем по файлам дальше
            ((null? record) (find-employee-record (cdr office-list) name))
            ;; запись нашли
             (else record))))
#+END_SRC

г) Потребуется просто завести еще один файл и добавить его в общую
систему файлов.

~Упражнение 2.75.~
Реализуйте в стиле передачи сообщений конструктор ~make-from-mag-ang~. Он
должен быть аналогичен приведенной выше процедуре ~make-from-real-imag~.

#+BEGIN_SRC scheme
  (define (make-from-mag-ang magnitude angle)
    (define (dispatch op)
      (cond ((eq? op 'real-part) (* magnitude (cos angle)))
            ((eq? op 'imag-part) (* magnitude (sin angle)))
            ((eq? op 'magnitude) magnitude)
            ((eq? op 'angle) angle)
            (else
             (error "Неизвестная оп. -- MAKE-FROM-REAL-IMAG" op))))
    dispatch)
#+END_SRC

~Упражнение 2.76.~
Когда большая система с обобщенными операциями развивается, могут
потребоваться новые типы объектов данных или новые операции. Для каждой
из трех стратегий — обобщенные операции с явной диспетчеризацией, стиль,
управляемый данными, и передача сообщений, – опишите, какие изменения
нужно произвести в системе, чтобы добавить новый тип или новую
операцию. Какая организация лучше подходит для системы, в которую часто
добавляются новые типы? Какая для системы, где часто появляются новые операции?

Ответ:
Для стиля, управляемого данными потребуется просто вносить новые
процедуры и типы в таблицу. При модели передачи сообщений нужно будет
дополнять сами процедуры изнутри, дописывать код. Грубо говоря, если у
нас процедура рассчитывает работать с треугольником, кругом и овалом, то
при попытке передать ей в качестве типа квадрат, мы натолкнемся на
ошибку, чтоб ее избежать придется добавить еще один ~if~. В случае с
явной диспетчеризацией, т.е. я так понимаю, идет речь о разделе про
помеченные данные в мане, придется просто писать новые процедуры.

Я думаю, что в случае с расширяющейя системой, не важно чаще ли в ней
добавляются типы или операции, больше подходит стиль, управляемый
данными, поскольку добавить что-то в таблицу значительно проще, чем
переписывать уже существующий код или писать его заново.

~Упражнение 2.77.~
Хьюго Дум пытается вычислить выражение (magnitude z), где z — объект,
показанный на рис. 2.24.
К своему удивлению, вместо ответа 5 он получает сообщение об ошибке от apply-
generic, гласящее, что у операции magnitude нет методов для типа
(complex). Он показывает результат Лизе П. Хакер. Та заявляет:
"Дело в том, что селекторы комплексных чисел для чисел с меткой complex
определены не были, а были только для чисел с меткой polar
и rectangular.
Все, что требуется, чтобы заставить это работать — это добавить к пакету
complex следующее:"

#+BEGIN_SRC scheme

  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'angle '(complex) angle)

#+END_SRC
Подробно опишите, почему это работает. В качестве примера, проследите все
процедуры, которые вызываются при вычислении (magnitude z), где z —
объект, показанный на рис. 2.24. В частности, сколько раз вызывается
apply-generic? На какую процедуру она диспетчирует в каждом случае?

Ответ:
Это в человек может увязать, что раз операции написаны для типов ~polar~ и
~rectangular~, то и для типа complex эти операци должны сработать, ведь
~polar~ и ~rectangular~ - это всего дишь 2 варианта представления типа
complex, как декартовая форма или полярная форма - это форма
представления комплексных чисел. Но компьютер об этом ничего не знает,
соответственно,нужно прямо указать, что данные операции подходят и для
типа complex.

Так выглядит процедура magnitude в разделе 2.4.3.
#+BEGIN_SRC scheme

  (define magnitude z) (apply-generic 'magnitude z))

#+END_SRC

При ее вызове ~(magnitude z)~, где z - это объекст типа ~complex~,
происходит следующее: сначала ~apply-generic~ ищет в таблице
операцию ~magnitude~, которая работает с типом ~complex~. В этой ячейке
теперь не пусто, там содержится сама процедура magnitude. Мы помним, что
у нас двухуровневая диспетчеризация: за уровнем complex есть 2 возможных
варианта: polar или rectangular. На рисунке 2.24 указан тип
~rectangular~. Следовательно, мы теперь применяем найденную в ячейке с
пометкой ~'magnitude 'complex~ процедуру ~magnitude~ к типу
~rectangular~. ~apply-generic~ ищет по таблице второй раз (но уже на уровень
ниже) и применяет вариант magnitude для декартового представления
комплексных чисел.

~Упражнение 2.78.~
В пакете ~scheme-number~ внутренние процедуры, в сущности, ничего не
делают, только вызывают элементарные процедуры +, -, и т.д. Прямо
использовать примитивы языка не было возможности, поскольку наша система
меток типов требует, чтобы каждый объект данных был снабжен меткой.
Однако на самом деле все реализации Лиспа имеют систему типов, которую
они используют внутри себя.
Элементарные процедуры вроде symbol? или number? определяют,
относится ли объект к определенному типу. Измените определения type-tag, contents и
attach-tag из раздела 2.4.2 так, чтобы наша обобщенная система использовала внутреннюю
систему типов Scheme.
То есть, система должна работать так же, как раньше, но только обычные
числа должны быть представлены просто в виде чисел языка Scheme, а не в виде пары, у
которой первый элемент символ ~scheme-number~.

Формально одниих предикатов number? и symbol? недостаточно, для
нормальной типизации: number? возвраает t и на дробные числа тоже, а
не только на обычные. А для рациональных чисел есть пакет, котоый не
будет работать если данные не помечены как 'rational. Так что хоррошо бы
иметь предикаты, определяющие, целое число перед нами или нет. Но таковых
пока не дано, так что мой вариант решения:

#+BEGIN_SRC scheme

  ;; исходный вариант
  ;;  помечивает данные
  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  ;; получает тип данных
  (define (type-tag datum)
    (if (pair? datum)
        (car datum)
        (error "Некорректные помеченные данные -- TYPE-TAG" datum)))

  ;; получает содержимое
  (define (contents datum)
    (if (pair? datum)
        (cdr datum)
        (error "Некорректные помеченные данные -- CONTENTS" datum)))

  ;; новый вариант
  (define (attach-tag type-tag contents)
    (if (number? contens)
        contens
        (cons type-tag contents)))

  ;; распознает тип данных (может работать только с числами или символами)
  (define (type-tag datum)
    (cond ((pair?  datum) (car datum))
          ((symbol?  datum) 'symbol)
          ((number?  datum) 'number))
    (else (error "Некорректные помеченные данные -- TYPE-TAG" datum)))

  (define (contents datum)
    (cond ((pair? datum) (cdr datum))
          ((not (pair? datum)) datum)
          (else (error "Некорректные помеченные данные -- CONTENTS" datum))))
#+END_SRC

~Упражнение 2.79.~
Определите обобщенный предикат равенства equ?, который проверяет два
числа на равенство, и вставьте его в пакет обобщенной арифметики.
Операция должна работать для обычных чисел, рациональных и комплексных.

#+BEGIN_SRC scheme

  (define (equ? n1 n2)
    (equal? n1 n2))

  (put 'equ '(complex complex) equ)
  (put 'equ '(rational rational) equ)
  (put 'equ '(scheme-number scheme-number) equ)

  ;; другое воплощение из частично подсмотренного варианта
  (define (equ? n1 n2)
    (apply-generic 'equ n1 n2))

  (define (equ-complex? n1 n2)
    (if (and (= (real-part n1) (real-part n1))
             (= (imag-part n1) (imag-part n2)))
        #t
        #f))

  (define (equ-rational? n1 n2)
    (if (and (= (denom n1) (denom n1))
             (= (numer n1) (numer n2)))
        #t
        #f))

  (put 'equ? '(complex complex) equ-complex?)
  (put 'equ? '(rational rational) equ-rational?)
  (put 'equ? '(scheme-number scheme-number) =)

#+END_SRC

~Упражнение 2.80.~
Определите обобщенный предикат =zero?, который проверяет, равен ли его
аргумент нулю, и вставьте его в пакет обобщенной арифметики.
Предикат должен работать для обычных, рациональных и комплексных чисел.

#+BEGIN_SRC scheme
  (define (=zero? n)
    (apply-generic '=zero? n))

  (define (zero-complex? n)
    (if (and (= 0 (real-part n))
             (= 0 (imag-part n)))
        #t
        #f))

  (define (zero-rational? n)
    (if (and (= 0 (denom n) (= 0 (numer n))))
        #t
        #f))

  (put '=zero? '(complex) zero-complex?)
  (put '=zero? '(rational) zero-rational?)
  (put '=zero? '(scheme-number) (lambda (n) (= 0 n)))
#+END_SRC

~Упражнение 2.81.~
Хьюго Дум заметил, что apply-generic может пытаться привести аргументы к
типу друг друга даже тогда, когда их типы и так совпадают.
Следовательно, решает он, нам нужно вставить в таблицу приведения
процедуры, которые «приводят» аргументы каждого типа к нему самому.
Например, в дополнение к приведению scheme-number->complex, описанному
выше, он бы написал еще:

#+BEGIN_SRC scheme
  (define (scheme-number->scheme-number n) n)

  (define (complex->complex z) z)

  (put-coercion 'scheme-number 'scheme-number
                 scheme-number->scheme-number)
  (put-coercion 'complex 'complex complex->complex)
#+END_SRC

а. Если установлены процедуры приведения типов, написанные Хьюго, что
произойдет, когда apply-generic будет вызвана с двумя аргументами типа
scheme-number или двумя аргументами типа complex для операции, которая не
находится в таблице для этих типов?
Допустим, например, что мы определили обобщенную процедуру возведения в
степень и добавили процедуру возведения в степень в пакет чисел Scheme и
ни в какой другой:

#+BEGIN_SRC scheme
  (define (exp x y) (apply-generic 'exp x y))

  ;; Следующие строки добавляются в пакет scheme-number
  (put 'exp '(scheme-number scheme-number)
        (lambda (x y) (tag (expt x y)))) ;; используется элементарная expt
#+END_SRC

Что произойдет, если мы позовем exp с двумя комплексными числами в
качестве аргументов?

Ответ:
У нас есть таблица приведения типов, где часть ячек - пустая, поскольку
невозможно привести объкт произвольного типа ко всем остальным типам. В
этой таблице ячейки проиндексированы типами, а содержимое их - операции,
по приведению одного типа в другой.

Новый вид apply-generic:
#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                  (let ((t1->t2 (get-coercion type1 type2))
                        (t2->t1 (get-coercion type2 type1)))
                    (cond (t1->t2
                           (apply-generic op (t1->t2 a1) a2))
                          (t2->t1
                           (apply-generic op a1 (t2->t1 a2)))
                          (else
                           (error "Нет метода для этих типов"
                                  (list op type-tags))))))
                (error "Нет метода для этих типов"
                       (list op type-tags)))))))
#+END_SRC

сейчас apply-generic работает по следующему принципу: получив 2
аргумента, ищет в таблице типов операцию для них. Если таковой нет, то
пробует привести аргумент пераого типа к аргументу второго и ищет
операцию снова. Если это не сработало, то пытается привести второй
аргумент к типа первого и опять ищет. Если и это не прокатило, то выдает
сообщение об ошибке.

Если установлены процедуры приведения типов, написанные Хьюго, то, когда
apply-generic будет вызвана с двумя аргументами типа scheme-number или
двумя аргументами типа complex для операции, которая не находится в
таблице для этих типов, apply-generic сначала попытается привести типы к
самим себе, затем пройдет по описанному выше сценарию, преджде чем выдать
сообщение об ошибке.
Посмотрим на обобщенную процедуру exp: внутри нее та же
apply-generic. Значит при вызове exp apply-generic приведет типы к самим
себе и вернемся к тому, с чего начали: к приведению типов. exp зациклится
навечно.

б) б. Прав ли Хьюго, что нужно что-то сделать с приведением однотипных
аргументов, или все и так работает правильно?

Ответ: конечно, прав. Какой смысл приводить типы аргументов друг к другу,
если они одинаковые? Только время тратить. В этом случае имеет смысл
поискать, для каких типов существует желаемая операция, и попробовать
привести типы аргументов к нужным.

в. Измените apply-generic так, чтобы она не пыталась применить
приведение, если у обоих аргументов один и тот же тип.

#+BEGIN_SRC scheme
  (define (apply-generic op . args)
    (let ((type-tags (map type-tag args)))
      (let ((proc (get op type-tags)))
        (if proc
            (apply proc (map contents args))
            (if (= (length args) 2)
                (let ((type1 (car type-tags))
                      (type2 (cadr type-tags))
                      (a1 (car args))
                      (a2 (cadr args)))
                  (if (equal? type1 type2)
                      (error "Нет метода для этих одинаковых типов" (list op type-tags))
                  (let ((t1->t2 (get-coercion type1 type2))
                        (t2->t1 (get-coercion type2 type1)))
                    (cond (t1->t2
                           (apply-generic op (t1->t2 a1) a2))
                          (t2->t1
                           (apply-generic op a1 (t2->t1 a2)))
                          (else
                           (error "Нет метода для этих типов"
                                  (list op type-tags)))))))
                (error "Нет метода для этих типов"
                       (list op type-tags)))))))
#+END_SRC


~Упражнение 2.82.~
Покажите, как обобщить apply-generic так, чтобы она обрабатывала
приведение в общем случае с несколькими аргументами. Один из способов
состоит в том, чтобы попытаться сначала привести все аргументы к типу
первого, потом к типу второго, и так далее. Приведите пример,
когда эта стратегия (а также двухаргументная версия, описанная выше)
недостаточно обща. (Подсказка: рассмотрите случай, когда в таблице есть
какие-то подходящие операции со смешанными типами, но обращения к ним не произойдет.)

Нам нужны суб-процедуры:
1. ~change-types~ будет приводить все аргументы к указанному типу, усли это
   возможно. Если привести не удалось, возвращаем фолс, иначе возвращаем
   список
2. ~get-type~ получит тип из списка типов. У нас есть 2 списка: в одном
   аргуметы, в другом их типы. Между этими типами есть строгое
   соответствие: первый элемент из списка типов соответствует первому
   элементу из списка аргументов и т.д. Передавая индекс в ~get-type~ мы
   гвоорим, тип какого аргумента хотим получить. Чтоб затем передать его
   в ~change-types~ и привести остальные аргументы к нему.
3. Внутренняя процедур ~iter~ получает на вход индекс, операцию,
   аргументы и их типы.
   Сначала ~iter~ попытается найти операцию для текущих аргументов и
   типов. Если нашли, то операция применяется, в противном случае мы
   пытаемся привести все аргументы к типу первого аргумента, второго и
   т.д. пока либо не дойдем до конца списка аргументов, либо не найдем
   подходящую операцию.

К сожалению, если последовательно приводить все аргументы к указанному
типу, то мы никогда не найдем операции в таблице, которые работают со
смешанными типами, поскольку типы наших аргументов всегда будут
оказываться одинаковыми, если приведение к указанному типу возможно.

#+BEGIN_SRC scheme
  (define (numer x) (car x))

  (define (denom x) (cdr x))

  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))

  (define (attach-tag type-tag contents)
    (cons type-tag contents))

  (define (type-tag datum)
    (if (pair? datum)
        (car datum)
        (error "Некорректные помеченные данные -- TYPE-TAG" datum)))

  (define (contents datum)
    (if (pair? datum)
        (cdr datum)
        (error "Некорректные помеченные данные -- CONTENTS" datum)))

  ;; примитивная реализация get-coertion. В мане не дано ее определение,
  ;; используется для поиска операций с приведением типов, здесь эмулируется то же самое
  ;; поведение. Переводит обычные числа в рациональные и наоборот.
  (define (get-coercion t1 t2)
    (cond ((and (equal? t1 'rational) (equal? t2 'scheme-number))
           (lambda (n) (make-rat n 1)))
          ((and (equal? t1 'scheme-number) (equal? t2 'rational))
           (lambda (x)
             (/ (+ (numer x) 0.0) (+ (denom x) 0.0))))
          (else #f)))

  ;; принимает тип, к которому нужно привести все аргументы,
  ;; типы аргументов и сами аргументы
  ;; если удалось все аргументы привести к указанному типу, возвращает
  ;; список приведенных к типу аргументов
  (define (change-types type types args)
    (define (iter type types args results)
      ;;аргументы кончились?
      (if (null? args)
          ;; вернуть результаты
          (reverse results)
          ;; инече попытатся найти операцию по приведению типов
          (let ((t1->t2 (get-coercion type (car types))))
            ;; нашли операцию?
            (if t1->t2
                ;; да, приводим к типу аргумент и идем на след. круг
                (iter type (cdr types) (cdr args) (cons (attach-tag
                                                         type
                                                         (t1->t2 (car args))) results))
                ;; такой операции нет, приведение к типу невозможно
                #f))))
    (format #t "change-types: type ~A\n" type)
    (iter type types args '()))

  ;; тесты
  ;; (change-types 'rational (list 'scheme-number 'scheme-number 'scheme-number
  ;;                               'scheme-number)
  ;;               (list 18 34 878 6567))

  ;; (change-types 'scheme-number (list 'rational 'rational 'scheme-number)
  ;;               (list (make-rat 3 6) (make-rat 12 8) 18))

  ;; (define (get op types)
  ;;   (define (check-types type list)
  ;;     (cond ((null? list) #t)
  ;;           ((equal? type (car list)) (check-types type (cdr list)))
  ;;           (else #f)))
  ;;   (cond ((and (equal? 'add op) (check-types 'scheme-number types))
  ;;          +)
  ;;         ((and (equal? 'sub op) (check-types 'scheme-number types))
  ;;         -)
  ;;         (else #f)))


  ;; получает тип из списка типов по индексу
  ;; нужена, чтоб получить тип первого аргумента, второго и т.д.
  (define (get-type indx types-lst)
    (cond ((or (>= indx (length types-lst)) (< indx 0)) #f)
          ((= indx 0) (car types-lst))
          (else (get-type (- indx 1) (cdr types-lst)))))

  (get-type 3 (list 'a 'b 'c 'd))


  (define (apply-generic op . args)
    (define (iter op indx type-tags args)
      ;; если индекс больше длины списка, значит мы привели все аргменты к типу последнего,
      ;; но так ничего и не нашли
      (if (>= indx (length args))
          (error "Нет метода для этих типов"
                 (list op type-tags))
          ;; иначе получаем текущие типы аргументов
          (let* ((cur-types (map type-tag args))
                 ;; ищем операцию для них
                 (proc (get op cur-types)))
            ;; операция найдена?
            (if proc
                ;; да, применим ее
                (apply proc (map contents args))
                ;; иначе пытаемся привести типы к типу аргумента на текущем индексе в списке
                (let ((new-args (change-types (get-type indx type-tags) cur-types args)))
                  ;; приведение типов удалось?
                  (if new-args
                      ;; да, вызываем iter с обновленным состояним аргументов
                      (iter op (+ indx 1) type-tags new-args)
                      ;; нет, вызываем iter с текущим представлением аргументов
                      (iter op (+ indx 1) type-tags args)))))))
    (let ((type-tags (map type-tag args)))
      (iter op 0 type-tags args)))
#+END_SRC

~Упражнение 2.83.~
Предположим, что Вы разрабатываете обобщенную арифметическую систему для
работы с башней типов, показанной на рис. 2.25: целые, рациональные, действительные,
комплексные. Для каждого из типов (кроме комплексного), разработайте
процедуру, поднимающую объект на один уровень в башне. Покажите, как
ввести обобщенную операцию raise, которая будет работать для всех типов
(кроме комплексных чисел).

Итак, нам понадобятся операции для приведения типов, которые будут
лежать в таблице типов:
scheme-number->rational
rational->real
real->complex

Для создания ~raise~ я не воспользовалась ~apply-generic~ поскольку:
операция ~get~ не найден ничего в таблице операций, поскольку приведение
типов - это отдельная таблица. А ~get-coertion~, которая приводит типы в
apply-generic, нуждается в двух аргументах: тип, который приводим, и тип,
к которому приводим. Но поскольку процедуру ~raise~ я оформляю в виде
черного ящика, я не хочу, чтоб пльзователь думал, какой там тип
в иерархии типов стоит над текущим, и указывал его как второй аргумент
~get-coertion~. Идея в том, чтоб пользователь просто ввел аргумент, а на
выходе получил обновленное состояние аргумента, если это
возможно. Поэтому ~raise~ выглядит так громоздко.

#+BEGIN_SRC scheme
  (define (scheme-number->rational n)
    (attach-tag 'rational (make-rat (contents n) 1)))

  ;; поскольку мы знаем, что действительные числа - это все числа, которые можно записать
  ;; конечной или бесконечной дробью, то нам никак не надо менять рациональную дробь,
  ;; ведь она тоже действительное число. Просто присвоим ей тип
  (define (rational->real n)
    (attach-tag 'real (contents n)))

  (define (real->complex n)
    (make-complex-from-real-imag (contents n) 0))

  ;; положим все операции в воображаемую таблицу по приведению типов
  (put-coertion 'scheme-number 'rational scheme-number->rational)
  (put-coertion 'rational 'real rational->real)
  (put-coertion 'real 'complex real->complex)

  ;; предположим, что аргумент всего 1
  (define (raise arg)
    (let ((type-tag (type-tag arg)))
      (cond ((equal? (car type-tags) 'scheme-number)
             (get-coertion (car type-tags) 'rational))
            ((equal? (car type-tags) 'rational)
             (get-coertion (car type-tags) 'real))
            ((equal? (car type-tags) 'real)
             (get-coertion (car type-tags) 'complex))
            (else #f))))

  ;; есть более элегантный подсмотренный вариант
  ;; суть в том, чтоб получить недостающий аргумент - тип, к котоому надо привести -
  ;; из таблицы операций
  (define (raise obj)
    (let* ((type-tag (type-tag obj))
           (supertype (get 'raise type-tag)))
      (if supertype
          ((get-coercion type-tag supertype) obj)
          obj)))

  ;; чтоб использовать этот ваиант, нужноп оложить raise в таблицу операций
  ;; (косяк этого варианта в том, что таблица операций предполагает, что внутри ее ячеек
  ;; лежат операции, а не символы, так мы нарушаем логику таблицы операций)
  (put 'raise 'scheme-num 'rational)
  (put 'raise 'rational 'real)
  (put 'raise 'real 'complex)
#+END_SRC

~Упражнение 2.84.~
Используя операцию raise из упражнения 2.83, измените процедуру
apply-generic так, чтобы она приводила аргументы к одному типу путем
последовательного подъема, как описано в этом разделе.
Потребуется придумать способ проверки, какой из двух типов выше по башне. Сде-
лайте это способом, «совместимым» с остальной системой, так, чтобы не
возникало проблем при добавлении к башне новых типов.

Как я понимаю это задание:
Итак, есть башня типов. Есть список аргументов у apply-generic, который
может быть любой длины. Нам нужно узнать, какой у нас есть самый
"высокий" тип аргумента из представленных, а затем последовательно
поднять по башне типов все остальные аргументы до самого высокого.
При этом это нельзя сделать кустарным способом, вроде, "если самый
высокий тип такой-то, то делаем то-то".
Самое главное - это придумать, как определить какой тип выше по башне,
при это сделать это так, чтоб при добавлении нового типа ничего не
пришлось менять.

Вариант: присвоить типам числовые идентфикаторы. Чем идентификтор больше,
тот по иерархии выше.

Предположим, задать башню типов списком. Индексируем каждый элемент
списка он 0 до n. Берем тип первого аргумента, проходимся по башне
типов. При совпадении получаем индекс типа, сохраняем. Берем тип второго
аргумента, проходимся по башне. Находим его индекс. Если его индекс
больше предыдущего, обновляем индекс. Повторяем до тех пор, пока не
обойдем весь список аргументов.

Этим займется процедура ~get-highest-type~ которая вернет нам числовой
идентификатор самого "высокого" типа из представленных типов аргументов.

Будем вызывать ~raise~ для каждого аргумента до тех пор, пока
идентификаторы всех ргументов не сравняются с заданным. Т.е. пока все
типы не поднимутся до исходного.

- получаем идентификатор самого высокого типа в иерархии.
- проходимся по списку аргументов, если идентификаторы типов аргументов
  совпадают, не вызываем raise. Иначе вызываем raise до тех пор, пока
  идентификатор тип аргумента не сравняется с заданным.
- продолжаем до тех пор, пока не дойдем до конца списка аргументов
- после этого вызываем заданную операцию для аргументов

#+BEGIN_SRC scheme
  (define types-tower (list 'a 'b 'c 'd))

  (define types-args (list 'c 'c 'a 'd 'c))

  ;; возвращает числовой идентификатор типа, если тип есть в башне
  ;; иначе #f
  (define (get-ident-of-type type types-tower)
    (define (iter type types-tower indx)
    (cond ((null? types-tower) #f)
          ((equal? type (car types-tower)) indx)
          (else (iter type (cdr types-tower) (+ 1 indx)))))
    (iter type types-tower 0))
  ;; возвраает идентификатор самого высокого типа из представленных в списке аргументов
  (define (get-highest-type types-args types-tower)
    (define (iter types-args types-tower ident)
      (if (null? types-args)
          ident
          (let ((cur-ident (get-ident-of-type (car types-args) types-tower)))
            (if (not cur-ident)
                #f
                (if (> cur-ident ident)
                    (iter (cdr types-args) types-tower cur-ident)
                    (iter (cdr types-args) types-tower ident)))))
      (iter  types-args types-tower 0)))

  ;; (get-highest-type types-args types-tower)

  ;;применяет процедуру raise заданное кол-во раз
  (define (iter-raise arg n types-tower)
    (if (= 0 n)
        arg
        (iter-raise (raise arg) (- n 1) types-tower)))

  (define (apply-generic op . args)
    (define (raise-all-args args ident-type new-lst)
      ;; если аргументы кончились или у нас нет идентификатора самого высокого типа
      (if (or (not ident-type) (null? args))
          ;; возвращаем пустой список
          new-lst
          ;; иначе получаем идентификатор типа текущего аргумента
          (let ((cur-type-ident (get-ident-of-type (type-tag (car args)) types-tower)))
            ;; если он меньше идентификатора самого высокого в иерархии типа
            (if (< cur-type-ident ident-type)
                ;; повышаем аргумент в иерархии заданное кол-во раз и идем к след. аргументу
                (cons (iter-raise (car args) (- ident-type cur-type-ident) types-tower)
                      (raise-all-args (cdr args) ident-type new-lst))
                ;; иначе оставляем аргумент как есть и к след. аргументу
                (cons (car args) (raise-all-args (cdr args) ident-type new-lst))))))
    ;; получаем список типов исходных аргументов
    (let* ((types-args (map type-tag args))
           ;; получаем новые аргументы, поднятые до заданного типа в иерархии типов
           (new-args (raise-all-args args (get-highest-type types-args types-tower) '())))
      ;; если получили новые аргументы
      (if new-args
          ;; получаем их типы
          (let* ((new-types-args (map type-tag new-args))
                 ;; ищем для них операцию
                 (proc (get op new-types-args)))
            ;; если нашли операцию
            (if proc
                ;; применяем ее
                (apply proc (map contents new-args))
                ;; иначе сообение об ошибке
                (error "Нет метода для этих типов"
                       (list op new-types-args))))
          ;; если новые аргументы получены не были, выдаем сообщение об ошибке
          (error "Не удалось обработать данные аргументы:
                  возможно, аргументы имею не указанные в башне типы"
                 (list op types-args))
          )))
#+END_SRC
~Упражнение 2.85.~
В этом разделе упоминался метод «упрощения» объекта данных путем спуска
его по башне насколько возможно вниз. Разработайте процедуру drop, которая делает это
для башни, описанной в упражнении 2.83. Ключ к задаче состоит в том,
что надо решить некоторым общим способом, можно ли понизить объект в
типе. Например, комплексное число 1.5+0i можно опустить до real,
комплексное число 1 + 0i до integer, а комплексное число 2 + 3i никуда
понизить нельзя. Вот план того, как определить, можно ли понизить объект: для начала
определите обобщенную операцию project, которая «сталкивает» объект вниз
по башне.
Например, проекция комплексного числа будет состоять в отбрасывании его
мнимой части.
Тогда число можно сдвинуть вниз в том случае, если, спроецировав его, а
затем подняв  обратно до исходного типа, мы получаем нечто, равное
исходному числу.
Покажите как реализовать эту идею в деталях, написав процедуру drop,
которая опускает  объект как можно ниже. Потребуется разработать
различные операции проекции и установить project в системе в качестве
обобщенной операции. Вам также потребуется обобщенный предикат равенства,
подобный описанному в упражнении 2.79. Наконец, используя drop,
перепишите apply-generic из упражнения 2.84, чтобы она «упрощала» свои результаты.

Предположим, у нас есть пакеты, которые работают с целыми числами и
действительными (возможно, тип scheme-number - это и есть тип для
действительных чисел,в мане числа этого типа автор называет обычными
числами)

- прежде чем опустить число вниз по башне, сохранить исходное
- для комплексного числа: комплексное->действительное и
  комплексное->целое
- для действительных: действительное-> рациональное и
  действительное->целое
- для рациональных: рациональное->целое

план ~project~:
- принимает 1 аргумент
- опускает его ниже, запоминает нвоое значение
- сравнивает старое и новое значения
- если совпадает, возвращает новое значение
- если нет и нет альтернативы, возвращает исходный аргумент (так проще
  уберечься от ошибок)

#+BEGIN_SRC scheme
  ;; обобщенная операция проекции
  (define (project arg)
    (apply-generic 'project arg))

  ;; обобщенный предикат равенства
  (define (equ? n1 n2)
    (apply-generic 'equ n1 n2))

  ;; проверка комплексных чисел на равенство
  (define (equ-complex? n1 n2)
    (if (and (= (real-part n1) (real-part n1))
             (= (imag-part n1) (imag-part n2)))
        #t
        #f))
  ;; проверка действительных чисел на равенство
  ;; в данном задании мы нарочно будем считать, что действительные числа могут быть
  ;; представлены только в виде рациональной дроби или целого числа, т.к.
  ;; нет ни представления, для работы с десятичной дробью
  (define (equ-real? n1 n2)
    (if (and (integer? n1) (integer? n2))
        (equ-integer n1 n2)
        (equ-rational? n1 n2)))


  ;; проверка рациональных
  (define (equ-rational? n1 n2)
    (if (and (= (denom n1) (denom n1))
             (= (numer n1) (numer n2)))
        #t
        #f))

  ;; проверка целых
  (define (equ-integer n1 n2)
    (= n1 n2))

  (put 'equ? '(complex complex) equ-complex?)
  (put 'equ? '(rational rational) equ-rational?)
  (put 'equ? '(scheme-number scheme-number) equ-integer)
  (put 'equ? '(real real) equ-real?)

  ;; будем считать, что действительные числа могут быть рациональными дробями или целыми
  ;;  но поскольку целые числа переводить уже некуда, то у нас остается только представление
  ;; действительных чисел в виде рациональных дробей, а значит, менять предс тавление
  ;; аргумента не надо, достаточно только изменить его тип
  (define (project-real arg)
    (make-rational (numer arg) (denom arg)))

  (define (project-complex arg)
    ;; если действительная часть комплексного числа - целое число
    (if (integer? (real-part arg))
        ;; пробуем перевести комплексное число в целое
        (let* ((complex->integer (real-part arg))
               (check (equ? (make-complex-from-real-imag complex->integer 0) arg)))
          ;; если удалось перевести,
          (if check
              ;; возвращаем новое значение аргумента
              (attach-tag 'integer complex->integer)
              #f))
        ;; если действительная часть комплексного числа не целое,
        ;; пробуем в перевести его в действительное число
        (let* ((complex->real (real-part arg))
               (check (equ? (make-complex-from-real-imag complex->real 0) arg)))
          (if check
              ;; возвращаем новое значение аргумента
              (attach-tag 'real complex->real)
              #f))))

  (define (project-rational arg)
    ;; переводим из рациональной дроби в целое число
    (let* ((rational->integer (numer arg))
           (check (equ? (make-rat rational->integer 1) arg)))
      ;; если проверка удалась
      (if check
          ;; возвращаем новое значение аргумента
          (make-rational rational->integer 1)
          #f)))

  ;; чтоб не возникало ошибок при ппопытке спустить вниз integer, введем эту процедуру
  (define (project-integer arg)
    (attach-tag 'integer arg))

  ;;кладем все оперции проекции в таблицу операций
  (put 'project 'complex project-complex)
  (put 'project 'rational project-rational)
  (put 'project? 'real project-real)
  (put 'project? 'integer project-integer)

  (define (drop arg)
    ;;узнаем тип аргумента
    (let* ((type (type-tag arg))
           ;; если есть оперция проекции для этого аргумента
           (op (get 'project type)))
      (if op
          ;; применям
          (apply op (contents arg))
          #f)))

#+END_SRC

Теперь надо переписать ~apply-generic~ так, чтоб она спускала свои
аргументы по башне типов, а не поднимала.

#+BEGIN_SRC scheme
  (define (apply-generic op .args)
    ;; функция спустит все аргументы вниз и вернет новый список аргументов
    (define (drop-all-args args new-list)
      (if (null? args)
          new-list
          (cons (drop (car arg)) (drop-all-args (cdr args) new-list))))
    ;; получаем исхожные типы аргументов
    (let* ((types-args (map type-tag args))
           ;; ищем для них заданную операцию
           (fn (get op types-args)))
      (if fn
          ;; применяем операцию, если нашли
          (apply fn (map contents args))
          ;; иначе спускаем все аргументы вниз, насколько возможно
          (let* ((new-args (drop-all-args args '()))
                 (new-types-args (map type-tag new-args))
                 (new-fn (get op new-types-args))))
          (if new-fn
              ;; применяем заданную операцию для нового представления аргументов,
              ;; если она существует
              (apply new-fn (map contents new-args))
              ;; иначе сообщение об ошибке
              (error "Нет метода для этих типов"
                     (list op types-tags))))))

#+END_SRC

~Упражнение 2.86.~
Допустим, нам хочется работать с комплексными числами, чьи действительные
и мнимые части, модули и аргументы могут быть обыкновенными числами, рациональными
числами либо любыми другими, какие нам захочется добавить к системе.
Опишите и реализуйте изменения в системе, которые потребуются, чтобы
добавить такую возможность. Вам придется определить операции вроде sine
(синус) и cosine (косинус), обобщенные на обыкновенные и рациональные
числа.

Речь идет о тригонометрическом представлении комплексных
чисел. Предположим, у нас есть координатная плоскость, где комплексное
число z находится в точке а,b. То есть мы берем действительную часть ~a~
и мнимую часть ~b~ находим точку по этим координатам и эта точка -
комплексное число ~z~. Но можно найти комплексное число ~z~ с помощью
угла, который получится, если проведем линию от ~z~ до начала координат
0,0. Согласно этой идее, ~a~ ~ будет выражаться как ~r*cosФ~,  ~b~ будет
выражаться как  ~r * sinФ~. r = это корень из а^2 + b^2, а фи - это угол
от радиус-вектора (линии, соединяющей начало координат и комплексное
число) и горизонтальной оси на комплексной плоскости.

Значит нам нужно понять, как получить синус и косинус угла фи, если у нас
числа ~a~ и  ~b~ могут быть абсолютно любыми.

К счастью, у нас в пакете коплексных чисел процедуры, которые работают с
тригонометрическим представлением комплексных чисел. Поэтому фи нам
считать не надо. Мы просто немного переопределим некоторые операции.

#+BEGIN_SRC scheme
  ;; обобщенные операции
  (define (sine n)
    (apply-generic 'sine n))

  (define (cosine n)
    (apply-generic 'cosine n))

  ;; кладем обобщенные операции в таблицу (можно потом добавить любые типы)
  (put 'sine '(scheme-number) (lambda (x) (tag (sin x))))
  (put 'cosine '(scheme-number) (lambda (x) (tag (cos x))))

  ;; для вычислений нам нужно уметь считать квадраты чисел и их квадратные корни
  (define (square x)
    (mul x x))

  (define (average x y)
    (div (add x y) 2.0))

  (define (sqrt x)
    (fixed-point (average-damp (lambda (y) (div x y)))
                 1.0))

  ;;добавлям к пакету комплексных чисел!
  ;; с учетом того, что теперь компоненты комплексного числа могут быть любыми числами,
  ;; то операции сложения, вычитания и т.д. внутри процедур, работаюих с комплексными
  ;; числами, должны быть обобщенными.
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
                         (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
                         (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
                       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
                       (sub (angle z1) (angle z2))))

  ;; добавляем к пакету для поляорного представления чисел!
  ;; соответственно, процедуры magnitude и angle используются из этого же пакета
  ;; не путать с одноименными операциями из другого пакета
  (define (real-part z)
    (mul (magnitude z) (cosine (angle z))))

  (define (imag-part z)
    (mul (magnitude z) (sine (angle z))))

  ;; добавляем к пакету для тригонометрического представления комплексных чисел
  ;; (фактически считаем magnitude и angle, только те работают уже с комплексным числом,
  ;; вытаскивая и него r и фи, а мы проводим обратную операцию, составляя из r и фи
  ;; комплексное число)
  (define (make-from-real-imag x y)
    (cons (sqrt (add (square x) (square y)))
          (atan y x)))

#+END_SRC

~шпаргалка для операций над многочленами~
#+BEGIN_SRC scheme
  (define (install-polynomial-package)
    ;; ВНУТРЕННИЕ ПРОЦЕДУРЫ
    ;; представление poly

    ;; создает полином (многочлен) как список из переменной и списка термов
    (define (make-poly variable term-list)
      (cons variable term-list))

    ;; проверяет, является ли аргумент переменной
    (define (variable? x) (symbol? x))

    ;; проверяет, являются ли 2 переменные одинаковыми
    (define (same-variable? v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))

    ;; получает переменную из полинома
    (define (variable p) (car p))
    ;;получает список термов из полинома
    (define (term-list p) (cdr p))


    ;; ПРЕДСТАВЛЕНИЯ ТЕРМОВ И СПИСКОВ ТЕРМОВ
    ;; создает терм как список из порядка и коэфициента
    ;; порядок трема - это то, в какой степени его переменная

    (define (make-term order coeff) (list order coeff))

    ;;возвращает порядок терма
    (define (order term) (car term))

    ;; возвращает коэфициент терма
    (define (coeff term) (cadr term))

    ;; добавляет терм к списку термов
    (define (adjoin-term term term-list)
      ;; коэфициент трема нулевой?
      (if (=zero? (coeff term))
          ;; да, не добавляем терм
          term-list
          ;; нет, добавляем терм
          (cons term term-list)))

    (define (the-empty-termlist) '())

    ;; получаем самый терм самого высокого порядка из списка термов
    ;; термы всегда отсортированны по их порядкам от бОльшего к меньшему
    (define (first-term term-list) (car term-list))

    ;; возвращает все термы, кроме терма в самым высоким порядком
    (define (rest-terms term-list) (cdr term-list))

    ;; проверяет список термов на наличие в нем термов
    (define (empty-termlist? term-list) (null? term-list))

    ;; складывает многочлены
    ;; наша система умеет работать только с многочленами, где только 1 переменная
    (define (add-poly p1 p2)
      ;; если переменная одна и таже в обоих полиномах
      (if (same-variable? (variable p1) (variable p2))
          ;; то создаем новый полином, куда копируем переменную
          ;; и складываем термы ддвух полиномов
          (make-poly (variable p1)
                     (add-terms (term-list p1)
                                (term-list p2)))
          ;; иначе сообщение об ошибке
          (error "Многочлены от разных переменных -- ADD-POLY"
                 (list p1 p2))))

    ;; умножает многочлены
    ;; механизм аналогичен процедуре выше, но только с умножением
    (define (mul-poly p1 p2)
      (if (same-variable? (variable p1) (variable p2))
          (make-poly (variable p1)
                     (mul-terms (term-list p1)
                                (term-list p2)))
          (error "Многочлены от разных переменных -- MUL-POLY"
                 (list p1 p2))))

    ;; процедура сложения термов
    ;; суть в том, чтоб сложить термы одинакового порядка, а если для текущего терма нет
    ;; терма с таким же порядком, просто добавляем его в новому списку термов
    (define (add-terms L1 L2)
      ;; если какой-то из списка термов пуст, возвращаем другой список термов
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            ;;иначе
            (else
             ;; получаем первые термы из спика ( они будут с самым высоким порядком)
             (let ((t1 (first-term L1)) (t2 (first-term L2)))
               ;; если порядок первого терма больше порядка второго терма
               (cond ((> (order t1) (order t2))
                      ;; добавляем первый терм к списку термов, который породит рекурсия
                      (adjoin-term
                       t1 (add-terms (rest-terms L1) L2)))
                     ;; аналогично, но только для второго терма
                     ((< (order t1) (order t2))
                      (adjoin-term
                       t2 (add-terms L1 (rest-terms L2))))
                     ;; если порядки термов равны
                     (else
                      ;; создаем новый терм с тем же порядком, что у исходных, но с суммой их
                      ;; коэфициентов, и добавляем его в список, порожденный рекурсией
                      (adjoin-term
                       (make-term (order t1)
                                  (add (coeff t1) (coeff t2)))
                       (add-terms (rest-terms L1)
                                  (rest-terms L2)))))))))

    ;; умножение термов
    ;; суть умножения термов в том, чтоб перемножить все термы первого списка
    ;; на все термы второго
    (define (mul-terms L1 L2)
      (if (empty-termlist? L1)
          (the-empty-termlist)
          ;; затем здесь исользовано сложение?
          (add-terms (mul-term-by-all-terms (first-term L1) L2)
                     (mul-terms (rest-terms L1) L2))))

    ;; эта процедура умножит текущий терм на все термы из предложенного списка
    (define (mul-term-by-all-terms t1 L)
      (if (empty-termlist? L)
          (the-empty-termlist)
          ;; получаем первый терм второго списка
          (let ((t2 (first-term L)))
            ;; добавляем новые термы
            (adjoin-term
             ;; складываем порядки, умножаем коэфициенты
             (make-term (add (order t1) (order t2))
                        (mul (coeff t1) (coeff t2)))
             ;; рекурсивно вызываем функцию с состатком списка термов пока список не кончится
             (mul-term-by-all-terms t1 (rest-terms L))))))

    ;; интерфейс к остальной системе
    (define (tag p) (attach-tag 'polynomial p))
    (put 'add '(polynomial polynomial)
          (lambda (p1 p2) (tag (add-poly p1 p2))))
    (put 'mul '(polynomial polynomial)
          (lambda (p1 p2) (tag (mul-poly p1 p2))))
    (put 'make 'polynomial
          (lambda (var terms) (tag (make-poly var terms))))
    'done)
#+END_SRC

~Упражнение 2.87.~
Установите ~=zero?~ для многочленов в обобщенный арифметический пакет. Это
позволит ~adjoin-term~ работать с многочленами, чьи коэффициенты сами по
себе многочлены.


Воспользуемся предикатом ~=zero?~ из упражнения 2.80, т.к. он прекрасно
отвечает нашим целям. Более того, позволяет нам иметь в качестве
коэфициентов не только целые числа и при добавлении любого другого
коэфициента, можно будет просто добавить еще один вариант предиката и
внести его в систему.

#+BEGIN_SRC scheme
  (define (=zero? n)
    (apply-generic '=zero? n))

  (define (zero-complex? n)
    (if (and (= 0 (real-part n))
             (= 0 (imag-part n)))
        #t
        #f))

  (define (zero-rational? n)
    (if (and (= 0 (denom n) (= 0 (numer n))))
        #t
        #f))

  (put '=zero? '(complex) zero-complex?)
  (put '=zero? '(rational) zero-rational?)
  (put '=zero? '(scheme-number) (lambda (n) (= 0 n)))
#+END_SRC


~Упражнение 2.88.~
Расширьте систему многочленов так, чтобы она включала вычитание
многочленов.
(Подсказка: может оказаться полезным определить обобщенную операцию смены
знака.)

процедура смены знака нужна, чтоб поменять все знаки у термов второго
полинома, т.к. если записать разность двух полиномов
(6x + 3y) - (7x + 9y) и опустить скобки, то согласно правилам, если перед
скобкой стоит минус, то при отбрасывании скобок все термы скобки поменяют
свой знак на противоположный.

Нужно вычесть термы одинакового порядка друг из друга. Если порядок терма
единственный в своем роде в данном выражении, то мы добавим его в новый
список термов с его текущим знаком.

#+BEGIN_SRC scheme
  ;; процедуры, меняющие знак у коэфициентов термов

  ;; для плотного представления термов
  (define (change-sign-dense terms-list)
    (define (iter terms-list new-lst)
      (cond ((null? terms-list) new-lst)
            ((= (car terms-list) 0)
             (cons (car terms-list) (iter (cdr terms-list) new-lst)))
            (else
             (cons (/ (car terms-list) -1.0) (iter (cdr terms-list) new-lst)))))
    (iter terms-list '()))

  ;; для разреженного
  (define (change-sign-sparse terms-list)
    (define (iter terms-list new-lst)
      (cond ((null? terms-list) new-lst)
            ((= (coeff (car terms-list)) 0)
             (cons (car terms-list) (iter (cdr terms-list) new-lst)))
            (else
             (cons (make-term (order (car terms-list))
                              (/ (coeff (car terms-list)) -1.0))
                   (iter (cdr terms-list) new-lst)))))
    (iter terms-list '()))

  (put 'change-sign 'dense change-sign-dense)
  (put 'change-sign 'sparse change-sign-sparse)

  (define (change-sign terms-lst)
    (apply-generic 'change-sign terms-lst))


  (define change-sign-dense-test '(1 2 0 3 -2 -5))

  ;; для корректного тестирования change-sign-sparse в интерпретатор должно быть залито:
  (define (coeff term) (cadr term))

  (define change-sign-sparse-test '((5 2) (4 3) (2 2) (0 -5)))

  ;; Для корректной работы процедур adjoin-terms и adjoin-terms-dense,используемых
  ;; в процедурах вычитания, нужно залить это в интерпритатор:

  (define (=zero? n)
    (= n 0))


#+END_SRC

Вариант для разреженного представления полиномов:
#+BEGIN_SRC scheme
  (define (sub-terms-sparse L1 L2)
    (define (iter L1 L2)
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            (else
             (let ((t1 (first-term L1)) (t2 (first-term L2)))
               (cond ((> (order t1) (order t2))
                      (adjoin-term
                       t1 (iter (rest-terms L1) L2)))
                     ((< (order t1) (order t2))
                      (adjoin-term
                       t2 (iter L1 (rest-terms L2))))
                     (else
                      (adjoin-term
                       (make-term (order t1)
                                  (- (coeff t1) (coeff t2)))
                       (iter (rest-terms L1)
                             (rest-terms L2)))))))))
    (iter L1 (change-sign-sparse L2)))

  (define L1-sparse '((3 1) (2 2) (0 -5)))
  (define L2-sparse '((4 4) (2 5) (0 -6)))

  (sub-terms L1-sparse L2-sparse)
#+END_SRC

Вариант для плотного представления полиномов.

#+BEGIN_SRC scheme
  ;; необходима для корректного добавления термов к списку термов плотного полинома
  (define (adjoin-term-dense term term-list)
    (if (=zero? (car term))
        term-list
        (append term term-list)))

  (define (sub-terms-dense L1 L2)
    (define (iter L1 L2)
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            (else
             (cond ((> (order (car L1) L1) (order (car L2) L2))
                    (adjoin-term-dense
                     (car L1) (iter (rest-terms L1) L2)))
                   ((< (order (car L1) L1) (order (car L2) L2))
                    (adjoin-term-dense
                     (car L2) (iter L1 (rest-terms L2))))
                   (else
                    (adjoin-term-dense
                     (make-term-dense (- (car L1) (car L2)))
                     (iter (rest-terms L1)
                           (rest-terms L2))))))))
    (iter L1 (change-sign-dense L2)))

#+END_SRC

Обобщенная процедура:

#+BEGIN_SRC scheme
  ;; кладем написанные процедуры в таблицу
  (put 'sub-terms '(dense dense) sub-terms-dense)
  (put 'sub-terms '(sparse sparse) sub-terms=sparse)

  (define (sub-terms .args )
    (apply-generic 'sub-terms args))
#+END_SRC

~Упражнение 2.89.~
Определите процедуры, которые реализуют представление в виде списка
термов, описанное выше как подходящее для плотных многочленов.

В мане нам сказано, что плотные полиномы - т.е. полиномы, в которых
большинство термов имеют НЕ нулевой коэфициент - удобно представлять в
виде списка коэфициентов вида '( 5 3 1 -2 -5). А порядок терма - это длин
списка, начинающегося с коэфициента этого терма, уменььшенная на 1.

Значит, все селекторы и конструкторы, определенные для разреженных
полиномов, надо определить и для плотных.

#+BEGIN_SRC scheme

  (define (make-term coeff) (list coeff))

  ;; вариант №1
  ;; плох тем, что нужно знать индекс терма в списке коэфициентов. А индекс - это уже почти
  ;; порядок терма
  (define (order idx-of-term term-list)
    (- (length term-list) idx-of-term))

  ;; вариант №2
  ;; плох тем, что если у двух термов окажутся одинаковые коэфиициенты, то
  ;; процедура венет порядок первого встретившегося терма с такми коэфициентом
  (define (order coeff term-list)
    (define (iter coeff term-list order)
      (cond ((null? term-list) #f)
            ((= (car term-list) coeff) order)
            (else (iter coeff (cdr term-list) (+ order 1)))))
    (iter coeff (reverse term-list) 0))

  ;; возвращает коэфициент терма
  (define (coeff term-order term-list)
    (if (>= term-order (length term-list))
        #f
    (list-ref (reverse term-list) term-order)))

  (define coeff-test '( 1 2 0 3 -2 -5))

  ;; (coeff 3 coeff-test)
  w;; (order -5 coeff-test)

  ;; эти процедуры годятся и для протного представления многочленов

  ;; получаем самый терм самого высокого порядка из списка термов
  ;; термы всегда отсортированны по их порядкам от бОльшего к меньшему
  (define (first-term term-list) (car term-list))

  ;; возвращает все термы, кроме терма в самым высоким порядком
  (define (rest-terms term-list) (cdr term-list))

  ;; проверяет список термов на наличие в нем термов
  (define (empty-termlist? term-list) (null? term-list))

#+END_SRC

~Упражнение 2.90.~
Допустим, что мы хотим реализовать систему многочленов, которая
эффективна как для плотных, так и для разреженных многочленов.
Один из способов это сделать заключается в том, чтобы разрешить в системе
оба типа представления. Ситуация аналогична примеру с комплексными
числами из раздела 2.4, где мы позволили сосуществовать декартову и полярному
представлению. Чтобы добиться этого, нам придется различать виды списков
термов и сделать операции над списками термов
обобщенными. Перепроектируйте систему с многочленами так, чтобы
это обобщение было реализовано.
Это потребует большого труда, а не только локальных изменений.

Возможно, одинаковые процедуры для 2х пакетов не стоило дублировать и
класть дважды в таблицу операций под разными типами, но с другой
стороны,вдруг появятся еще какие-то представления полиномов и для них
понадобятся другие операции?

#+BEGIN_SRC scheme
  ;; создаем пакет для плотного представления полиномов
  (define (install-dense-package)

    (define (make-term-dense coeff) (list coeff))

    (define (order-dense coeff term-list)
      (define (iter coeff term-list order)
        (cond ((null? term-list) #f)
              ((= (car term-list) coeff) order)
              (else (iter coeff (cdr term-list) (+ order 1)))))
      (iter coeff (reverse term-list) 0))

    (define (coeff-dense term-order term-list)
      (if (>= term-order (length term-list))
          #f
          (list-ref (reverse term-list) term-order)))

    (define (first-term-dense term-list) (car term-list))

    (define (rest-terms-dense term-list) (cdr term-list))

    (define (empty-termlist?-dense term-list) (null? term-list))

    (define (make-poly-dense variable term-list)
      (cons variable term-list))

    (define (variable?-dense x) (symbol? x))

    (define (same-variable?-dense v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))

    (define (variable-dense p) (car p))

    (define (term-list-dense p) (cdr p))

    (define (tag p) (attach-tag 'dense p))

    (put 'make-term tag make-term-dense)
    (put 'order tag order-dense)
    (put 'coeff tag coeff-dense)
    (put 'rest-terms tag rest-terms-dense)
    (put 'first-term tag first-term-dense)
    (put 'empty-termlist? tag empty-termlist?-dense)
    (put 'make-poly tag make-poly-dense)
    (put 'variable? tag variable?-dense)
    (put 'same-variable? tag same-variable?-dense)
    (put 'variable tag variable-dense)
    (put 'term-list tag term-list-dense)

    'done
    )

  ;; создаем пакет для разреженного представления полиномов

  (define (install-sparse-package)

    (define (make-term-sparse order coeff) (list order coeff))

    (define (order-sparse term) (car term))

    (define (coeff-sparse term) (cadr term))

    (define (first-term-sparse term-list) (car term-list))

    (define (rest-terms-sparse term-list) (cdr term-list))

    (define (empty-termlist?-sparse term-list) (null? term-list))

    (define (make-poly-sparse variable term-list)
      (cons variable term-list))

    (define (variable?-sparse x) (symbol? x))

    (define (same-variable?-sparse v1 v2)
      (and (variable? v1) (variable? v2) (eq? v1 v2)))

    (define (variable-sparse p) (car p))

    (define (term-list-sparse p) (cdr p))

    (define (tag p) (attach-tag 'sparse p))

    (put 'make-term tag make-term-sparse)
    (put 'order tag order-sparse)
    (put 'coeff tag coeff-sparse)
    (put 'rest-terms tag rest-terms-sparse)
    (put 'first-term tag first-term-sparse)
    (put 'empty-termlist? tag empty-termlist?-sparse)
    (put 'make-poly tag make-poly-sparse
    (put 'variable? tag variable?-sparse)
    (put 'same-variable? tag same-variable?-sparse)
    (put 'variable tag variable-sparse)
    (put 'term-list tag term-list-sparse)

    'done
    )

  ;; добавляем процедуры к уже существующим в пакете
  (define (install-polynomial-package)

    (define (make-poly  variable term-list)
      (apply-generic 'make-poly variable term-list))

    (define (variable?  x)
      ((apply-generic 'variable? type) x))

    (define (same-variable?  v1 v2)
      (apply-generic 'same-variable? v1 v2))

    (define (variable p)
      (apply-generic 'same-variable? p))

    (define (term-list p)
      (apply-generic 'term-list p))

    (define (coeff .args)
      (apply-generic 'coeff args))

    (define (order .args)
      (apply-generic 'order args))

    (define (first-term term-list)
      (apply-generic 'first-term term-list))

    (define (rest-terms term-list)
      (apply-generic 'rest-terms term-list))

    (define (empty-termlist? term-list)
      (apply-generic 'empty-termlist? term-list))

    ;; здесь идут определения не изменившихся процедур
    ;; <...>

    (put 'coeff 'polynomial coeff)
    (put 'order 'polynomial order)
    ;; кладем дальше прочие операции по лекалу
    ;; <...>

    'done)

#+END_SRC

~Упражнение 2.91~

Доопределить процедуру, которая делит два полинома один на другой.

Деление можно производить в столбик. А именно, разделим старший член
делимого на старший член делителя. В результате получится первый терм частного. Затем
умножим результат на делитель, вычтем получившийся многочлен из делимого
и, рекурсивно деля разность на делитель, получим оставшуюся часть
частного.
Останавливаемся, когда порядок делителя превысит порядок делимого, и
объявляем остатком то, что тогда будет называться делимым. Кроме того, если
когда-нибудь делимое окажется нулем, возвращаем ноль в качестве и
частного, и остатка.
Процедуру ~div-poly~ можно разработать, следуя образцу ~add-poly~ и
mul-poly. Процедура проверяет, одна ли и та же у многочленов переменная. Если это так,
div-poly откусывает переменную и передает задачу в div-terms, которая
производит операцию деления над списками термов. Наконец, div-poly
прикрепляет переменную к результату, который выдает div-terms.
Удобно сделать так, чтобы div-terms выдавала и частное, и остаток при
делении. Она может брать в качестве аргументов два терма и выдавать список, состоящий из
списка термов частного и списка термов остатка.

Итак, алгоритм деления:
- берем старший терм делимого и делим его на старший терм делителя,
  результат = первый терм частного. Умножаем результат на
  делитель. Получившееся произведение вычитаем из исходного
  полинома-делимого. Получившуюся разность снова делим на делитель и
  повторяем весь алгоритм. Итак до тех пор, пока порядок делителя не
  привысит порядок делимого и тогда возвращаем текущее делимое как
  остаток и получившийся список частных. Если же на какой-то итерации
  делимое стало нулем, возвращаем ноль и как частное, и как остаток.

Тестирования нет, посольку функция универсальна для обоих представлений
полиномов, т.е. нам нужны обобенные функции, которые мы не можем
использовать из-за отсутствия таблиц операций.
#+BEGIN_SRC scheme
  (define (div-terms L1 L2)
    ;; если делимое - пустой список
    (if (empty-termlist? L1)
        ;; возвращаем пустые списки как частное и как остаток
        (list (the-empty-termlist) (the-empty-termlist))
        ;; иначе получаем первые термы делимого и делителя
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          ;; если порядок делителя превышает порядок делимого
          (if (> (order t2) (order t1))
              ;; тогда возвращаем пустой список в качетсве частного и делимое в качестве
              ;; остатка
              (list (the-empty-termlist) L1)
              ;; иначе делим старший терм делимого на старший терм делителя
              (let ((new-c (div (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2))))
                (let ((rest-of-result
                       ;; рекурсивно вычисяем оставшуюся часть результата
                       ;; если коэфициент нулевой, значит, делимое превратится в 0
                       (if (=zero? new-c)
                           ;; возвращаем 0 как остаток и частное
                           (list 0 0)
                           ;; иначе
                           ;; умножаем текущее частное на делитель, вычитаем из делимого
                           ;; разность передаем в рекурсивный вызов как новое делимое
                           (div-terms (sub-terms L1 (mul-term-by-all-terms (make-term new-o new-c) L2))
                                      L2))))
                  ;; сформировать окончательный результат
                  ;; после выполнения рекурсии откатимся по стеку назад, так в переменных
                  ;; new-c и new-o окажутся самые первые значения частного, соединим их
                  ;; с оставшейся частью частного, так получим все частное целиком
                  (list (adjoin-term (make-term new-c new-o) (car rest-of-result))
                        ;; объединим частное и остаток в список
                        (cadr rest-of-result))
                  ))))))

  (define (div-poly poly1 poly2)
    (let ((var1 (variable poly1))
          (var2 (variable poly2)))
      ;; проверяем переменные на одинаковость
      (if (same-variable? var1 var2)
          ;; делим список термов один на другой
          (div-terms (term-list poly1) (term-list poly2))
          ;; иначе сообщение об ошибке
          (error "Переменные не одинаковые" var1 var2))))

#+END_SRC

~Упражнение 2.93.~
Модифицируйте пакет арифметики рациональных чисел, заставив его
пользоваться обобщенными операциями, но при этом измените make-rat,
чтобы она не пыталась сокращать дроби. Проверьте систему, применив
make-rational к двум многочленам, и получив рациональную функцию, сложите
ее с собой же, используя add.

#+BEGIN_SRC scheme
  (define (install-rational-package)
    ;; внутренние процедуры
    (define (numer x) (car x))
    (define (denom x) (cadr x))
    ;; просто создаем пару из числителя и знаменателя, раз теперь не надо сокраать дроби
    (define (make-rat n d)
      (list n d))
    ;; в качестве арифметических предикатов будем использовать обобщенные операции
    (define (add-rat x y)
      (make-rat (add (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
                (mul (denom x) (denom y))))
    (define (sub-rat x y)
      (make-rat (sub (mul (numer x) (denom y))
                   (mul (numer y) (denom x)))
                (mul (denom x) (denom y))))
    (define (mul-rat x y)
      (make-rat (mul (numer x) (numer y))
                (mul (denom x) (denom y))))
    (define (div-rat x y)
      (make-rat (mul (numer x) (denom y))
                (mul (denom x) (numer y))))
    ;; интерфейс к остальной системе
    (define (tag x) (attach-tag ’rational x))
    (put 'add '(rational rational)
          (lambda (x y) (tag (add-rat x y))))
    (put 'sub '(rational rational)
          (lambda (x y) (tag (sub-rat x y))))
    (put 'mul '(rational rational)
          (lambda (x y) (tag (mul-rat x y))))
    (put 'div '(rational rational)
          (lambda (x y) (tag (div-rat x y))))
    (put 'make 'rational
          (lambda (n d) (tag (make-rat n d))))
    ’done)

  (define (make-rational n d)
    ((get 'make 'rational) n d))


  ;; ради теста эмулируем необхдимые процедуры, чтоб не пользоваться таблицами операций
  ;; настоятельно рекомендуется залить в интерпретатор все функции из раздела
  ;; "шпаргалкадля операций над многочленам"
  (define (make-rational n d)
    (make-rat n d))

  (define (make-polynomial var terns)
    (make-poly var terns))

  ;; определим тестовые примеры
  (define p1 (make-polynomial 'x '((2 1)(0 1))))
  (define p2 (make-polynomial 'x '((3 1)(0 1))))
  (define rf (make-rational p2 p1))
#+END_SRC

Предположим, нам удалось сложить rf с самой собой, и мы увидели, что
процедура сложения не сократила дробь. Чтоб это сделать, надо
модифицировать ~make-rat~, чтоб онв делила числитель и знаменатель на их
наиобльший общий делитель (НОД). Алгоритм Евклида сработает и для
многочленов.

#+BEGIN_SRC scheme
  ;; версия для целых чисел
  (define (gcd-integer a b)
    (if (= b 0)
        a
        (gcd-integer b (remainder a b))))

  ;; версия для термов
  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (remainder-terms a b))))

  ;; модицифицированная версия make-rat
  (define (make-rat n d)
    (let ((g (gcd-terms n d)))
      (cons (/ n g) (/ d g))))
#+END_SRC

~Упражнение 2.94.~
Используя ~div-terms~, напишите процедуру ~remainder-terms~, и с ее помощью
определите ~gcd-terms~, как показано выше. Напишите теперь процедуру ~gcd-polys~,
которая вычисляет НОД двух многочленов.
(Процедура должна сообщать об ошибке, если входные объекты являются
многочленами от разных переменных.) Установите в систему обобщенную
операцию greatest-common-divisor, которая для многочленов сводится к gcd-poly, а для
обыкновенных чисел к обыкновенному gcd.

Процедура ~div-terms~ определена в упр. 2.91 и возвращает список, ~car~
которого - частное от деления термов, а ~cdr~ - остаток от деления.

Нас просят протестировать пример, но без функционирующей таблицы операций
это не сделать.

#+BEGIN_SRC scheme
  ;; возвращает остаток от деления термов друг на друга
  (define (remainder-terms L1 L2)
    (cadr (div-terms L1 L2)))

  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (remainder-terms a b))))

  (define (gcd-polys poly1 poly2)
    (let ((var1 (variable poly1))
          (var2 (variable poly2)))
      ;; проверяем переменные на одинаковость
      (if (same-variable? var1 var2)
          ;; делим список термов один на другой
          (gcd-terms (term-list poly1) (term-list poly2))
          ;; иначе сообщение об ошибке
          (error "Переменные не одинаковые" var1 var2))))

  (define (gcd-integer a b)
    (if (= b 0)
        a
        (gcd-integer b (remainder a b))))

  ;; положим обе функции в таблицу операций
  (put 'gcd '(integer integer) gcd-integer)
  (put 'gcd '(polynomial polynomial) gcd-polys)

  (define (greatest-common-divisor args)
    (apply-generic 'gcd args))

#+END_SRC

~Упражнение 2.95~

Пусть P1 , P2 и P3 – многочлены.
P1: x^2 − 2x + 1
P 2 : 11x^2 + 1
P 3 : 13x + 5

Процедуры по нахождению НОД не будут работать, если числа станут дробными
(или коэфициенты многочленов станут дробями).

Теперь пусть Q 1 будет произведение P 1 и P 2 , а Q 2 произведение P 1 и
P 3 . При помощи ~greatest-common-divisor~ (упражнение 2.94) вычислите
НОД Q1 и Q2 .
Обратите внимание, что ответ не совпадает с P1 . Этот пример вводит в
вычисление операции с нецелыми числами, и это создает сложности для
алгоритма вычисления НОД. Чтобы понять, что здесь происходит, попробуйте
включить трассировку в ~gcd-terms~ при вычислении НОД либо проведите
деление вручную.

Попробуем проследить процесс вручную. У нас есть многочлены Q1 и Q2.
Q1: 11x^4 - 22x^3 + 12x^2 -2x + 1
Q2: 13^3 - 21x^2 + 3x +5

При попытке поделить коэфициенты первого полинома, на коэфициенты
второго, мы будем полчать дробные числа в виде рациональных дробей или же
десятичных. Ни с тем, ни с другим представлением дробей ~gcd~ работать не
умеют. Хотя автор утверждает, что это будет приводить всего лишь к
неверному представлению НОД, целочисленный вариант gcd просто выдает
ошибку и отказывается работать, если ему передать две дроби в качестве аргументов.

~Упражнение 2.96.~
а). Напишите процедуру ~pseudoremainder-terms~, которая работает в точности
как ~remainder-terms~, но только прежде, чем позвать ~div-terms~, домножает делимое на
множитель целости, описанный выше. Модифицируйте ~gcd-terms~ так, чтобы она использовала
~pseudoremainder-terms~, и убедитесь, что теперь в примере из упражнения 2.95
~greatest-common-divisor~ выдает ответ с целыми коэффициентами.
б. Теперь у НОД целые коэффициенты, но они больше, чем коэффициенты P1.
Измените ~gcd-terms~, чтобы она убирала общий множитель из коэффициентов ответа путем
деления всех коэффициентов на их (целочисленный) НОД.

Возьмем порядок старшего терма Q1, назовем его O. Возьмем порядок
старшего терма Q2 и назовем его О2. Возьмем коэффициент старшего терма Q2
и назвем его К. ~Множитель целостности - это K в степени 1 + О1 - О2~.
Если домножить Q1 на множитель целостности, а потом разделить Q1 на Q2,
мы полчим результат, в котором у коэффициентов нет никаких дробей.

#+BEGIN_SRC scheme
  ;; подгоним необходимые процедуры под ситуацию, когда таблиц операций у нас нет
  (define (sub-terms-sparse L1 L2)
    (define (iter L1 L2)
      (cond ((empty-termlist? L1) L2)
            ((empty-termlist? L2) L1)
            (else
             (let ((t1 (first-term L1)) (t2 (first-term L2)))
               (cond ((> (order t1) (order t2))
                      (adjoin-term
                       t1 (iter (rest-terms L1) L2)))
                     ((< (order t1) (order t2))
                      (adjoin-term
                       t2 (iter L1 (rest-terms L2))))
                     (else
                      (adjoin-term
                       (make-term (order t1)
                                  (- (coeff t1) (coeff t2)))
                       (iter (rest-terms L1)
                             (rest-terms L2)))))))))
    (iter L1 (change-sign-sparse L2)))

  (define (div-terms L1 L2)
    (if (empty-termlist? L1)
        (list (the-empty-termlist) (the-empty-termlist))
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (format #t "div-terms: L1 ~A L2 ~A\n" L1 L2)
          (format #t "div-terms: t1 ~A t2 ~A\n" t1 t2)
          (if (> (order t2) (order t1))
              (list (the-empty-termlist) L1)
              (let* ((new-c (/ (coeff t1) (coeff t2)))
                    (new-o (- (order t1) (order t2)))
                    (new-term (make-term new-o new-c)))
                (format #t "div-terms: new-term ~A\n" new-term)
                (if (or (=zero? new-c) (< new-c 0.000001))
                    (list 0 0)
                (let ((rest-of-result
                       (div-terms (sub-terms-sparse
                                   L1
                                   (mul-term-by-all-terms new-term L2))
                                  L2)))
                  (list (adjoin-term (make-term new-c new-o) (car rest-of-result))
                        (cadr rest-of-result))
                  )))))))


  (define (add-terms L1 L2)
    (cond ((empty-termlist? L1) L2)
          ((empty-termlist? L2) L1)
          (else
           (let ((t1 (first-term L1)) (t2 (first-term L2)))
             (cond ((> (order t1) (order t2))
                    (adjoin-term
                     t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2))
                    (adjoin-term
                     t2 (add-terms L1 (rest-terms L2))))
                   (else
                    (adjoin-term
                     (make-term (order t1)
                                (+ (coeff t1) (coeff t2)))
                     (add-terms (rest-terms L1)
                                (rest-terms L2)))))))))

  (define (mul-term-by-all-terms t1 L)
    (if (empty-termlist? L)
        (the-empty-termlist)
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2))
                      (* (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))

  ;; (процедуры, данные в мане, которые мы слегка переработали выше, работают именно с ним,
  ;; поэтому несмотря на то, что полиномы плотные, будем использовать это представление)
  (define P1 (make-poly 'x '((2 1) (1 -2) (0 1))))
  (define P2 (make-poly 'x '((2 11) (0 1))))
  (define P3 (make-poly 'x '((1 13) (0 5))))

  (define Q2 (mul-poly P1 P3))
  (define Q1 (mul-poly P1 P2))
#+END_SRC

Определим процедуру, которая возвращает множитель целостности, если
передать ей 2 списка термов.

#+BEGIN_SRC scheme
  (define (integerizing-factor L1 L2)
    (let* ((t1 (first-term L1))
           (t2 (first-term L2)))
      (expt (coeff t2) (- (+ 1 (order t1)) (order t2))))))

  (define test (integerizing-factor (term-list Q1) (term-list Q2)))

#+END_SRC

а).
#+BEGIN_SRC scheme
  (define (pseudoremainder-terms L1 L2)
    (cadr (div-terms (mull-by-all-terms
                      (make-term 0 (integerizing-factor L1 L2)) L1)
                     L2)))

  (define (gcd-terms a b)
    (if (empty-termlist? b)
        a
        (gcd-terms b (pseudoremainder-terms a b))))
#+END_SRC

б).Теперь у НОД целые коэффициенты, но они больше, чем коэффициенты P1.
Измените ~gcd-terms~, чтобы она убирала общий множитель из коэффициентов ответа путем
деления всех коэффициентов на их (целочисленный) НОД.

Если мы все числа умножали на множитель целостности, значит, можем на
него же и разделить, получив исходные коээффициенты таким образом.
#+BEGIN_SRC scheme
  (define (reduce-coeff terms-list factor)
    (if (null? terms-list)
        '()
        (adjoin-term (make-term (order (first-term terms-list))
                                (/ (coeff (first-term terms-list)) factor))
                     (reduce-coeff (cdr terms-list) factor))))

  (define (gcd-terms a b)
    ;; получили НОД термов
    (let ((g (if (empty-termlist? b)
                 a
                 (gcd-terms b (pseudoremainder-terms a b))))
          ;; получим множитель целостности для исходных списком термов
          (factor (integerizing-factor a b)))
          ;; сократили коэффициенты на множитель целостности
          (reduce-coeff g factor)))

#+END_SRC

~Упражнение 2.97~
а. Реализуйте этот алгоритм приведения рациональную функцию к наименьшему
знаменателю как процедуру ~reduce-terms~, которая принимает
в качестве аргументов два списка термов n и d и возвращает список из nn и dd,
которые представляют собой n и d, приведенные к наименьшему знаменателю.
Напишите, кроме того, процедуру ~reduce-poly~, подобную ~add-poly~,
которая проверяет, чтобы два poly имели одну и ту же переменную. Если это
так, ~reduce-poly~ откусывает эту переменную и передает оставшуюся часть
задачи в reduce-terms, а затем прикрепляет переменную обратно к двум
спискам термов, которые получены из reduce-terms.

б. Определите процедуру, аналогичную ~reduce-terms~, которая делает то, что
делала для целых чисел исходная ~make-rat~. и определите reduce как
обобщенную операцию, которая вызывает apply-generic и диспет-
чирует либо к ~reduce-poly~ (если аргументы — многочлены), либо к ~reduce-integers~ (для
аргументов типа scheme-number). Теперь Вы легко можете заставить пакет
рациональной арифметики приводить дроби к наименьшему знаменателю,
потребовав от make-rat звать ~reduce~ прежде, чем сочетать данные
числитель и знаменатель в процессе порождению рационального числа.

а.
- запустить ~gcd-terms~ для нахождения НОД числителя и знаменателя
- найти множитель целостности: старший коэфициент НОД, возведенный в
  степень 1 + О1 - О2, где O2 – порядок НОД, а O1 — максимум из порядков
  числителя и знаменателя.
- умножить числитель и знаменатель на множитель целостности
- поедлить числитель и наменатль на нод
- редуцировать коэфициенты числителя и знаменателя

#+BEGIN_SRC scheme
  (define (reduce-terms n d)
    ;; получили НОД
    (let* ((g (gcd-terms n d))
           ;; получили старший коэффциент НОД-а
           (k (coeff (first-term g)))
           ;; получаем старший из порядков числителя или знаменателя
           (O1 (if (>= (order (first-term n)) (order (first-term n)))
                   (order (first-term n))
                   (order (first-term n))))
           ;; получаем старший порядок НОД-а
           (O2 (order (first-term g)))
           ;; получаем множитель целостности
           (factor (expt K ( - (+ 1 O1) O2)))
           ;; создаем из него новый терм
           (new-term (make-term 0 factor)))
      ;; умножаем числитель и заменатель на множитель целостности,
      ;; делим на НОД, редуцируем коэффициенты, оборачиваем результат в список
      (list (reduce-coeff (/ (mul-term-by-all-terms new-term n) g) factor)
            (reduce-coeff (/ (mul-term-by-all-terms new-term d) g) factor))))

  (define (reduce-poly poly1 poly2)
    (let ((var1 (variable poly1))
          (var2 (variable poly2)))
      ;; проверяем переменные на одинаковость
      (if (same-variable? var1 var2)
           ;; вызываем основную функцию
          (reduce-terms (term-list poly1) (term-list poly2))
          ;; иначе сообщение об ошибке
          (error "Переменные не одинаковые" var1 var2))))

#+END_SRC

б.
Определите процедуру, аналогичную ~reduce-terms~, которая делает то, что
делала для целых чисел исходная ~make-rat~. и определите reduce как
обобщенную операцию, которая вызывает apply-generic и диспет-
чирует либо к ~reduce-poly~ (если аргументы — многочлены), либо к ~reduce-integers~ (для
аргументов типа scheme-number). Теперь Вы легко можете заставить пакет
рациональной арифметики приводить дроби к наименьшему знаменателю,
потребовав от make-rat звать ~reduce~ прежде, чем сочетать данные
числитель и знаменатель в процессе порождению рационального числа.

#+BEGIN_SRC scheme
  (define (reduce-integers n d)
    (let ((g (gcd-integers n d)))
      (list (/ n g) (/ d g))))

  (put 'reduce '(scheme-number scheme-number) reduce-integers)
  (put 'reduce '(polynomial polynomial) reduce-poly)

  (define (reduce args)
    (apply-generic 'reduce args))
#+END_SRC

~Упражнение 3.1.~
Накопитель (accumulator) — это процедура, которая вызывается с одним
численным аргументом и собирает свои аргументы в сумму. При каждом вызове накопитель
возвращает сумму, которую успел накопить.
Напишите процедуру ~make-accumulator~, порождающую накопители, каждый из
которых поддерживает свою отдельную сумму. Входной параметр ~make-accumulator~ должен
указывать начальное значение суммы;

#+BEGIN_SRC scheme

  (define (make-accumulator amount)
    (let ((balance amount))
      (lambda (amount)
        (set! balance (+ balance amount))
        balance)))

  (define A (make-accumulator 5))

  (A 10)
  => 15
  (A 10)
  => 25

#+END_SRC

~Упражнение 3.2.~
При тестировании программ удобно иметь возможность подсчитывать, сколько
раз за время вычислений была вызвана та или иная процедура. Напишите процедуру
~make-monitored~, принимающую в качестве параметра процедуру ~f~, которая
сама по себе принимает один входной параметр. Результат, возвращаемый
~make-monitored~ — третья процедура, назовем ее ~mf~, которая подсчитывает,
сколько раз она была вызвана, при помощи внутреннего счетчика. Если на
входе ~mf~ получает специальный символ ~how-many-calls?~, она возвращает
значение счетчика. Если же на вход подается специальный символ
~reset-count~, ~mf~ обнуляет счетчик. Для любого другого параметра ~mf~
возвращает результат вызова ~f~ с этим параметром и увеличивает счетчик.

#+BEGIN_SRC scheme
  (define (make-monitored f)
    (let ((counter 0))
      (define (mf arg)
        (cond ((equal? arg 'how-many-calls?) counter)
              ((equal? arg 'reset-count) (set! counter 0))
              (else (begin
                      (set! counter (+ counter 1))
                      (f arg)))))
      mf))

  ;; тестовая функция
  (define (improve guess x)
    (average guess (/ x guess)))

  (define (average x y)
    (/ (+ x y) 2))

  (define (good-enough? guess x)
    (define (square x)
      (* x x))
    (< (abs (- (square guess) x)) 0.001))

  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x)
                   x)))

  (define (sqrt x)
    (sqrt-iter 1.0 x))

  ;; тест
  (define s (make-monitored sqrt))
  (s 100)
  (s 'how-many-calls?)
  (s 'reset-count)
#+END_SRC


~Упражнение 3.3.~
Измените процедуру ~make-account~ так, чтобы она создавала счета,
защищенные паролем.
А именно, ~make-account~ должна в качестве дополнительного аргумента
принимать символ, получившийся объект-счет должен обрабатывать запросы,
только если они сопровождаются паролем, с которым счет был создан, а в
противном случае он должен жаловаться.

#+BEGIN_SRC scheme
  (define (make-account balance password)
    (let ((own-pass password))
      (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Недостаточно денег на счете"))

      (define (deposit amount)
        (set! balance (+ balance amount))
        balance)

      (define (dispatch password m)
        (cond ((and (eq? own-pass password) (eq? m 'withdraw)) withdraw)
              ((and (eq? own-pass password) (eq? m 'deposit)) deposit)
              ((not (eq? own-pass password)) (error "Неправильный пароль"))
               (else (error "Неизвестный вызов -- MAKE-ACCOUNT"
                            m))))
        dispatch))


  ;; тест
  (define acc (make-account 100 'secret-password))
  ((acc 'secret-password 'withdraw) 40)
  ((acc 'some-other-password 'deposit) 50)
#+END_SRC


~Упражнение 3.4.~
Модифицируйте процедуру ~make-account~ из упражнения 3.3, добавив еще одну
локальную переменную, так, чтобы, если происходит более семи попыток доступа подряд с
неверным паролем, вызывалась процедура ~call-the-cops~ (вызвать полицию).

Я уменьшила кол-во неправильных попыток до трех, чтоб было быстрее
проверять.
#+BEGIN_SRC scheme
  (define (call-the-cops)
    (error "cops are going!"))

  (define (make-account balance password)
    (let ((own-pass password)
          (wrong-pass-counter 0))
      (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Недостаточно денег на счете"))

      (define (deposit amount)
        (set! balance (+ balance amount))
        balance)

      (define (dispatch password m)
        (cond ((and (eq? own-pass password) (eq? m 'withdraw))
               (begin
                 (set! wrong-pass-counter 0)
                 withdraw))
              ((and (eq? own-pass password) (eq? m 'deposit))
               (begin
                 (set! wrong-pass-counter 0)
                 deposit))
              ((not (eq? own-pass password))
               (if (< wrong-pass-counter 3)
                   (begin
                     (set! wrong-pass-counter (+ wrong-pass-counter 1))
                     (error "Неправильный пароль"))
                   (call-the-cops)))
               (else (error "Неизвестный вызов -- MAKE-ACCOUNT"
                            m))))
        dispatch))


  ;; тест
  (define acc (make-account 100 'secret-password))
  ((acc 'secret-password 'withdraw) 40)
  ((acc 'some-other-password 'deposit) 50)
#+END_SRC
~Упражнение 3.5~

Реализуйте интегрирование методом Монте-Карло в виде процедуры
~estimate-integral~, которая в качестве аргументов принимает предикат P,
верхнюю и нижнюю границы прямоугольника x1, x2, y1 и y2, а также число
проверок, которые мы должны осуществить, чтобы оценить отношение
площадей.
Ваша процедура должна использовать ту же самую процедуру
~monte-carlo~, которая выше использовалась для оценки значения π. Оцените π при помощи
~estimate-integral~, измерив площадь единичного круга.

Точки (x1 y1) и (x2 y2) - это 2 угла прямокгольника, расположенные по
диагонали. Это границы прямоугольника.

#+BEGIN_SRC scheme
  ;; необходимые для работы функции
  (define (random-in-range low high)
    (let ((range (- high low)))
      (+ low (random range))))

  (define (monte-carlo trials experiment)
    (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
             (/ trials-passed trials))
            ((experiment)
             (iter (- trials-remaining 1) (+ trials-passed 1)))
            (else
             (iter (- trials-remaining 1) trials-passed))))
    (iter trials 0))

  ;; определенные мной процедуы и переменные

  ;; радиус и координаты центральной точки окружности
  (define radius 1)
  (define center-x 1)
  (define center-y 1)

  (define (square x)
    (* x x))

  ;; предикат для проверок принадлежности точки окрнужности
  (define (test x y)
    (<= (+ (square (- x center-x))
           (square (- y center-y)))
        (square radius)))

  (define (estimate-integral P x1 x2 y1 y2 n)
    ;; находит площать прямоугольника
    (define (S x1 x2 y1 y2)
      (* (- y2 y1) (- x2 x1)))
    (abs (* (S x1 x2 y1 y2) (monte-carlo n (lambda () (P (random-in-range x1 x2)
                                                         (random-in-range y1 y2)))))))
  (estimate-integral test 0.0 2.0 0.0 2.0 7000)
#+END_SRC

~Упражнение 3.6.~
Полезно иметь возможность сбросить генератор случайных чисел, чтобы
получить последовательность, которая начинается с некоторого числа. Постройте новую
процедуру ~rand~, которая вызывается с аргументом. Этот аргумент должен
быть либо символом ~generate~, либо символом ~reset~.
Процедура работает так: (rand 'generate) порождает новое случайное число;
((rand 'reset) <новое-значение>) сбрасывает внутреннюю переменную
состояния в указанное hновое-значениеi. Таким образом, сбрасывая значения, можно
получать повторяющиеся последовательности.
Эта возможность очень полезна при тестировании и отладке программ,
использующих случайные числа.

#+BEGIN_SRC scheme
  (define rand
    (let ((x random-init))
      (lambda (arg)
        (cond ((eq? arg 'generate) (begin (set! x (rand-update x)) x))
              ((eq? arg 'reset ) (lambda (value) (set! x value)
                                         x))
              (else x)))))


  (define random-init
  (random (expt 2 31)))

  (define (rand-update x)
    (let ((a 13)
          (b 67)
          (m 6))
      (+ (* x a) (* (abs m) b))))

  ;; тесты
  (rand 'generate)
  ((rand 'reset) 3)
#+END_SRC


~Упражнение 3.7.~
Рассмотрим объекты-банковские счета, создаваемые процедурой ~make-account~,
и снабженные паролями, как это описано в упражнении 3.3. Предположим, что наша
банковская система требует от нас умения порождать совместные счета. Напишите процедуру
~make-joint~, которая это делает. ~Make-joint~ должна принимать три
аргумента. Первый из них — защищенный паролем счет. Второй обязан
совпадать с паролем, с которым этот счет был создан, иначе ~make-joint~
откажется работать. Третий аргумент — новый пароль.

- как полуить парольищ объекта?
#+BEGIN_SRC scheme
  (define (make-account balance password)
    (let ((own-pass password))
      (define (withdraw amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Недостаточно денег на счете"))

      (define (deposit amount)
        (set! balance (+ balance amount))
        balance)
      ;; процедура проверки пароля
      (define (check-pass pass?)
        (if (eq? own-pass pass?)
            #t
            #f))
      ;; процедура изменения пароля
      (define (change-pass new-pass)
        (set! own-pass new-pass))

      (define (dispatch password m)
        (cond ((and (eq? own-pass password) (eq? m 'withdraw)) withdraw)
              ((and (eq? own-pass password) (eq? m 'deposit)) deposit)
              ((and (eq? own-pass password) (eq? m 'check-pass)) check-pass)
              ((and (eq? own-pass password) (eq? m 'change-pass)) change-pass)
              ((not (eq? own-pass password)) (error "Неправильный пароль"))
              (else (error "Неизвестный вызов -- MAKE-ACCOUNT"
                           m))))

      dispatch))

  (define (make-joint acc acc-pass new-pass)
    (if ((acc acc-pass 'check-pass) acc-pass)
        (begin
          ((acc acc-pass 'change-pass) new-pass)
          acc)
        (error "Неправильный пароль")))

  ;; тесты
  (define peter-acc (make-account 100 'open-sesame))
  (define paul-acc (make-joint peter-acc 'open-sesame 'ggg))

  ((paul-acc 'ggg 'check-pass) 'ggg)
  ((peter-acc 'ggg 'check-pass) 'ggg)

  ((peter-acc 'ggg 'deposit) '10)
  ((paul-acc 'ggg 'deposit) '10)
#+END_SRC

~Упражнение 3.8.~
Когда в разделе 1.1.3 мы определяли модель вычислений, мы сказали, что
первым шагом при вычислении выражения является вычисление его подвыражений. Однако мы
нигде не указали порядок, в котором проходит вычисление подвыражений (слева направо или
справа налево). Когда мы вводим присваивание, порядок, в котором вычисляются аргументы
процедуры, может повлиять на результат.
Определите простую процедуру f, так, чтобы вычисление
(+ (f 0) (f 1))
возвращало 0, если аргументы + вычисляются слева направо, и 1, если они
вычисляются справа налево.

Итак, обычно программа вычисляется сверху вниз, слева направо. Но в форме
set! выражение, которое мы должны вычислить, чтоб присвоить
переменной его результат, находится справа. Соотвтетсвенно, порядок
вычислений изменится. Значит для изменения порядка надо использовать set!

Чтоб + вернул 0, нужно, чтоб значение правой части выражения приравлялось
к левому.
Иными словами должно произойти (set! (f 1) (f 0))
А чтоб получить единицу, приравнения должно быть в обратном порядке
(set! (f 0) (f 1))
В заивимости от того, будем мы двигать справа налево или слева направо
поменяется ответ у +.


#+BEGIN_SRC scheme
  (define seen-zero? #f)
  (define (f n)
    (cond ((= n 0) (begin (set! seen-zero? #t) n))
          (seen-zero? 0)
          (else n)))


  (+ (f 1) (f 0))
  ;; здесь необходимо перезалить функцию и переменную состояния в интерпритатор,
  ;; поскольку переменная состояния будет отражать состояниена предыдущем вычислении
  (+ (f 0) (f 1))
#+END_SRC

~Упражнение 3.9~
Сделано на листочке.

~Упражнение 3.10.~
В процедуре ~make-withdraw~ локальная переменная ~balance~ создается в виде
параметра ~make-withdraw~. Можно было бы создать локальную переменную и явно, используя
let, а именно:

#+BEGIN_SRC scheme
  (define (make-withdraw initial-amount)
    (let ((balance initial-amount))
      (lambda (amount)
        (if (>= balance amount)
            (begin (set! balance (- balance amount))
                   balance)
            "Недостаточно денег на счете"))))
#+END_SRC

С помощью модели с окружениями проанализируйте альтернативную версию
makewithraw. Нарисуйте картинки, подобные приведенным в этом разделе, для выражений
~(define W1 (make-withdraw 100))~
~(W1 50)~
~(define W2 (make-withdraw 100))~
Покажите, что две версии make-withdraw создают объекты с одинаковым
поведением. Как различаются структуры окружений в двух версиях?

Итак , ~make-withdraw~ создается в глобальном окружении. Процедура
связывается с именем, теперь все процедуры имеют доступ к определенной
процедуре. ~make-withdraw~ создает свое собвтенное окружение, которое
вмещает формальные параметры и тело функции. Далее у нас идет форма
~let~, которая являясь лямбда-выражением по сути, так же создает свое
внутреннее окружение. Внутри этого окружения что угодно может ссылаться
на созданную локальную переменную ~balance~, в которую мы положили
значение формального параметра ~initial-amount~. Важно понимать, что
окружение, порожденное ~let~ != окружению, порожденному самой функцией
~make-withdraw~, окружение ~let~ более внутреннее по отношению к
откружению, которое породила функция. Это значит, что мы можем обращаться
из окружения формы ~let~ в окружение фунции, например, взаимодетвовать с
параметром ~initial-amount~, если нам захочется. Но мы не можем
определяться к переменной ~balance~ вне ее окружения. Она как бы "скрыта"
от внешнего мира.

Возвращаемое значение процедуры ~make-withdraw~ - лямбда, которая внутри
себя ссылается на переменную ~balance~, поскольку определена внутри ее
окружения. Так у нас получается объект "банковский счет". Поскольку
переменная ~W1~ определна глобально, значит, в глоабльном окружении
появляется запись, связывание имения ~W1~ и возвращенной лямбды. При
вызове ~(W1 50)~ мы перезапишем переменную ~balance~, испотзуя формальный
параметр лямбды. Мы можем это сделать, потому что лямбда была определена
внутри ~let~, которая создала ~balance~. При вызове ~(define W2 (make-withdraw 100))~
мы получим второй объект, никак не связаный с ~W1~.

Если у нас будет такая версия ~make-withdraw~, то ничего особенно не поменяется.
#+BEGIN_SRC scheme
  (define (make-withdraw balance)
    (lambda (amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Недостаточно денег на счете")))
#+END_SRC

У нас только исчезнет окружение, формируемое формой ~let~ и мы будем
просто обращаться к формальному параметру ~balance~.

~Упражнение 3.11.~
В разделе 3.2.3 мы видели, как модель с окружениями описывает поведение
процедур, обладающих внутренним состоянием. Теперь мы рассмотрели, как
работают локальные определения.
Типичная процедура с передачей сообщений пользуется и тем, и
другим. Рассмотрим процедуру моделирования банковского счета из раздела
3.1.1:

#+BEGIN_SRC scheme
  (define (make-account balance)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Недостаточно денег на счете"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            (else (error "Неизвестный вызов -- MAKE-ACCOUNT"
                         m))))
    dispatch)
#+END_SRC

Покажите, какая структура окружений создается последовательностью
действий
~(define acc (make-account 50))~
~((acc ’deposit) 40)~
=> 90
~((acc ’withdraw) 60)~
=>30
Где хранится внутреннее состояние acc? Предположим, что мы определяем еще
один счет ~(define acc2 (make-account 100))~
Каким образом удается не смешивать внутренние состояния двух счетов?
Какие части структуры окружений общие у ~acc~ и ~acc2~?

При вызове ~(define acc (make-account 50))~ в глобальном окружении
появляется объект, который связывается с именем ~acc~. Данный объект по
факту представляет собой процедуру ~dispatch~, которую вернула процедура
~make-account~. Внутри  ~make-account~ определены 3 процедуры. Это
означает, что они находятся в одном окружении, которое породила процедура
~make-account~, это позволяет им образаться друг к другу, в порядке того,
как их определяли. Иными словами, процедуру ~dispatch~ определили позже
всех, поэтому она может обращаться к процедурам ~withdraw~ и ~deposit~, а
вот они к ~dispatch~ обращаться не могут, т.к. на момент определиния ее
еще не существовало.

Вернемся к вызову ~(define acc (make-account 50))~. Мы получили объект
~acc~, формальному параметру ~balance~ было присвоено значение 50. Храним
это значение.
Вызываем ~((acc 'deposit) 40)~. В этом время запускается процедура
~dispatch~, она генерирует свое окружение,
ее формальному параметру присваивается значение символа
~'deposit~. Поскольку этот символ совпадает с названием соответствующей
процедуры, ~dispaltch~ возвращает процедуру ~deposit~ во внешнее
окружение, откуда была вызвана. При вызове процедуры ~deposit~ генериурет
свое внутреннее окружение. Ее формальному параметру присваивается
значение 40. Затем мы обновляем значение ~balance~.  Аналогичные действия
по окружениям будут  происходить при вызове ~((acc ’withdraw) 60)~.

Предположим, мы создаем новый счет ~(define acc2 (make-account
100))~. Внутренее состоянии ~acc2~ будет храниться в его переменной
~balance~. С точки зрения компьютера, acc2 и acc имеют разные адреса, а
значит являются разными объектами. И хотя они оба определены глобально, у
каждого есть свои внутренние окружения. Поскольку эти окружения
изолированы друг от друга, у нас могут быть 2 разных состояния,
хранящиеся в двух переменных с одинаковым именем ~balance~, поскольку они
находятся в 2х разных окружениях, то с точки зрения компьютера это 2
разные переменные. Более того, если мы будем обращаться внутри какого-то
объекта к его переменной ~balance~,мы обратимся именно к его переменной,
поскольку будем в одном с ней окружении. Она будет более "внутренней", по
отношению к другой переменной с таким же именем, и потому перекроет ее.


~Упражнение 3.12.~
В разделе 2.2.1 была введена следующая процедура для добавления одного
списка к другому:
#+BEGIN_SRC scheme

  (define (append x y)
    (if (null? x)
        y
        (cons (car x) (append (cdr x) y))))

#+END_SRC

~Append~ порождает новый список, по очереди наращивая элементы ~x~ в начало
~y~. Процедура ~append!~ подобна ~append~, но только она является не конструктором, а
мутатором. Она склеивает списки вместе, изменяя последнюю пару ~x~ так, что
ее ~cdr~ становится равным ~y~. (Вызов ~append!~ с пустым ~x~ является ошибкой.)

#+BEGIN_SRC scheme
  (define (append! x y)
    (set-cdr! (last-pair x) y)
    x)
#+END_SRC
Здесь ~last-pair~ — процедура, которая возвращает последнюю пару своего аргумента:
#+BEGIN_SRC scheme
  (define (last-pair x)
    (if (null? (cdr x))
        x
        (last-pair (cdr x))))
#+END_SRC

Рассмотрим последовательность действий

#+BEGIN_SRC scheme
  (define x (list 'a 'b))
  (define y (list 'c 'd))
  (define z (append x y))
#+END_SRC
 Каким будет вывод интерпретатора? Объясните свой ответ, нарисовав
 стрелочные диаграммы.

#+BEGIN_SRC scheme
  z
  => (a b c d)

  (cdr x)
  => (b)

  (define w (append! x y))

  w
  =>
  (a b c d)

  (cdr x)
  (b c d)
#+END_SRC

Гоовря более простым языком, ~append!~ является деструктивной функцией:
она не создает новый список, а меняет уже существующие. Поэтому и ~cdr~ у
~x~ после применения ~append!~ изменился. ~append!~ меняет указатели
благодаря ~set-cdr!~.

~Упражнение 3.13.~
Рассмотрим следующую процедуру ~make-cycle~, которая пользуется last-pair
из упражнения 3.12:

#+BEGIN_SRC scheme
  (define (make-cycle x)
    (set-cdr! (last-pair x) x)
    x)
#+END_SRC

Нарисуйте стрелочную диаграмму, которая изображает структуру z, созданную
таким кодом:

#+BEGIN_SRC scheme
  (define z (make-cycle (list 'a 'b 'c)))
#+END_SRC

Что случится, если мы попробуем вычислить ~(last-pair z)~?

Структура ~z~ - это так называемый кольцевой список. Т.е. список,
последний указатель которого указывает не на nil, а на ~car~ этого же
списка. При попытке вызвать ~(last-pair z)~ мы зациклимся навсегда,
поскольку ~cdr~ списка никогда не будет ~nil~.

~Упражнение 3.14.~
Следующая процедура, хотя и сложна для понимания, вполне может оказаться полезной:

#+BEGIN_SRC scheme
  (define (mystery x)
    (define (loop x y)
      (format #t "x ~A y ~A\n" x y)
      ;; если список пустой
      (if (null? x)
          ;; возвращаем y
          y
          ;; иначе берем "хвост" списка
          (let ((temp (cdr x)))
            (format #t "temp ~A\n" temp)
            ;; заменияем хвост "x" на "y"
            (set-cdr! x y)
            ;; затем в качестве списка "x" передаем его хвост
            ;; а в качестве "y" передаем обновленный x
            (loop temp x))))
    (loop x '()))

  (mystery (list 'a 'b 'c 'd))

#+END_SRC

~Loop~ пользуется «временной» переменной ~temp~, чтобы сохранить старое
значение ~cdr~ пары ~x~, поскольку ~set-cdr!~ на следующей строке его
разрушает.
Объясните, что за задачу выполняет ~mystery~. Предположим, что переменная
~v~  определена выражением ~(define v (list 'a 'b 'c 'd))~. Нарисуйте
диаграмму, которая изображает список, являющийся значением ~v~. Допустим,
что теперь мы выполняем ~(define w (mystery v))~. Нарисуйте стрелочные
диаграммы, которые показывают структуры v и w после вычисления этого выражения. Что
будет напечатано в качестве значений ~v~ и ~w~?

~mystery~ - это версия ~reverse~, только формируем мы новый список
благодаря использованию указателей из исходного, а не
копированию этих элементов. Из этих указателей мы формируем новый
список. По мере фомирования нового списка, указатели "вычищаются" из
исходного из-за использования ~set-cdr!~, который изменяется указатель на
""хвост" исходного списка.

После вызова ~(define w (mystery v))~ ~w~ будет присвоего значение ~(d c
b a)~, а ~v~ останется только ~(а)~. ~V~ получает свое значение таким
образом потому, что мы всегда изменяли ~cdr~ списка, но не ~car~, который
по-прежнему указывал на элемент ~a~.

~Упражнение 3.16.~
Бен Битобор решил написать процедуру для подсчета числа пар в любой
списковой структуре.
«Это легко, — думает он. — Число пар в любой структуре есть число пар в
~car~ плюс число пар в ~cdr~ плюс один на текущую пару». И он пишет следующую процедуру:

#+BEGIN_SRC scheme
  (define (count-pairs x)
    (if (not (pair? x))
        (begin (format #t "~A\n" x) 0)
        (+ (count-pairs (car x))
           (count-pairs (cdr x))
           1)))

  ;; зациклится навсегда
  (define endless-l (make-cyrcle l1))
  (count-pairs endless-l)

  ;; вернет 4
  (count-pairs (list 'a (list 'b) 'c))

  ;;вернет 3
  (count-pairs (list 'a 'b 'c))

  ;; вернет 7
  (count-pairs (list (list (list 'a) 'c) (list 'b) 'c))


  ;; Здесь есь скользкий момент!
  ;; Нужно, чтоб было 3 пары не с точки зрения человека, а с точки зрения машины. Т.е. чтоб
  ;; было именно 3 ячейки. Не все примеры выше этому правилу не соответствуют
  (define l1 (list 'a))
  (define l2 (list 'b))
  (define l3 (list 'c))

  (define lt1 (list 'b 'c))
  (define lt2 (list 'a))
  (set-car! lt1 lt2)
  (set-car! (cdr lt1) lt2)

  ;;делаем так, чтоб car и cdr указывали на 1 и тот же объект.
  (set-car! l2 l3)
  (set-cdr! l2 l3)

  ;; аналогично
  (set-car! l1 l2)
  (set-cdr! l1 l2)

  ;; вернет 4
  (count-pairs l1)
  ;;вернет 7
  (count-pairs lt1)
#+END_SRC

Покажите, что эта процедура ошибочна. В частности, нарисуйте диаграммы,
представляющие списковые структуры ровно из трех пар, для которых Бенова процедура
вернет 3; вернет 4; вернет 7; вообще никогда не завершится.

Некорректное поведение возикает, если использовать разделаемые
структуры. На самом деле процедура считает не количество пар, а
количетсов указателей на них. Сколько указателей указывают на одну и ту
же пару, столько раз она будет посчитана.

~Упражнение 3.17.~
Напишите правильную версию процедуры count-pairs из упражнения 3.16,
которая возвращает число различных пар в любой структуре. (Подсказка: просматривайте
структуру, поддерживая при этом вспомогательную структуру, следящую за
тем, какие пары уже были посчитаны.)

Мы можем создавать дополнительный список, копируя в него элементы, при
копировании проверяя, не был ли этот объект уже в списке. Для этого нам
нужен предикат ~eq?~, который проверяет, являются ли текущие символы
одним объектом в памяти компьютера.

#+BEGIN_SRC scheme
  (define (my-count-pairs lst)
    (let ((new-lst '()))
      (define (iter x)
        (format #t "new-lst ~A\n"new-lst)
        (format #t "x ~A\n" x)
        (cond ((and (not (pair? x)) (check-lst x new-lst))
               (begin (format #t "not pair\n") (set! new-lst (cons x new-lst)) 0))
              ((pair? x) (begin  (format #t "pair\n")
                                 (+ (iter (car x))
                                    (iter (cdr x))
                                    1)))
              (else (begin (format #t "else\n") -1))))
      (iter lst)))


  (define endless-l (make-cyrcle '(a b c)))
  (my-count-pairs endless-l)

  (define l1 (list 'a))
  (define l2 (list 'b))
  (define l3 (list 'c))

  (define lt1 (list 'b 'c))
  (define lt2 (list 'a))
  (set-car! lt1 lt2)
  (set-car! (cdr lt1) lt2)

  ;;делаем так, чтоб car и cdr указывали на 1 и тот же объект.
  (set-car! l2 l3)
  (set-cdr! l2 l3)

  ;; аналогично
  (set-car! l1 l2)
  (set-cdr! l1 l2)

  ;; вернет 7
  (my-count-pairs l1)
  ;;вернет 4
  (my-count-pairs lt1)

  (my-count-pairs '(a b c d))
  ;;предикат для проверки наличия символа в списке
  (define (check-lst elt lst)
    (cond ((null? lst) #t)
          ((eq? elt (car lst)) #f)
          (else (check-lst elt (cdr lst)))))


  (check-lst 'a (list x))

  (define test (list 'a 'a 'a))
#+END_SRC

~Упражнение 3.18.~
Напишите процедуру, которая рассматривает список и определяет, содержится
ли в нем цикл, то есть, не войдет ли программа, которая попытается добраться до конца
списка, продвигаясь по полям ~cdr~, в бесконечный цикл.
Такие списки порождались в упражнении 3.13

Идея 1.
Обычный список от кольцевого отличает наличие указателя на nil в последней
паре списка. Пока мы не достигнем nil, список не кончится.
Значит, нам надо как-то проверить, есть этот указатель или нет.

Идея 2.
Еще можно попробовать скопирвать элементы в другой список и проверить, не
начали ли мы копировать в новый список одни и те же объекты.
Недостаток: что если у нас правильный список, состоящий из одних и тех е
объектов?

Идея 3.
?

Реализация идеи 2.
#+BEGIN_SRC scheme
  ;; создадим тестовые примеры
  (define test-cycle (make-cycle (list 'a 'b 'c)))
  (define test-usual (list 'a 'b 'c))
  (define test-same-object (list 'a 'a 'a))

  ;;предикат проверяет, был элемент в списке уже или нет
  (define (check-lst elt lst)
    (cond ((null? lst) #t)
          ((eq? elt (car lst)) #f)
          (else (check-lst elt (cdr lst)))))

  (define (cycle? lst)
    (define (iter lst new-lst)
      ;; если дошли до конца списка, он не циклический
      (cond ((null? lst) #f)
            ;; элемент не был с списке
            ((check-lst (car lst) new-lst) (iter (cdr lst) (cons (car lst) new-lst)))
            ;; иначе список циклический
            (else #t)))
    (iter lst '()))

  (cycle? test-cycle)
  (cycle? test-usual)
  ;; этот тест выявляет недостаток идеи
  (cycle? test-same-object)
#+END_SRC

~Упражнение 3.19.~
Переделайте упражнение 3.18, используя фиксированное количество
памяти. (Тут нужна достаточно хитрая идея.)

Значит, теперь мы не можем копировать элементы списка в другой список,
чтоб проверить. не повторяются ли какие-то из них. Объем требуемой памяти
будет расти вместе с длиной списка. В худжем случае нам понадобится
столько же памяти, сколько нужно для исходного списка.

Но мы можем сравнивать каждый элемент с ~car~ списка. Тогда понадобится
фиксированный объем памяти.

Если какой-то элемент совпал с первым элементом списка, то мы считаем,
что зациклились. Недостаток этой идеи такой же, как и у идеи в предыдущем
упражнении.

#+BEGIN_SRC scheme
  ;; создадим тестовые примеры
  (define test-cycle (make-cycle (list 'a 'b 'c)))
  (define test-usual (list 'a 'b 'c))
  (define test-same-object (list 'a 'a 'a))


  (define (cycle? lst)
    (define (iter lst elt)
      ;; если дошли до конца списка, он не циклический
      (cond ((null? lst) #f)
            ;; если текущий элемент не является тем же объектом, что и car списка,
            ;; список не циклический
            ((not (eq? elt (car lst))) (iter (cdr lst) elt))
            ;; иначе список циклический
            (else #t)))
    (iter (cdr lst) (car lst)))

  (cycle? test-cycle)
  (cycle? test-usual)
  ;; этот тест выявляет недостаток идеи
  (cycle? test-same-object)
#+END_SRC

~Упражнение 3.20~

Сделано на листочке.

~Упражнение 3.21~
ПРоблема в том, что стандартная "печаталка" схемы ничего не знает об
очередях, она может печатать только списки, пары, отдельные символы и
т.д. Вобчном списке ~car~ всегда будет указывать на начало списка, на его
первый элемент, а ~cdr~ - на хвост, т.е., грубо говоря, на следующий
элемент после того, на который указывает ~car~, соответственно при печати
списка мы просто печатаем его ~car~ и весь ~cdr~. Но при вставке
элементов в очередь мы искусственно сдвигаем ~cdr~ на последний
добавленный элемент. То есть в случае с очередью, между указателем ~car~
и  ~cdr~ может оказаться неограниченное кол-во элементов. Только
интерпритатор об этом ничего не знает: при печати он все так же
напечатает ~car~ и ~cdr~ списка, в результате вместо печати всей очереди,
мы увидим только ее первый элемент и последний.

Нужно написать такую процедуру, которая сможет напечатать очередь
целиком.

#+BEGIN_SRC scheme
  (define (print-queue queue)
    (define (iter queue)
      (if (null? queue)
          (newline)
          (begin
            (format #t " ~A" (car queue))
            (iter (cdr queue)))))
    (iter (front-ptr queue)))

  ;; тестовая очередь
  (define test-queue (make-queue))
  (insert-queue! test-queue 'a)
  (insert-queue! test-queue 'b)
  (insert-queue! test-queue 'c)
  (insert-queue! test-queue 'd)
  (insert-queue! test-queue 'f)

  (print-queue test-queue)
#+END_SRC

~Упражнение 3.22.~
Вместо того, чтобы представлять очередь как пару указателей, можно
построить ее в виде процедуры с внутренним состоянием. Это состояние
будет включать указатели на начало и конец обыкновенного списка. Таким
образом, ~make-queue~ будет иметь вид
#+BEGIN_SRC scheme

  (define (make-queue)
    (let ((front-ptr ...)
          (rear-ptr ...))
      ;;<определения внутренних процедур>
      (define (dispatch m) ...)
      dispatch))
#+END_SRC

Закончите определение ~make-queue~ и реализуйте операции над очередями с
помощью этого представления.

Получается, что теперь мы представляем очередь как набор процедур,
который может взаиможействовать с очередью. Иными словами вызов
~make-queue~ создавал нам список, который мы воспринимали как очередь, а
сейча мы получаем объект, который может взаимодействовать с очередью, но
не саму очередь.

#+BEGIN_SRC scheme
  (define (make-queue)
    (let ((front-ptr (lambda (queue) (car queue)))
          (rear-ptr (lambda (queue) (cdr queue))))

      (define (set-front-ptr! queue item) (set-car! queue item))

      (define (set-rear-ptr! queue item) (set-cdr! queue item))

      (define (empty-queue? queue) (null? (front-ptr queue)))

      (define (front-queue queue)
        (if (empty-queue? queue)
            (error "FRONT вызвана с пустой очередью" queue)
            (car (front-ptr queue))))


      (define (insert-queue! queue item)
        (let ((new-pair (cons item '())))
          (cond ((empty-queue? queue)
                 (set-front-ptr! queue new-pair)
                 (set-rear-ptr! queue new-pair)
                 queue)
                (else
                 (set-cdr! (rear-ptr queue) new-pair)
                 (set-rear-ptr! queue new-pair)
                 queue))))


      (define (dispatch m)
        (cond ((eq? 'insert-queue! m) insert-queue!)
              ((eq? 'front-queue m) front-queue)
              ((eq? 'empty-queue? m) empty-queue?)
              ((eq? 'set-front-ptr! m) set-front-ptr!)
              ((eq? 'set-rear-ptr! m) set-rear-ptr!)
              (else (error "wrong action!" m))))
              dispatch))

  (define test-obj (make-queue))
  (define test-queue '(v n))
  ((test-obj 'insert-queue!) test-queue 'a)

#+END_SRC

~Упражнение 3.23.~
Дек (deque, double-ended queue, «двусторонняя очередь») представляет
собой последовательность, элементы в которой могут добавляться и
уничтожаться как с головы, так и с хвоста. На деках определены такие
операции: конструктор ~make-deque~, предикат ~empty-deque?~, селекторы
~front-deque~ и ~rear-deque~, и мутаторы ~front-insert-deque!~,
~rear-insert-deque!~, ~front-delete-deque!~ и ~rear-delete-deque!~.
Покажите, как представить дек при помощи пар, и напишите реализацию
операций .Все операции должны выполняться за Θ(1) шагов.

#+BEGIN_SRC scheme
  (define (make-deque)
    (cons '()'()))

  (define (front-ptr-deque queue) (car queue))

  (define (rear-ptr-deque queue) (cdr queue))

  (define (empty-deque? deque)
    (and (null? (front-ptr-deque deque)) (null? (rear-ptr-deque deque))))

  (define (set-front-ptr! queue item) (set-car! queue item))

  (define (set-rear-ptr! queue item) (set-cdr! queue item))

  (define (front-insert-deque! deque item)
    (let ((new-pair (cons item '())))
      (cond ((empty-deque? deque)
             (set-front-ptr! deque new-pair)
             (set-rear-ptr! deque new-pair)
             deque)
            (else
             (begin
               (let ((front (front-ptr-deque deque)))
                 (set-car! deque new-pair)
                 (set-cdr! (front-ptr-deque deque) front)))
             deque))))

  (define test (make-deque))
  (front-insert-deque! test 'a)
  (front-insert-deque! test 'b)
  (front-insert-deque! test 'c)

  (define queue (make-queue))
  (insert-queue! queue 'a)
  (insert-queue! queue 'b)
  (insert-queue! queue 'c)


  (define (rear-insert-deque! queue item)
    (let ((new-pair (cons item '())))
      (cond ((empty-deque? queue)
             (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             queue)
            (else
             (set-cdr! (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             queue))))

  (rear-insert-deque! test 'f)

   (define (rear-delete-deque! deque)
     (define (iter queue)
       (format #t "queue ~A deque ~A\n " queue deque)
       (if (null? (cdr (cdr queue)))
           (begin
             (set-cdr! deque (list (car queue)))
             (set-cdr! queue '()))
           (iter (cdr queue))))
    (cond ((empty-deque? deque)
           (error "DELETE! вызвана с пустой очередью" deque))
          (else
           (iter (car deque))))
           deque)

  (rear-delete-deque! test)

  (define (front-delete-deeue! deque)
    (cond ((empty-deque? deque)
           (error "DELETE! вызвана с пустой очередью" deque))
          (else
           (set-front-ptr! deque (cdr (front-ptr deque)))
           deque)))

#+END_SRC


~Упражнение 3.24.~
В реализациях таблиц в этом разделе ключи всегда проверяются на равенство
с помощью ~equal?~ (который, в свою очередь, зовется из ~assoc~). Это не всегда то, что
нужно. Например, можно представить себе таблицу с числовыми ключами, где
не требуется точного совпадения с числом, которое мы ищем, а нужно только
совпадение с определенной допустимой ошибкой. Постройте конструктор
таблиц ~make-table~, который в качестве аргумента принимает процедуру
~same-key?~ для проверки равенства ключей. ~Make-table~ должна возвращать
процедуру ~dispatch.~ через которую можно добраться до процедур ~lookup~
и ~insert!~ локальной таблицы.

Значит, нам нужно представлять таблицу как объект, который сгенерируется
mаke-table, при этом ~make-table~ должна принимать предикат, с помощью
которого мы будем искать значение в таблице. ИНыми словами, надо заменить ~assoc~
#+BEGIN_SRC scheme
  (define (make-table same-key?)
    (let ((local-table (list '*table*)))

      (define (lookup key-1 key-2)
        (let ((subtable (same-key? key-1 (cdr local-table))))
          (if subtable
              (let ((record (same-key? key-2 (cdr subtable))))
                (if record
                    (cdr record)
                    #f))
              #f)))

      (define (insert! key-1 key-2 value)
        (let ((subtable (same-key? key-1 (cdr local-table))))
          (if subtable
              (let ((record (same-key? key-2 (cdr subtable))))
                (if record
                    (set-cdr! record value)
                    (set-cdr! subtable
                              (cons (cons key-2 value)
                                    (cdr subtable)))))
              (set-cdr! local-table
                        (cons (list key-1
                                    (cons key-2 value))
                              (cdr local-table)))))
        'ok)
      (define (dispatch m)
        (cond ((eq? m 'lookup-proc) lookup)
              ((eq? m 'insert-proc!) insert!)
              (else (error "Неизвестная операция -- TABLE" m))))
      dispatch))


  (define test (make-table assoc))
  ((test 'insert-proc!) 'letter 'vowel 'A)
  ((test 'lookup-proc) 'letter 'vowel)
#+END_SRC

~Упражнение 3.25.~
Обобщая случаи одно- и двумерных таблиц, покажите, как можно реализовать
таблицу, в которой элементы хранятся с произвольным количеством ключей и
различные значения могут храниться с различным количеством
ключей. Процедуры lookup и insert! должны принимать на входе
список ключей, с которыми требуется обратиться к таблице.

Я сделала так, что мы теперь можем строить таблицы любой глубины, а не
только двухмерные.
#+BEGIN_SRC scheme
  (define (make-table same-key?)
    (let ((local-table (list '*table*)))

      (define (lookup keys)
        (define (iter table keys)
          (if (= (length keys) 1)
              (let ((record (same-key? (car keys) (cdr table))))
                (if record
                    (cdr record)
                    #f))
              (let ((subtable (same-key? (car keys) (cdr table))))
                (if subtable
                    (iter subtable (cdr keys))
                    #f))))
        (iter local-table keys))

      ;; эта процедура создаст субтаблицу со всеми ключами, при условии, что другой
      ;; субтаблицы нет
      ;; на самом деле, она скорее необходимым образом связывает все оставшиеся ключи и
      ;; значение, чтоб мы потом могли вставить их в нашу таблицу
      (define (make-subtable keys value)
        (if (= (length keys) 1)
            (cons (car keys) value)
            (list (car keys) (make-subtable (cdr keys) value))))

      (define (insert! keys value)
        (define (iter table keys value)
          ;; если ключ всего 1, значит таблица одномерная (или стала такой из-за рекурсии)
          (if (= (length keys) 1)
              (begin
              ;; ищем запись
              (let ((record (same-key? (car keys) (cdr table))))
                ;; если запись найдена,
                (if record
                    ;;заменяем значение в записи
                    (begin
                      (set-cdr! record value)
                      'ok)
                    (begin
                      ;; иначе добавляем новую запись
                      (set-cdr! table
                                (cons (cons (car keys) value)
                                      (cdr table)))
                      'ok))))
              ;; в случае если ключей 2, ищем первую подтаблицу
              (let ((subtable (same-key? (car keys) (cdr table))))
                ;; если нашли, отправляемся искать запись
                (if subtable
                    (iter subtable (cdr keys) value)
                    ;; иначе создаем новую подтаблицу
                    (begin
                      (set-cdr! table (cons (make-subtable keys value) (cdr table)))
                      'ok)))))
        (iter local-table keys value))


      (define (dispatch m)
        (cond ((eq? m 'lookup-proc) lookup)
              ((eq? m 'insert-proc!) insert!)
              ((eq? m 'print!) (format #t "~A\n" local-table))
              (else (error "Неизвестная операция -- TABLE" m))))
      dispatch))

  ;; первый тест
  ;; проверяет замещение элементов при условии, что у них один ключ
  (define test (make-table assoc))
  ((test 'insert-proc!) '(letter vowel) 'A)
  ((test 'insert-proc!) '(letter vowel) 'U)
  ((test 'lookup-proc) '(letter vowel))
  (test 'print!)
  ;; второй тест
  ;; проверяет добавление элементов с разными ключами в подтаблицу
  (define test (make-table assoc))
  ((test 'insert-proc!) '(letter consonant) 'C)
  ((test 'insert-proc!) '(letter vowel) 'U)
  ((test 'lookup-proc) '(letter consonant))
  ((test 'lookup-proc) '(letter vowel))

  ;;третий тест
  ;; проверяет добавление элементов с разным кол-вом ключей
  (define test (make-table assoc))
  ((test 'insert-proc!) '(letter consonant big) 'C)
  ((test 'insert-proc!) '(number) 6)
  ((test 'lookup-proc) '(number))
  ((test 'lookup-proc) '(letter consonant big))

#+END_SRC

~Упражнение 3.26.~
При поиске в таблице, как она реализована выше, приходится просматривать
список записей. В сущности, это представление с неупорядоченным списком из раздела
2.3.3. Для больших таблиц может оказаться эффективнее организовать
таблицу иначе.
Опишите реализацию таблицы, в которой записи (ключ, значение)
организованы в виде бинарного дерева, в предположении, что ключи
можно каким-то образом упорядочить (например, численно или по
алфавиту). (Ср. с упражнением 2.66 из главы 2.)

Видимо, речь идет об одномерной таблице, которая является по сути
бинарным деревом. То есть надо организовать бинарное дерево, элементы
которого - ассоциативные списки.

#+BEGIN_SRC scheme
  ;; (define test (list (cons 'en 4) (cons 'l 3) (cons 'r 5)))
  ;; (set-cdr! (cdr test) (list 2))

  (define (make-table)
    (let ((local-table '()))

      (define (make-node entry-elt right-branch left-branch)
        (list entry-elt right-branch left-branch))

      (define (entry-elt node)
        (car node))

      (define (left-branch node)
        (cadr node))

      (define (right-branch node)
        (caddr node))

      (define (get-key pair)
        (car pair))

      (define (get-value pair)
        (cdr pair))

      (define (insert! key value)
        (define (iter key value table)
          ;; таблица пустая, устанавлваем в нее корень
          (cond ((null? table) (set! local-table (make-node (cons key value) '() '())))
                ;; если ключ больше ключа текущего узла
                ((> key (get-key (entry-elt table)))
                 (if (null? (right-branch table))
                     ;; и при этом справа узлов нет,
                     ;; создаем новый лист
                     (begin
                       (set-cdr! (cdr table) (cons (make-node
                                                    (cons key value) '() '())
                                                   '()))
                       'ok)
                     ;; иначе идем по правой ветке
                     (iter key value (right-branch table))))
                ;; аналогичная логика, только ветка левая
                ((< key (get-key (entry-elt table)))
                 (if (null? (left-branch table))
                     (begin
                       (set-car! (cdr table) (make-node
                                              (cons key value) '() '()))
                       'ok)
                     (iter key value (left-branch table))))
                ;; если ключ = ключу текущего узла, устанавливаем новое значение для
                ;; этого ключа
                (else (set-car! table (cons key value)))))
          (iter key value local-table))

      (define (lookup key)
        (define (iter table key)
          (cond ((null? table) #f)
                ((> key (get-key (entry-elt table)))
                 (iter (right-branch table) key))
                ((< key (get-key (entry-elt table)))
                 (iter (left-branch table) key))
                (else (get-value (entry-elt table)))))
        (iter local-table key))


      (define (dispatch m)
        (cond ((eq? m 'lookup-proc) lookup)
              ((eq? m 'insert-proc!) insert!)
              ((eq? m 'print!) (format #t "~A\n" local-table))
              (else (error "Неизвестная операция -- TABLE" m))))
      dispatch))

  ;;тесты
  (define test (make-table))
  ;; пробуем вставлять элементы в таблицу
  ((test 'insert-proc!) 8 'A)
  ((test 'insert-proc!) 7 'B)
  ((test 'insert-proc!) 9 'C)
  ((test 'insert-proc!) 10 'F)
  ((test 'insert-proc!) 3 'G)

  (test 'print!)
  ;; пробуем найти элементы в таблице
  ((test 'lookup-proc) 7)
  ((test 'lookup-proc) 3)
  ((test 'lookup-proc) 1)
#+END_SRC

~Упражнение 3.28.~
Определите ИЛИ-элемент как элементарный функциональный блок. Ваш
конструктор ~or-gate~ должен быть подобен ~and-gate~.

Это все процедуры, которые нужны, чтоб запустить ~and-gate~
#+BEGIN_SRC scheme

  (define the-agenda (make-agenda))

  (define (make-agenda) (list 0))

  (define (current-time agenda) (car agenda))

  (define (set-current-time! agenda time)
    (set-car! agenda time))

  (define (segments agenda) (cdr agenda))

  (define (empty-agenda? agenda)
    (null? (segments agenda)))

  (define (set-segments! agenda segments)
    (set-cdr! agenda segments))

  (define (first-segment agenda) (car (segments agenda)))

  (define (rest-segments agenda) (cdr (segments agenda)))

  (define (make-time-segment time queue)
    (cons time queue))

  (define (segment-time s) (car s))

  (define (segment-queue s) (cdr s))

  (define (make-queue)
    (cons '() '()))

  (define (front-ptr queue) (car queue))

  (define (rear-ptr queue) (cdr queue))

  (define (set-front-ptr! queue item) (set-car! queue item))

  (define (set-rear-ptr! queue item) (set-cdr! queue item))

  (define (empty-queue? queue) (null? (front-ptr queue)))

  (define (front-queue queue)
    (if (empty-queue? queue)
        (error "FRONT вызвана с пустой очередью" queue)
        (car (front-ptr queue))))

  (define (insert-queue! queue item)
    (let ((new-pair (cons item '())))
      (cond ((empty-queue? queue)
             (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             queue)
            (else
             (set-cdr! (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             queue))))

  (define (call-each procedures)
    (if (null? procedures)
        'done
         (begin
           ((car procedures))
           (call-each (cdr procedures)))))

  (define (get-signal wire)
    (wire 'get-signal))

  (define (set-signal! wire new-value)
    ((wire 'set-signal!) new-value))

  (define (add-action! wire action-procedure)
    ((wire 'add-action!) action-procedure))

  (define (add-to-agenda! time action agenda)
    (define (belongs-before? segments)
      (or (null? segments)
          (< time (segment-time (car segments)))))
    (define (make-new-time-segment time action)
      (let ((q (make-queue)))
        (insert-queue! q action)
        (make-time-segment time q)))
    (define (add-to-segments! segments)
      (if (= (segment-time (car segments)) time)
          (insert-queue! (segment-queue (car segments))
                         action)
          (let ((rest (cdr segments)))
            (if (belongs-before? rest)
                (set-cdr!
                 segments
                 (cons (make-new-time-segment time action)
                       (cdr segments)))
                (add-to-segments! rest)))))
    (let ((segments (segments agenda)))
      (if (belongs-before? segments)
          (set-segments!
           agenda
           (cons (make-new-time-segment time action)
                 segments))
          (add-to-segments! segments))))

  (define (after-delay delay action)
    (add-to-agenda! (+ delay (current-time the-agenda))
                    action
                    the-agenda))

  (define (make-wire)
    (let ((signal-value 0) (action-procedures '()))
      (define (set-my-signal! new-value)
        (if (not (= signal-value new-value))
            (begin (set! signal-value new-value)
                   (call-each action-procedures))
            'done))
      (define (accept-action-procedure! proc)
        (set! action-procedures (cons proc action-procedures))
        (proc))
      (define (dispatch m)
        (cond ((eq? m 'get-signal) signal-value)
              ((eq? m 'set-signal!) set-my-signal!)
              ((eq? m 'add-action!) accept-action-procedure!)
              (else (error "Неизвестная операция -- WIRE" m))))
      dispatch))

#+END_SRC

Это сам ~and-gate~. ~logical-and~ написана самостоятельно,т.к. в мане ее
нет.

#+BEGIN_SRC scheme

  (define and-gate-delay 3)

  (define (logical-and s1 s2)
    (if (and (= s1 1) (= s2 1))
        1
        0))

  (define (and-gate a1 a2 output)
    (define (and-action-procedure)
      (let ((new-value
             (logical-and (get-signal a1) (get-signal a2))))
        (after-delay and-gate-delay
                     (lambda ()
                       (set-signal! output new-value)))))
    (add-action! a1 and-action-procedure)
    (add-action! a2 and-action-procedure)
    'ok)


#+END_SRC

А это сам ответ для задания.

#+BEGIN_SRC scheme
  (define (logical-or s1 s2)
    (if (or (= s1 1) (= s2 1))
        1
        0))

  (define (or-gate a1 a2 output)
    (define (or-action-procedure)
      (let ((new-value
             (logical-or (get-signal a1) (get-signal a2))))
        (after-delay or-gate-delay
                     (lambda ()
                       (set-signal! output new-value)))))
    (add-action! a1 or-action-procedure)
    (add-action! a2 or-action-procedure)
    'ok)

#+END_SRC

~Упражнение 3.29.~
Еще один способ создать ИЛИ-элемент — это собрать его как составной блок
из И-элементов и инверторов. Определите процедуру ~or-gate~, которая это
осуществляет.
Как время задержки ИЛИ-элемента выражается через ~and-gate-delay~ и
~inverter-delay~?

Идея простая:
- поменяем значение каждого входного провода на противоположные
- проверим их через "И"
- если сигнал выходного провода "И" = 1, значит оба входных провода "И"
  имели значение единицы, которое они приобрели после того, как мы
  изменили сигналы входных проводов на противоположные. То есть
  изначально входные сигналы были 0. Если оба входных сигнала "ИЛИ" имеют
  значения нуля, то вернется 0. Во всех остальных случаях вернется 1.
Поэтому в случае если ответ "И" = 1, мы на выходе получим 0, а во всех
остальных случаях 1.

В данном случае задержка ~or-gate~ будет равна сумме всех задержек от
примеренения "НЕ" и "И". Скажем, если зажержка инвертора = 2, а задержка
"ИЛИ" = 3, то задержка этой версии ~or-gate~ = 9, поскольку инвертор мы
примнеили 3 раза, а логическое "N" - 1 раз.

#+BEGIN_SRC scheme
  (define (or-gate a1 a2 output)
    (define (or-action-procedure)
      (let* ((new-a1 (make-wire))
             (new-a2 (make-wire)))
        (inverter a1 new-a1)
        (inverter a2 new-a2)
        (let* ((and-result (make-wire)))
          (and-gate new-a1 new-a2 and-result)
          (inverter and-result output))))
    (add-action! a1 or-action-procedure)
    (add-action! a2 or-action-procedure)
    'ok)
#+END_SRC


~Упражнение 3.30.~
На рисунке 3.27 изображен каскадный сумматор ~(ripple-carry adder)~,
полученный выстраиванием в ряд n сумматоров. Это простейшая форма
параллельного сумматора для сложения двух n-битных двоичных чисел. На
входе мы имеем A1 , A2 , A3 ,. . . An и B1 , B2 , B3 , . . . Bn — два двоичных чис-
ла, подлежащих сложению (каждый из Ak и Bk имеет значение либо 0, либо
1). Схема порождает S1 , S2 , S3 , . . . Sn — первые n бит суммы, и C –
бит переноса после суммы. Напишите процедуру ~riple-carry-adder~, которая
бы моделировала эту схему. Процедура должна в качестве аргументов
принимать три списка по n проводов в каждом (Ak , Bk и Sk ), а
также дополнительный провод C. Главный недостаток каскадных сумматоров в
том, что приходится ждать, пока сигнал распространится. Какова задержка,
требуемая для получения полного вывода n-битного каскадного сумматора,
выраженная в зависимости от задержек И-, ИЛИ-элементов и инверторов?

Сумматоры и полусумматоры нужны, чтоб сложить 2 числа.
Полусумматор:
- обеспечивает сложение в пределах одного разряда без учета единицы,
  которая могла быть получены в результате сложения в предыдущем разряде.
- при этом если присложении текущего разряда мы получим единицу для
  переноса в следующий,она будет занесена в параметр "с"

Сумматор:
- работает аналогично полусумматору, но учитывает единицу, которую мы
  могли получить при сложении в предыдущем разряде. Поэтому имеет 3
  входа: 2 слагаемых и единица из предыдущего разряда.

Таким образом понятно, что все это работает только на одном разряде. А
что если в числах 5 разрядов? Сто?
Для этого нужен каскадный сумматор. Фактически он представляет из себя
полный сумматор, вызванный столько раз, сколько разрядов в самом большом
числе.

Задержка будет огромной. Чтоб ее посчитать, нужно сложить все задержки от
всех вызовов ~or-gate~, ~and-gate~ и ~inverter~ на одной итерации
сложения и умножить эту сумму на количество битов в самом большом
числе. И задержка будет увеличиваться пропорционально увеличению
количества разрядов, т.е. сложность алгоритма О(n).

#+BEGIN_SRC scheme
  ;; полусумматор
  ;; а и b - это входы, S и С - выходы.
  ;; S - это сумма, С - бит, который перейдет в следующий разряд
  (define (half-adder a b s c)
    ;;создаем дополнительные провода
    (let ((d (make-wire)) (e (make-wire)))
      (or-gate a b d)
      (and-gate a b c)
      (inverter c e)
      (and-gate d e s)
      'ok))

  ;;  сумматор
  ;;А В - это входны (слагаемые), c-in - бит, доставшийся нам от сложения предыдущего
  ;; раззряда. sum - сумма и c-out - бит, который будет перенесен в следующий разряд
  ;; (если мы этот бит получим)
  (define (full-adder a b c-in sum c-out)
    (let ((s (make-wire))
          (c1 (make-wire))
          (c2 (make-wire)))
      (half-adder b c-in s c1)
      (half-adder a s sum c2)
      (or-gate c1 c2 c-out)
      'ok))

  (define (riple-carry-adder a-list b-list s-list c-wire)
      ;; если оба списка слагаемых кончились, сложение окончено
      (cond ((and (null? a-list) (null? a-list)) 'ok)
            ;; если список проводов для суммы закончился, прекращаем работу
            ;; поскольку писать больше некуда
            ((null? s-list) 'ok)
            ;; если закончился один из списков, заполняем недостающие разряды нулями
            ((null? a-list)
             (begin
               (full-adder 0 (car b-list) c-wire (car s-list) c-wire)
               (riple-carry-adder a-list (cdr b-list) (cdr s-list) c-wire)))
            ((null? b-list)
             (begin
               (full-adder (car a-list) 0 c-wire (car s-list) c-wire)
               (riple-carry-adder (cdr a-list) b-list (cdr s-list) c-wire)))
            (else
             (begin
               (full-adder (car a-list) (car b-list) c-wire (car s-list) c-wire)
               (riple-carry-adder (cdr a-list) (cdr b-list) (cdr s-list) c-wire)))))


  (define a1 (make-wire))
  (define a2 (make-wire))
  (set-signal! a2 1)
  (define a-list (list a1 a2))

  (define b1 (make-wire))
  (define b2 (make-wire))
  (define b-list (list b1 b2))

  (define s1 (make-wire))
  (define s2 (make-wire))
  (define s-list (list s1 s2))

  (define c-wire (make-wire))

  (riple-carry-adder a-list b-list s-list c-wire)
#+END_SRC

~Упражнение 3.31.~
Внутренняя процедура ~accept-action-procedure!~, определенная в ~make-wire~,
требует, чтобы в момент, когда процедура-действие добавляется к проводу, она
немедленно исполнялась. Объясните, зачем требуется такая инициализация.
В частности, проследите работу процедуры ~half-adder~ из этого текста и
скажите, как отличалась бы реакция системы, если бы ~accept-action-
procedure!~ была определена как

#+BEGIN_SRC scheme
  (define (accept-action-procedure! proc)
    (set! action-procedures (cons proc action-procedures)))
#+END_SRC

Ответ: механизм исполнения процедур, которые попали в список процедур для
конкретного провода, заработает только в том случае, если в провод будет
установлен сигнал, который при этом не совпадает с предыдущим. В случае с
работой ~half-addler~, сигнал в проводах изменится благодаря вызову
~set-signal!~, который есть в процедурах ~and-gate~, ~or-gate~ и
~inverter~. Но заковыка в том, ~half-addler~ сам по себе не заработает:
это случится только тогда, когда изменится сигнал у проводов. Для этого
нам и нужен вызов добавляемой процедры в список исполняемых процедур: в
противном случае просто нечему запустить механизм исполнения процедур,
добавленных в список, и программа просто не заработает.

~Упражнение 3.32.~
Процедуры, предназначенные к выполнению в каждом временном отрезке,
хранятся в виде очереди. Таким образом, процедуры для каждого отрезка
вызываются в том же порядке, в котором они были добавлены к плану (первый
пришел, первый ушел).
Объясните, почему требуется использовать именно такой порядок. В
частности, проследите поведение И-элемента, входы которого
меняются с 0 на 1 и с 1 на 0 одновременно и скажите, как отличалось бы
поведение, если бы мы хранили процедуры отрезка в обыкновенном списке,
добавляя и убирая их только с головы (последний пришел, первый ушел).

Ответ: при работе любого механизма нам необходим порядок действий, в
противном случае ни один алгоритм не заработает. Если попросить человека
напистаь на бумажке любой алгоритм по пунктам на бумажке, то человек начнет его
писать сверху вниз, т.к. первое действие будет записано первым, никто е
начнет писать алгоритм с конца. Таким образом мы получаем структуру
"первым записали - первым исполнили", что очень близко к опеределению
машинной очереди "первым пришел - первым ушел". Если бы мы использовали
обычные списки, то действия пришлось бы добавлять с конца, чтоб в ~car~
списка оказалось первое по порядку действие. Я уже молчу о том, что если
бы нампонадобилось добавить новое действие,котоое должно было бы
исполниться после всех уже имеющихся, пришлосьбы переписать весь список
от начала до конца. А это расходы и по памяти, и по времени.

~Упражнение 3.33.~
С помощью элементарных ограничений (сумматор, умножитель и константа),
определите процедуру ~averager~ (усреднитель), которая принимает три
соединителя a, b и c,
и обеспечивает условие, что значение c равно среднему арифметическому
значений a и b.

Процедуры, необходимые для функционирования системы.

#+BEGIN_SRC scheme

  (define (constant value connector)
    (define (me request)
      (error "Неизвестный запрос -- CONSTANT" request))
    (connect connector me)
    (set-value! connector value me)
    me)

  (define (inform-about-value constraint)
    (constraint 'I-have-a-value))

  (define (inform-about-no-value constraint)
    (constraint 'I-lost-my-value))

  ;; порождает сумматор, который уявляется возвращаемым значением
  ;; сумматор представляет собой диспетчер для внутренних процедур
  (define (adder a1 a2 sum)
    ;; установка нового значения суммы или слагаемых
    (define (process-new-value)
      ;; у обеих переменных есть значения? - складываем их и устанавливаем в sum
      (cond ((and (has-value? a1) (has-value? a2))
             (set-value! sum
                         (+ (get-value a1) (get-value a2))
                         me))
            ;; известна сумма и первая переменная? - вычисляем вторую как разность суммы
            ;; и первой переменной
            ((and (has-value? a1) (has-value? sum))
             (set-value! a2
                         (- (get-value sum) (get-value a1))
                         me))
            ;; аналогично, только устанавливаем значение первой переменной
            ((and (has-value? a2) (has-value? sum))
             (set-value! a1
                         (- (get-value sum) (get-value a2))
                         me))))
    ;; "забываем" все значения
    (define (process-forget-value)
      (forget-value! sum me)
      (forget-value! a1 me)
      (forget-value! a2 me)
      (process-new-value))

    ;; сумматор
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
             (process-new-value))
            ((eq? request 'I-lost-my-value)
             (process-forget-value))
            (else
             (error "Неизвестный запрос -- ADDER" request))))

    ;; подсоединяем слагаемые и сумму к сумматору
    (connect a1 me)
    (connect a2 me)
    (connect sum me)
    me)

  ;; исполняет все процедуры в списке, коме исключения
  (define (for-each-except exception procedure list)
    (define (loop items)
      (cond ((null? items) 'done)
            ((eq? (car items) exception) (loop (cdr items)))
            (else (procedure (car items))
                  (loop (cdr items)))))
    (loop list))

  ;; создает соединитель
  ;; соединительпредставляет собой объект, имеющий 3 переменных состояния:
  ;; значение, информант, который это значение установил, и список всех ограничений, в
  ;; которых участвует этот сеодинитель
  (define (make-connector)
    ;; начальные значения всех переменных состояния - false
    (let ((value #f) (informant #f) (constraints '()))
      ;; устанавливаем новое значение
      (define (set-my-value newval setter)
        ;; если у соединтеля нет текущего значения
        (cond ((not (has-value? me))
               ;; устанавливаем значение
               (set! value newval)
               ;; запоминаем ограничение, которое значение установило
               (set! informant setter)
               ;; исполняем список ограничений, кроме текущего
               (for-each-except setter
                                inform-about-value
                                constraints))
              ;; если же у соединения значение было и оно не совпадает с новым
              ((not (= value newval))
               ;; выдаем сообщение об ошибке
               (error "Противоречие" (list value newval)))
              ;; все остальное игнорим
              (else 'ignored)))

      ;; стираем значение соединителя
      (define (forget-my-value retractor)
        ;; если стереть значение хочет то же ограничение, что его установило,
        (if (eq? retractor informant)
            ;; то стираем ограничение
            (begin (set! informant #f)
                   ;; выполняем список всех ограничений кроме текущего
                   (for-each-except retractor
                                    inform-about-no-value
                                    constraints))
            'ignored))

      ;;подсоединяем новое ограничение к списку
      (define (connect new-constraint)
        ;; если нового ограничения в списке нет, то подсоединяем его к списку ограничений
        (if (not (memq new-constraint constraints))
            (set! constraints
                  (cons new-constraint constraints)))
        ;; если значение у соединителя есть,
        (if (has-value? me)
            ;; заносим это в список ограничений (?)
            (inform-about-value new-constraint))
        'done)
      (define (me request)
        (cond ((eq? request 'has-value?)
               (if informant #t #f))
              ((eq? request 'value) value)
              ((eq? request 'set-value!) set-my-value)
              ((eq? request 'forget) forget-my-value)
              ((eq? request 'connect) connect)
              (else (error "Неизвестная операция -- CONNECTOR"
                           request))))
      me))

  ;; "умножитель" полностью копирует поведение "сумматора", только вместо операции сложения,
  ;; использует умножение
  (define (multiplier m1 m2 product)
    (define (process-new-value)
      (cond ((or (and (has-value? m1) (= (get-value m1) 0))
                 (and (has-value? m2) (= (get-value m2) 0)))
             (set-value! product 0 me))
            ((and (has-value? m1) (has-value? m2))
             (set-value! product
                         (* (get-value m1) (get-value m2))
                         me))
            ((and (has-value? product) (has-value? m1))
             (set-value! m2
                         (/ (get-value product) (get-value m1))
                         me))
            ((and (has-value? product) (has-value? m2))
             (set-value! m1
                         (/ (get-value product) (get-value m2))
                         me))))
    (define (process-forget-value)
      (forget-value! product me)
      (forget-value! m1 me)
      (forget-value! m2 me)
      (process-new-value))
    (define (me request)
      (cond ((eq? request 'I-have-a-value)
             (process-new-value))
            ((eq? request 'I-lost-my-value)
             (process-forget-value))
            (else
             (error "Неизвестный запрос -- MULTIPLIER" request))))
    (connect m1 me)
    (connect m2 me)
    (connect product me)
    me)

  ;; устанавливает значение данного соединителя
  (define (constant value connector)
    (define (me request)
      (error "Неизвестный запрос -- CONSTANT" request))
    (connect connector me)
    (set-value! connector value me)
    me)

  ;; процедуры интерфейса
  (define (has-value? connector)
    (connector 'has-value?))

  (define (get-value connector)
    (connector 'value))

  (define (set-value! connector new-value informant)
    ((connector 'set-value!) new-value informant))

  (define (forget-value! connector retractor)
    ((connector 'forget) retractor))

  (define (connect connector new-constraint)
    ((connector 'connect) new-constraint))
#+END_SRC

Вычисляем среднее арифметическое по формуле: (а + в) / 2 = с

#+BEGIN_SRC scheme
  (define (averager a b c)
    (let ((const (make-connector))
          (sum (make-connector)))
      ;; получаем сумму a + b
      (adder a b sum)
      (constant 2 const)
      (multiplier const c sum)))

  ;; тест 1
  (define a (make-connector))
  (define b (make-connector))
  (define c (make-connector))

  (set-value! a 54 'user)
  (set-value! b 38 'user)

  (define result (averager a b c))
  (get-value c)

  ;; тест 2
  (forget-value! a 'user)
  (forget-value! b 'user)
  (set-value! a 100 'user)
  (set-value! b 200 'user)
  (define result (averager a b c))
  (get-value c)
#+END_SRC

~Упражнение 3.34.~
Хьюго Дум хочет построить квадратор, блок-ограничение с двумя выводами,
такое, что значение соединителя b на втором выводе всегда будет равно
квадрату значения соединителя a на первом выводе. Он предлагает следующее
простое устройство на основе умножителя:

#+BEGIN_SRC scheme
  (define (squarer a b)
    (multiplier a a b))
#+END_SRC

В такой идее есть существенная ошибка. Объясните ее.

На первый взгляд все должно сработать. Но мы знаем, что у нас не
однонаправленные вычисления: наш умножитель может вычислять как
произведение, так и множитель, имея произведение и другой множитель.
В случае, если у нас неизвестно "а", умножитель просто застопорится,
поскольку не сможет вычислить ни произведение, ни второй множитель. Таким
образом он становится однонаправленным.

~Упражнение 3.35.~
Бен Битобор объясняет Хьюго, что один из способов избежать неприятностей
в упражнении 3.34 — определить квадратор как новое элементарное ограничение. Заполните
недостающие части в Беновой схеме процедуры, реализующей такое ограничение:

#+BEGIN_SRC scheme
  ;; необходимые процедуры для поиска квадратного корня
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x)
                   x)))

  (define (average x y)
    (/ (+ x y) 2))

  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))

  (define (square x)
    (* x x ))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (sqrt x)
    (sqrt-iter 1.0 x))

  ;; дописанное ограничение
  (define (squarer a b)
    (define (process-new-value)
      (if (has-value? b)
          (if (< (get-value b) 0)
              (error "квадрат меньше 0 -- SQUARER" (get-value b))
              (set-value! a (sqrt (get-value b)) me))
          (if (has-value? a)
              (set-value! b (* (get-value a) (get-value a)) me)
              'ignored)))

    (define (process-forget-value)
      (forget-value! a me)
      (forget-value! b me))

    (define (me request)
      (cond ((eq? request 'I-have-a-value)
             (process-new-value))
            ((eq? request 'I-lost-my-value)
             (process-forget-value))
            (else
             (error "Неизвестный запрос -- SQUARER" request))))
    (connect a me)
    (connect b me)
    me)

  ;;тест
  (define c (make-connector))
  (define d (make-connector))
  (define test (squarer c d))

  (set-value! c 4 'user)
  (get-value d)

  (forget-value! c 'user)
  (forget-value! d 'user)

  (set-value! d 18 'user)
  (define test2 (squarer c d))
  (get-value c)
#+END_SRC

~Упражнение 3.36.~

Допустим, что мы выполняем следующую последовательность действий в
глобальном окружении:

#+BEGIN_SRC scheme
(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
#+END_SRC

В какой-то момент при вычислении ~set-value!~ будет выполнено следующее
выражение из внутренней процедуры соединителя:

#+BEGIN_SRC scheme
(for-each-except setter inform-about-value constraints)
#+END_SRC

Нарисуйте диаграмму, изображающую окружение, в котором выполняется
указанное выражение.

Итак, функция ~make-connector~, которая создает соединитель, создает и
окружение, куда входит процедура ~set-my-value~, которая вызове
~for-each-except setter~, которая в свою очередь определена глобально.

Итак, мы создали 2 коннектора в глобальном окружении, вызываем
~set-value!~.  Эта функция внутри себя вызывает ~me~, который отвечает за
диспетчеризацию внутри соединителя и представления его как
объекта. Оказываемся внутри окружения соединителя, ~me~ возвращает нам
процедуру ~set-my-value~, поскольку она сооветствует запросу и находится
в окружении соединителя, но определена до ~me~,поэтому ~me~имеет к ней
доступ. Заходим внутрь проедуры ~set-my-value~,оказываемся на втором
уровне вложенности: глобальное окружение -> окружение соединителя ->
окружение ~set-my-value~. Доходим до исполнения
~(for-each-except setter inform-about-value constraints)~. В поиске
процедуры интерпритатор будет подниматься все выше по уровню вложенности,
пока не дойдет до глобального окружения. Поскольку процедура там есть, мы
можем спокойно ею воспользоваться. То есть ~for-each-exept~ будет
исполнена в окружении, которое сгенерит процедура ~set-my-value~.

~Упражнение 3.37.~
Процедура ~celsius-fahrenheit-converter~ выглядит громоздко по сравнению со
стилем определения в формате выражения:

#+BEGIN_SRC scheme
  (define (celsius-fahrenheit-converter x)
    (c+ (c* (c/ (cv 9) (cv 5))
            x)
        (cv 32)))

  (define C (make-connector))

  (define F (celsius-fahrenheit-converter C))
#+END_SRC

Здесь c+, c* и т. п. — «ограничительные» версии арифметических
операций. Например, c+ берет в виде аргументов два соединителя, и
возвращает соединитель, который связан с ними ограничением-сумматором:

#+BEGIN_SRC scheme
  (define (c+ x y)
    (let ((z (make-connector)))
      (adder x y z)
      z))
#+END_SRC

Определите аналогичные процедуры для c-, c*, c/ и cv (константа), так,
чтобы можно было определять составные ограничения, как в вышеприведенном
примере.

#+BEGIN_SRC scheme
  (define (c* x y)
    (let ((product (make-connector)))
      (multiplier x y product)
      product))

  (define (c- x y)
    (let ((diff (make-connector)))
      (adder y diff x)
      diff))

  (define (c/ x y)
    (let ((quotient (make-connector)))
      (multiplier y quotient x)
      quotient))

  (define (cv val)
    (let ((const (make-connector)))
      (constant val const)
      const))

#+END_SRC

~Упражнение 3.38.~
Пусть Петр, Павел и Мария имеют общий счет, на котором вначале лежит 100
долларов. Петр кладет на счет 10 долларов, одновременно с этим Павел берет 20, а Мария
берет половину денег со счета. При этом они выполняют следующие операции:

#+BEGIN_SRC scheme
  ;; Петр:
  (set! balance (+ balance 10))
  ;; Павел:
  (set! balance (- balance 20))
  ;; Мария:
  (set! balance (- balance (/ balance 2)))
#+END_SRC

а. Перечислите возможные значения balance после завершения операций,
предполагая, что банковская система требует от транзакций исполняться
последовательно в каком-то порядке.
б. Назовите какие-нибудь другие значения, которые могли бы получиться,
если бы система разрешала операциям чередоваться. Нарисуйте временные
диаграммы, подобные рис. 3.29, чтобы объяснить, как возникают такие результаты.

А:

Предположим, что операции исполняются в том порядке, в котором они даны в
задании: т.е. сначала к счету обращается Петр, потом Павел, потом Мария.
Перед тем, как Петр обратился к счету, балан счета 100$.
Петр заносит на счет 10$: баланс счета 110$ долларов
Павел снимает 20$ со счета: баланс 90$
Мария снимает со счета половину имеющейся суммы: баланс 45$.

Б:
Предположим, Петр обращается к счету первым. Балас счета 100$,но между
проверкой баланса и снятием денег ПЕтром, к счету успевает обратиться
Павел и забирает оттуда 20$,в результате проверка баланса Петром уже
теряет актуальность, хотя и не мешает исполнению операции: но только
баланс после занесения 10 долларов на счет будет не 110, как раньше,
а 90. А если предположить, что между операциями и Петра и Павла
вклинилась еще и Мария, то последствия несколько непредсказуемы: кому-то
может банально не хватить денег, если бы суммы были бОльшими.

~Упражнение 3.39.~
Какие из пяти возможных исходов параллельного выполнения сохраняются,
если мы сериализуем выполнение таким образом:

#+BEGIN_SRC scheme
  (define x 10)

  (define s (make-serializer))

  (parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))
                    (s (lambda () (set! x (+ x 1)))))
#+END_SRC

Вариант 1.
Итак, отличие от мановского варианта в том, что в первой процедуре мы
имеем не ~(set! x (* x x))~, ~(set! x (lambda () (* x x)))~, и вот лямбда
уже сериализована.
Значит, у нас сериализована вторая процедура и внутренняя лямбда в первой,
а значит, технически может сложиться ситуация, когда  первая процедура
начнет исполнятся, в это время включится вторая. Первая процедура считает
~x~ в значении 10, в это время вторая процедура увеличит на ~1~, закончит
выполнение. Но первой процедуре это неважно, посольку значение ~x~ было
уже считано из памяти, и теперь только осталось возвести его в квадрат.
Получем ~ответ 100~ .

Вариант 2.
Вторая процедура увеличивает ~x~ на 1, ~x = 11~, в этом время первая
процедура считывает значение из памяти возводит его в квадрат, ~ответ 121~.

Вариант 3.
Начинает исполняться первая процедура, возводит ~x~ в квадрат, затем
исполняется вторая процедура. ~Ответ 101~.

~Упражнение 3.40.~
Укажите все возможные значения ~x~ при выполнении

#+BEGIN_SRC scheme
  (define x 10)
  (parallel-execute (lambda () (set! x (* x x)))
                    (lambda () (set! x (* x x x))))
#+END_SRC

Какие из них сохраняются, если вместо этого мы выполняем сериализованные
процедуры:

#+BEGIN_SRC scheme
  (define x 10)
  (define s (make-serializer))
  (parallel-execute (s (lambda () (set! x (* x x))))
                    (s (lambda () (set! x (* x x x)))))
#+END_SRC

Все варианты ~x~ при параллельном, несериализованном исполнении указанных
лямбд:
а) Первая лямбда возводит ~x~ в квадрат, затем вторая лямбда возводит
результат первой процедуры в куб. ~Ответ 1 000 000~.
б) Вторя лямбда возводит ~x~ в куб, затем первая лямбда возводит
результат в квадрат. ~Ответ 1 000 000~
в) Первая лямбда считывает значение ~x~, затем вторая лямбда успевает
изменить значение ~x~,первая лямбда считывает его 2 раз, ~ответ 10 000~
г) Вторая лямбда считывает ~x~ первый раз, затем первая лямбда
устанавливает новое значение ~x~, и вторая лямбда считывает его второй и
третий раз. ~Ответ 100 000~
д) Вторая лямбда успевает считать значение ~x~ два раза, прежде чем
первая лямбда изменит его. Затем вторая лямбда считывает его третий
раз. ~Ответ 10 000~

Если воспользоваться сериализацией, то процедуры смогут исполняться
только по очереди, а значит, исполянтся только варианты ~a~ и ~б~.

~Упражнение 3.41.~
Бен Битобор считает, что лучше было бы реализовать банковский счет таким
образом (измененная строка отмечена комментарием):

#+BEGIN_SRC scheme
  (define (make-account balance)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Недостаточно денег на счете"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (let ((protected (make-serializer)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) (protected withdraw))
              ((eq? m 'deposit) (protected deposit))
              ((eq? m 'balance)
               ((protected (lambda () balance)))) ; сериализовано
              (else (error "Неизвестный запрос -- MAKE-ACCOUNT"
                           m))))
      dispatch))
#+END_SRC

поскольку несериализованный доступ к банковскому счету может привести к
неправильному поведению. Вы согласны? Существует ли сценарий, который демонстрирует
обоснованность беспокойства Бена?

Ответ:
в принципе, идея перестраховаться лишней не бывает. В конкретном случае
Бен прав, хотя и возвращение значения баланса не изменяет никакое
состояние, но мозможен такой сценарий:
предположим у нас 2 процесса, которые имеют доступ к одному
счету. Предположим, первый снимает деньги, а второй запрашивает баланс
счета, и если сумма на счету его устраивает, то выполняет какие-то
операции (которые у нас пока даже не определены). В результате у нас оба
процесса считывают значение баланса, затем первый процесс это значение
меняет, но второй процесс об этом ничего не знает, он-то значение уже
считал. В результате у нас параллельно существует 2 состояния одного и
того же счета. Последствия из-за этого могут быть крайне неблагприятные.

~Упражнение 3.42.~
Бен Битобор говорит, что слишком расточительно в ответ на каждое
сообщение ~withdraw~ и ~deposit~ создавать по новой сериализованной
процедуре. Он говорит, что можно изменить ~make-account~ так, чтобы все
вызовы ~protected~ происходили вне процедуры ~dispatch~. Таким образом,
счет будет возвращать одну и ту же сериализованную процедуру
(созданную тогда же, когда и сам счет) каждый раз, когда у него просят
процедуру снятия денег:

#+BEGIN_SRC scheme
  (define (make-account balance)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Недостаточно денег на счете"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (let ((protected (make-serializer)))
      (let ((protected-withdraw (protected withdraw))
            (protected-deposit (protected deposit)))
        (define (dispatch m)
          (cond ((eq? m 'withdraw) protected-withdraw)
                ((eq? m 'deposit) protected-deposit)
                ((eq? m 'balance) balance)
                (else (error "Неизвестный запрос -- MAKE-ACCOUNT"
                             m))))
        dispatch)))
#+END_SRC

Безопасно ли такое изменение? В частности, есть ли разница в том, в каком
порядке может происходить параллельное выполнение в этих двух версиях
~make-account~?

Я считаю, что поведение процедур будет корректным, и изменение безопасно,
поскольку процедуры все равно сериализованы тем или иным способом. С
точки зрения ресурсов этот вариант более эргономичен.

~Упражнение 3.44.~
Рассмотрим задачу переноса денег с одного счета на другой. Бен Битобор
утверждает, что ее можно решить с помощью следующей процедуры, даже в тех
случаях, когда много людей одновременно перемещают деньги между
различными счетами, если использовать при этом какой-то механизм,
сериализующий операции занесения на счет и снятия со счета, например,
версию ~make-account~ из нашего текста.
#+BEGIN_SRC scheme
  (define (transfer from-account to-account amount)
    ((from-account 'withdraw) amount)
    ((to-account 'deposit) amount))
#+END_SRC

Хьюго Дум считает, что с этой версией возникнут проблемы и что нужно
использовать более сложный подход, вроде того, который требуется при решении задачи
обмена. Прав ли он? Если нет, то в чем состоит существенная разница между
задачей перевода денег и задачей обмена счетов? (Нужно предположить, что
значение баланса на from-account по крайней мере равно amount.)

Ответ:
Ситуация двоякая: правота Хьюго зависит от того, в каком порядке будут
исполняться операции. Да, снятие и занесение денег на счет защищены
сериализаторами, но они защищены по отедльности, а не как лок операций.
Предположим, у нас есть счет 1, 2 и 3 и два клиента банка.

Павел снимает деньги, в это время никакая другая процедура не может
получить доступ к этой же операции на этом счету. Предположим, что у нас
на счету 100$, а Павел хочет снять 101. Разумеется, это приведет к
ошибке. Но что если в этот же самый момент Петр кладет на счет 150
долларов? Тогда данные, которые есть у Павла уже не актуальны, поскольку
значение переменной ~balance~ было обновлено.

Но в общем случае процедура, предложенная Беном будет работать, поскольку
мы будем сначала снимать деньги со счета, а потом класть. Предположим,
что Петр и Павел оба хотят снять деньги с одного и того же счета. Петр
оказался первым, а значит, Павел будет ждать, пока он не закончит,
поскольку процедура снятия защищена сериализатором. Переменная ~balance~
будет перезаписана, а значит, Павел получит актуальные данные. То есть у
нас не окажется ситуации, когда где-то в системе параллельно будет
существовать 2 состояния баланса одного и того же счета.

~Упражнение 3.45.~
Хьюго Дум полагает, что теперь, когда операции снятия денег со счета и
занесения их на счет перестали сериализовываться автоматически, система
банковских счетов стала неоправданно сложной и работать с ней правильным
образом чересчур трудно. Он предлагает сделать так, чтобы
~make-account-and-serializer~ экспортировал сериализатор (для использования в
процедурах вроде ~serialized-exchange~), и вдобавок сам использовал его
для сериализаци простых операций со счетом, как это делал ~make-account~.
Он предлагает переопределить объект-счет так:

#+BEGIN_SRC scheme
  (define (make-account-and-serializer balance)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Недостаточно денег на счете"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (let ((balance-serializer (make-serializer)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) (balance-serializer withdraw))
              ((eq? m 'deposit) (balance-serializer deposit))
              ((eq? m 'balance) balance)
              ((eq? m 'serializer) balance-serializer)
              (else (error "Неизвестный запрос -- MAKE-ACCOUNT"
                           m))))
      dispatch))

  (define (deposit account amount)
    ((account 'deposit) amount))

  (define (exchange account1 account2)
    (let ((difference (- (account1 'balance)
                         (account2 'balance))))
      ((account1 'withdraw) difference)
      ((account2 'deposit) difference)))

  (define (serialized-exchange account1 account2)
    (let ((serializer1 (account1 'serializer))
          (serializer2 (account2 'serializer)))
      ((serializer1 (serializer2 exchange))
       account1
       account2)))
#+END_SRC

Объясните, в чем Хьюго ошибается. В частности, рассмотрите, что
происходит при вызове ~serialized-exchange~.

Рассматриваем мановский вариант работы процедуры.
Вызываем ~serialized-exchange~. Получаем сериализаторы первого и второго
счетов, сохраняем их в локальные переменные. Блочим вторым сериализатором
процедуру ~exchange~, которая снимает разницу между балансом первого и
второго счета с первого счета и докладывает ее на второй, а сверху блочим
это все вторым сериализатором.Что это дает?
Пока оба сериализатора не "отпустят" процедуру, никакой другой процесс не
сможет ею воспользоваться. Так мы предоствращаем ситуацию, когда между
высчитыванием разицы между балансами и изменением состояния счетов
вклинивается второй процесс и меняет состояние баланса на счете. Он может
это сделать, поскольку у нас защищены операции зпрашивания баланса,
снятия и занесения денег, но не защищены "переходы" между ними:
т. е. после запрашивания баланса сериализатор  "отпускает" счет, а затем
должен снова его заблочить для дальнейших операций. И именно в этот
момент счет может перехватить другой процесс.

Теперь рассмотрим вариант, когда процедура исполняется с вариантом
Хьюго.
У нас один и тот же сериализатор экспортируется счетом и используется для
блокировки его же процедур.
Вызывается процедура ~serialized-exchange~. Получаем сериализаторы обоих
счетов и сохраняем их в локальные переменные. Блочим обоими
сериализаторами вызов ~exchange~. В процедуре ~exchange~ пытаемся
получить баланс первого счета, но это невозможно: сериализатор занят
блокированием ~exchange~,в результате мы будем вечно ждать, пока
сериализатор освободится, а освободиться он не сможет, потому что ~exchange~
никогда не закончит свое исполнение (?)

~шпаргалка по реализации мьютекса~

#+BEGIN_SRC scheme
  ;; создает сериализованную процедуру
  (define (make-serializer)
    ;; создаем мьютекс
    (let ((mutex (make-mutex)))
      (lambda (p)
        (define (serialized-p . args)
          ;; захватываем мьюеткс
          (mutex 'acquire)
          ;; применяем процедуру к аргументам
          (let ((val (apply p args)))
            ;; освободаем мьютекс
            (mutex 'release)
            ;; возвращаем полученные значения
            val))
        serialized-p)))

  ;; проверяем значение мьютекса и устанавливаем новое, если
  ;; мьюеткс не занят
  (define (test-and-set! cell)
    ;; мьютекса занят?
    (if (car cell)
        ;; да
        #t
        ;; нет
        ;; захватываем мьютекс
        (begin (set-car! cell #t)
               #f)))

  ;; создает мьютекс
  (define (make-mutex)
    ;; устанавливаем исходное значение #f
    (let ((cell (list #f)))
      (define (the-mutex m)
        ;; если мы хотим захватить мьюеткс
        (cond ((eq? m 'acquire)
               ;; проверяем его текущее значение
               ;; если значение #t - мьютекс захвачен
               (if (test-and-set! cell)
                   ;; ждем, пока не овободится
                   (the-mutex 'acquire)))
              ;; если запрос на освобождение мьюетекса, освобождаем
              ((eq? m 'release) (clear! cell))))
      the-mutex))
#+END_SRC

~Упражнение 3.47.~
Семафор (размера n) представляет собой обобщение мьютекса. Подобно
мьютексу, семафор поддерживает операции захвата и освобождения, но
захватить его одновременно могут до ~n~ процессов.
Прочие процессы, которые попытаются захватить семафор, должны будут ждать
освобождения. Дайте реализацию семафоров:

а. в терминах мьютексов.
б. в терминах атомарных операций ~test-and-set!~.

То есть фактически мне надо написать мьютекс, который сможет быть
захвачен определенным количеством процессов.
Мьютекс фактически представляется в виде списка из одного элемента. N
процессов должны захватывать и освобождать этот мьютекс, значит нам
нужно, чтоб на каждый процесс приходилось по ячейке. Так что будем
представлять мьютекс в виде списка значений #t/#f - так реализован
собственный вариант.

Вариант "а" реализован имено так, как сделано ниже, поскольку:
мьютекс - это особая переменная, которая может принимать значения только
1/0 или #t/#f. А семафор - это объект, который представляет собой мьютекс
и счетчик к нему. А в принципе можно сказать, что семафор - это и есть
сам счетчик.

Процедура ~make-semaphore~ возвращает объект, который является
представлением семафора. Внутри себя он содержит мьютекс и счетчик для
подсчета обратившихся к семафору процессов. Мьютекс в нашей реализации
представляет собой объект, который содержит в себе состояние "занят" или
"свободен". Если мьютекс занят, а какой-то другой процесс захочет
получить к нему дотсуп, то процесс войдет в цикл ожидания, пока мьютекс
не освободится. Семафор работает с несколькими процессами, значит, если
мы будет просто передавать запрос мьютексу, то это не
сработает. Предположим, мьютекс занят, но лимит потоков не превышен.
Мы отправили ему сообщение на повторный захват при поскольку лимит процессов не
превышен, то каждый новый процесс будет попадать в петлю ожидания, пока
самый первый процесс не освободит мьютекс. И только после этого какой-то
из ожидающих процессов сможет занять мьютекс.
Поэтому если мьютекс занят, но лимит процессов не ревышен, то мы просто
увеличим счетчик процессов и вернем #t, эмулировав повторный захват
мьютекса, но не сделав его.

Вариант "б" реализован аналогичным образом, только мы не используем
~make-mutex~ напрямую, а вместо этого создаем ячейку мьютекса вручную и
вручную же меняем в ней значения с помощью ~test-and-set!~

#+BEGIN_SRC scheme
  ;; собственный вариант
  (define (make-semaphore n)
    ;;заводим пустой списк
    (let ((cell-list '()))
      (define (current-mutex m)
        ;; если хотим захватить семафор
        (cond ((eq? m 'acquire)
               ;; проверяем, сколько ячеек в списке
               (if (= (length cell-list) n)
                   ;; если кол-во ячеек = кол-ву процессов, которые могут захватить семафор
                   ;; ждем, пока не освободится место
                   (current-mutex 'acquire)
                   ;; иначе добавляем новую ячейку
                   (cons (list #t) cell-list)))
              ;; если хотим освободить семафор от 1 процесса
              ((eq? m 'release)
               ;; проверяем, захвачен ли какими-то процессами семафор вообще
               (if (null? cell-list)
                   #f
                   ;; если да, то укорачиваем список на 1
                   (set! cell-list (cdr cell-list))))))
      current-mutex))


  ;; семафор в термине мьютексов
  (define (make-semaphore n)
    ;; создаем мьютекс и счетчик
    (let ((mutex (make-mutex))
          (cnt 0))
      (define (the-semaphore m)
        ;; если поступил запрос на захват мьютекса
        (cond ((eq? m 'acquire)
               ;; захват не первый, но максимум потоков не превышен
               (cond ((and (> cnt 0) (< cnt n))
                      ;; увеличиваем счетчик
                      (begin (set! cnt (+ cnt 1))
                             #t))
                     ;; запрос первый, захватывем семафор
                     ((= 0 cnt) (begin (mutex 'acquire) #t))
                     ;; лимит потоков превышен, ждем, пока один из них не освободится
                     (else (the-semaphore 'acquire))))
              ;; если поступил запрос на освобождение мьютекса
              ((eq? m 'release)
               ;; остался единственный поток, освобождаем мьюеткс и уменьшаем счетчик
               (cond ((= cnt 1) (begin (mutex 'release) (set! cnt (- cnt 1))))
                     ;; потоков больше, чем 1, просто уменьшаем счетчик
                     ((> cnt 1) (set! cnt (- cnt 1)))
                     ;; иначе вхолостую освобождаем мьюеткс
                     ((= cnt 0) (mutex 'release))))
              ;; если поступил любой другой запрос, выдаем ошибку
              (else (error "wrong request---- THE-SEMAPHORE" m))))
      the-semaphore))


  ;;семафор в терминах атомарных операций
  (define (make-semaphore n)
    (let ((cell-mutex (list #f))
          (cnt 0))
      (define (the-semaphore m)
        ;; получен запрос не захват мьютекса
        (cond ((eq? m 'acquire)
               ;; захват мьютекса не первый, но и максимум не превышен
               (cond ((and (test-and-set! cell-mutex) (< cnt n))
                      (begin (set! cnt (+ cnt 1))
                             #t))
                     ;;лимит превышен
                     ((= cnt n) (the-semaphore 'acquire))
                     ;; в противном случае захватываем мьютекс
                     (else (test-and-set! cell-mutex))))
              ((eq? m 'release)
               (cond ((= cnt 1) (begin (clear! cell-mutex) (set! cnt (- cnt 1))))
                     ((> cnt 1) (set! cnt (- cnt 1)))
                     ((= cnt 0) (clear! cell-mutex))))
              (else (error "wrong request---- THE-SEMAPHORE" m))))
      the-semaphore))

#+END_SRC

~Упражнение 3.48.~
Подробно объясните, почему метод избежания тупиков, описанный выше
(т. е. счета нумеруются, и каждый процесс сначала пытается захватить счет
с меньшим номером), в самом деле позволяет избежать тупика в задаче
обмена балансов.  Перепишите ~serialized-exchange~ с использованием этой
идеи.
(Придется также изменить ~make-account~, так, чтобы каждый
счет создавался вместе с номером, и чтобы этот номер можно было считать, послав
соответствующее сообщение.)

Каждый вызов ~make-serializer~ возвращает объект, который представляет
собой процедуру ~serialized-p~, которая определена внутри лямбды,
принимающей на вход процедуру.
Задача ~serialized-p~ применить процедуру-параметр к своим аргументам,
использовав мьютекс. Таким образом, если другой поток попытается
использовать тот же самый объект ~serialized-p~, то при попытке захватить
мьютекс внутри ~serialized-p~ войдет в петлю ожидания и будет находиться
там, пока первый поток не освободит мьютекс.

Теперь смотрим, как работает процедура ~serialized-exchange~. Мы получаем
для каждого счета объект ~serialized-p~, каждый из которых содержит внутри
себя свой собственный мьютекс. Затем мы выполняем целиком вызов
~((serializer1 (serializer2 exchange)) account1 account2)~.
Во что раскрывается вызов ~((serializer1 (serializer2 exchange)) account1
account2)~

Воспользуемся методом подстановки, чтоб понять, что и когда
вызывается. Некторые строки кода объединены блоком ~begin~, чтоб их было
проще форматировать и воспринимать: подразумевается, что внутри блока
содержится исполняющийся код процедуры ~serialized-p~.
Так же в определенный момент мы столкнемся с проблемой, что у нас есть 2
мьютекса и 2 процедуры ~serialized-p~, которые принадлежат разным
аккаунтам. Чтобы не путаться, мы добавим к ним номера, чтоб
подчеркнуть, что это разные объекты.
Стрелочкой ~->~ опозначается переход на следующий шаг вычисления.
#+BEGIN_SRC scheme
  ((serializer1 (serializer2 exchange)) account1 account2) ->
  ((serializer1 (lambda (exchange) serialized-p-2)) account1 account2) ->
  ((lambda (lambda (exchange) serialized-p-2) serialized-p-1) account1 account2) ->
  ((lambda (serialized-p-2) serialized-p-1) account1 account2) ->
  (serialized-p-1 account1 account2) ->
  ;; объединим в блок для корректного форматирования
  (begin
    (mutex 'acquire)
    (let ((val (apply serialized-p-2 account1 account2)))
      (mutex 'release)
      val)) ->
  ;; во избежании путаницы, какой мьютекс какому сериализатору принадлежит, пронумеруем и их
  (begin
    (mutex-1 'acquire)
    (let ((val (begin (mutex-2 'acquire)
                      (let ((val (apply exchange account1 account2)))
                        (mutex-2 'release) val))))
      (mutex-1 'release)
      val))

#+END_SRC

Это решение сработает, если в какой-то момент другой
поток попытается обменять местами счет1 и счет2 или счет1 и счет3. Но
если второй поток попытается провернуть зеркальную операцию
(т.е. обменятьм местами счет2 и счет1, пока первый поток пытается обменять
счет1 и счет2), мы войдем в дедлок.

Но предположим, что у нас присвоены идентификационные номера счетам. Если
счет1 имеет номер 1, а счет2 имеет номер 2, то хоть мы будем менять
местами счет1 и счет2 или счет2 и счет1, ~serialized-exchange~ должна
будет определить, чей идентификационный номер меньше, и войти в
сериализованную процедуру этого счета. Понятно, что оба процесса
попытаются захватить один и тот же счет, но в этом случае опоздавший
процесс будет просто ждать, пока первый выполнит всю работу, таким
образом первый процесс не попадет в режим ожидания, поскольку второй
процесс начал работу "с другого конца"и заблочил нужный нам ресурс.

#+BEGIN_SRC scheme
  (define id-cnt 0)

  (define (make-account-and-serializer balance)
    (define (withdraw amount)
      (if (>= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Недостаточно денег на счете"))
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (let ((balance-serializer (make-serializer))
          (id-acc id-cnt))

      (define (dispatch m)
        (cond ((eq? m 'withdraw) withdraw)
              ((eq? m 'deposit) deposit)
              ((eq? m 'balance) balance)
              ((eq? m 'serializer) balance-serializer)
              ((eq? m 'id) id-acc)
              (else (error "Неизвестный запрос -- MAKE-ACCOUNT"
                           m))))
      (set! id-cnt (+ id-cnt 1))
      dispatch))

  (define (exchange account1 account2)
    (let ((difference (- (account1 'balance)
                         (account2 'balance))))
      ((account1 'withdraw) difference)
      ((account2 'deposit) difference)))

  (define (serialized-exchange account1 account2)
    (let ((serializer1 (account1 'serializer))
          (serializer2 (account2 'serializer))
          (id1 (account1 'id))
          (id2 (account1 'id)))
      (if (> id1 id2)
          ((serializer1 (serializer2 exchange)) account1 account2)
          ((serializer2 (serializer1 exchange)) account1 account2))))


  (define test1 (make-account-and-serializer 100))
  (define test2 (make-account-and-serializer 130))
  (test1 'id)
  (test2 'id)

  ;;тестов для serialized-exchange нет, поскольку пока не реализовано создание потоков
#+END_SRC

~Упражнение 3.49.~
Опишите сценарий, в котором вышеописанный механизм избежания тупиков не
работает. (Подсказка: в задаче обмена счетов каждый процесс заранее знает, к каким
счетам ему нужен будет доступ. Рассмотрите ситуацию, в которой процессу
нужно сначала получить доступ к каким-то разделяемым ресурсам, прежде чем
он сможет определить, какие ресурсы ему потребуются дополнительно.)

Идея:
Данный метод не сработает, если мы предположим, что процессу заранее
известен только 1 счет, с которым ему придется
взаимодействовать. Предположим, он сначала зайдет в сериализованную
процедуру этого счета, а потом будет узнавать, на какой счет идет
перевод. Предположим, что у нас есть счет1 и счет2, имеющие id1 и 2
соответственно. В одно процессе мы будем переводить деньги со счета 1, а
в другом - со счета 2. Занимаем мьютексы у этих счетов и теперь думаем,
куда бы перевести деньги. Предположим, что мы решаем переводить деньги на
счета с наименьшим идентификатором: счет2 захочет перевести деньги на
счет1 (поскольку мы считаем, что 1 - это самый меньший иднетификатор в
нашей системе), а счет1 решает перевести деньги на счет2 (поскольку
самому себе отправлять деньги бессмысленно).В результате при попытке
захватить мьютексы снова, мы войдем в дедлок. Процесс, отправляющий
деньги со счета 1 будет ждать, пока освободится счет 2, поскольку тот
занят другим процессом, который хочет перевести деньги с него. Второй же
процесс будет ожидать освобождения счета1 по той же причине. Цикл этого
ожидания не кончится никогда.

~Упражнение 3.50.~
Закончите следующее определение, которое обобщает процедуру ~stream-map~,
чтобы она позволяла использовать процедуры от нескольких аргументов, подобно ~map~ из
раздела 2.2.1, сноска 12.

В сноске 12 сказано:
map принимает процедуру от n аргументов и n списков и применяет процедуру ко
всем первым элементам списков, всем вторым элементам списков и так
далее. Возвращается список результатов.

У нас уже было аналогичное задание 2.36, когда требовалось заполнить пробелы в
процедуре ~accumulate-n~. ~stream-map~ отличется от нее только структурой
данных и отсутствием начального значения.

Определим необходимые функции для работы с потоками, описанные в мане.
#+BEGIN_SRC scheme

  (define (force delayed-object)
    (delayed-object))

  (define (memo-proc proc)
    (let ((already-run? #f) (result #f))
      (lambda ()
        (if (not already-run?)
            (begin (set! result (proc))
                   (set! already-run? #t)
                   result)
            result))))

  (define (delay expr)
    (memo-proc (lambda () expr)))

  (define (stream-ref s n)
    (if (= n 0)
        (stream-car s)
        (stream-ref (stream-cdr s) (- n 1))))

  (define (stream-enumerate-interval low high)
    (if (> low high)
        the-empty-stream
        (cons-stream
         low
         (stream-enumerate-interval (+ low 1) high))))

  (define (stream-filter pred stream)
    (cond ((stream-null? stream) the-empty-stream)
          ((pred (stream-car stream))
           (cons-stream (stream-car stream)
                        (stream-filter pred
                                       (stream-cdr stream))))
          (else (stream-filter pred (stream-cdr stream)))))

  (define (display-line x)
    (newline)
    (display x))

  (define (stream-for-each proc s)
    (if (stream-null? s)
        'done
         (begin (proc (stream-car s))
                (stream-for-each proc (stream-cdr s)))))

  (define (display-stream s)
    (stream-for-each display-line s))
#+END_SRC

Если мы считаем, что ~argstreams~ - это не список потоков, а поток,
содержащий в себе потоки, а сама ~stream-map~ возвращает не список
результатов, а поток результатов, то определение такое:
#+BEGIN_SRC scheme

  (define (stream-map proc . argstreams)
    (if (stream-null? (car argstreams))
        the-empty-stream
        (cons-stream
         (apply proc (map stream-car argstreams))
         (apply stream-map
                (cons proc (map stream-cdr argstreams))))))
#+END_SRC

~Упражнение 3.51.~
Чтобы внимательнее изучить задержанные вычисления, мы воспользуемся
следующей процедурой, которая печатает свой аргумент, а затем возвращает
его:

#+BEGIN_SRC scheme
  (define (show x)
    (display x)
    (newline)
    x)
#+END_SRC

Что печатает интерпретатор в ответ на каждое выражение из следующей
последовательности?

#+BEGIN_SRC scheme
  (define x (stream-map show (stream-enumerate-interval 0 10)))

  (stream-ref x 5)

  (stream-ref x 7)
#+END_SRC

При исполнении первого выражения интерпретатор напечатал цифры от 0 до 10
по одному на строке. Второе и третье выражение возвращают 5 и 7,
соответственно. Это становится возможным, поскольку ~x~ - это поток
данных.
Он образовался поскольку:
- ~show~ не только печатает элемент, но и возвращает его
- ~stream-map~ возвращает результат в качестве потока

Если ~show~ перестанет возвращать печтаемые элементы, то ~x~ будет
заполнен значениями типа ~unspecified~.

~Упражнение 3.52.~
Рассмотрим последовательность выражений

#+BEGIN_SRC scheme
  (define sum 0)

  ;;прибавляет число к имеющейся сумме и возвращает сумму
  (define (accum x)
    (set! sum (+ x sum))
    sum)

  ;; формируем последовательность-поток сумм
  ;; после выполнения sum = 210
  (define seq (stream-map accum (stream-enumerate-interval 1 20)))

  ;; формирует поток четных чисел
  ;; начиная с этого выражения sum не меняется
  (define y (stream-filter even? seq))

  ;; формирует поток из чисел, которые делятся на 5 дез остатка
  (define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                           seq))

  ;; возвращает седьмой элемент потока
  (stream-ref y 7)

  ;; печатает весь поток
  (display-stream z)
#+END_SRC

а) Каково значение ~sum~ после вычисления каждого из этих выражений?
б) Что печатается при вычислении выражений ~stream-ref~ и
~display-stream~?
в) Изменился бы этот результат, если бы мы реализовали ~(delay <expr>)~ просто как
~(lambda () <выражение>)~, не применяя оптимизацию через ~memo-proc~?
Объясните свой ответ.

Ответы:
а - смотри ответы над выражениями
б - смотри ответы над соответствующими выражениями
в - результат бы не изменился, но пришлось бы каждый раз вычислять
задержанное выражение заново (в нашем случае это вычисление ~cdr~ потока,
например), что ресурсозатратно, вместо того, чтоб просто получить уже
вычисленный результат.

~Упражнение 3.53.~
Не запуская программу, опишите элементы потока, порождаемого

#+BEGIN_SRC scheme
  (define s (cons-stream 1 (add-streams s s)))
#+END_SRC

Так выглядит сама ~add-streams~,которая порождает поток сумм первых
элементов, вторых и т.д.
#+BEGIN_SRC scheme
(define (add-streams s1 s2)
    (stream-map + s1 s2))
#+END_SRC

Значит получается, что мы конструируем бесконечный поток
~s~. Бесконечный - потоку что параметры ~add-streams~ - все тот же поток
~s~. Затем мы конструируем поток, ~car~ которого 1, а ~cdr~ - обещание
вычислить сумму элементов этого же потока. Если мы попросим вычислить
~cdr~ потока, процесс замкнется навсегда. Но элементы будут выглядеть
так: 1 2 4 8 16 и т.д.

Кстати, запустить программу не получается: интерпретатор заявляет, что
переменная ~s~ не привязана. Поскольку выполнения начинается с самых
внутренних скобок, т.е. с ~(add-streams s s)~, то с точки зрения
интерпретатора ~s~действительно еще не определена.

~Упражнение 3.54~.
Определите процедуру ~mul-streams~, аналогичную ~add-streams~, которая
порождает поэлементное произведение двух входных потоков. С помощью нее и
потока ~integers~ закончите следующее определение потока, n-й элемент
которого (начиная с 0) равен факториалу n + 1.

Значит, например, второй элемент потока должен быть = !1. А седьмой
элемент - !8.

К сожалению, проверить решение невозможно, т.к. комп пытается вычислить
все и мы получаем переполнение стека.

#+BEGIN_SRC scheme
  (define (mul-streams s1 s2)
      (stream-map * s1 s2))

  (define (integers-starting-from n)
    (cons-stream n (integers-starting-from (+ n 1))))

  (define integers (integers-starting-from 1))

  (define factorials (cons-stream 1 (mul-streams integers factorials)))
#+END_SRC

~Упражнение 3.55.~
Определите процедуру ~partial-sums~, которая в качестве аргумента берет
поток S, а возвращает поток, элементы которого равны S0, S0 + S1, S0 + S1 + S2....
Например, ~(partial-sums integers)~ должно давать поток 1, 3, 6, 10,
15...

Значит, каждый элемен потока = сумме всех предыдущих элементов. Задача
похожа на предыдущее упражнение.

Не получилось сразу написать процедуру для потоков, поэтому сначала
представим ее для обычных списков:
#+BEGIN_SRC scheme
  ;; вариант процедуры для обычных списков
  ;; неэффективен, поскольку мы по многу раз считаем одни и те же промежуточные суммы,
  ;; пока список не кончится + используется реверс списка
  ;; скорость роста алгоритма близка к экспоненциальной, если считать кол-во операций
  ;; сложения
  (define (partial-sums lst)
    (define (sum-of-elts lst)
      (if (null? lst)
          0
          (+ (car lst) (sum-of-elts (cdr lst)))))
    (define (iter lst new-list)
      (if (null? lst)
          new-list
            (iter (cdr lst) (cons (sum-of-elts lst) new-list))))
    (iter (reverse lst) '()))

  ;; более эффективный варинт:
  ;; теперь мы накапливаем суммы, полученные на каждой итерации сложения элементов списка,
  ;; пока не дойдем до конца
  ;; скорость роста алгоритма линейная
  (define (partial-sums lst)
    (define (sum-of-elts lst new-list)
      (if (null? lst)
          new-list
          (sum-of-elts (cdr lst)
                       (append new-list (list (+ (car (last-pair new-list))
                                      (car lst)))))))
    (sum-of-elts (cdr lst) (list (car lst))))
#+END_SRC

Теперь пробуем написать процедуру для потоков данных.
Процедура представляет собой бесконечную рекурсию, которая вернет
бесконечный поток сумм бесконечных целых чисел.

#+BEGIN_SRC scheme

  (define (partial-sums s)
    (cons-stream (stream-car s) (add-streams (stream-cdr s) (partial-sums s))))

#+END_SRC


~Упражнение 3.56.~
Существует знаменитая задача, впервые сформулированная Р. Хэммингом:
породить в возрастающем порядке и без повторений все положительные целые
числа, у которых нет других простых делителей, кроме 2, 3 и 5. Очевидное
решение состоит в том, чтобы перебирать все натуральные числа по очереди
и проверять, есть ли у них простые множители помимо 2, 3 и 5. Однако эта
процедура весьма неэффективна, поскольку чем больше числа, тем меньшая их
доля соответствует условию. Применим альтернативный подход: назовем
искомый поток чисел ~S~ и обратим внимание на следующие факты:

- ~S~ начинается с 1.
- Элементы ~(scale-stream S 2)~ также принадлежат ~S~
- То же верно и для ~(scale-stream S 3)~ и ~(scale-stream S 5)~.
- Других элементов ~S~ нет.

Теперь требуется только соединить элементы из этих источников. Для этого
мы определяем процедуру ~merge~, которая сливает два упорядоченных потока в один
упорядоченный поток, убирая при этом повторения:

#+BEGIN_SRC scheme
  (define (merge s1 s2)
    ;;если какой-то из потоков пустой - возвращаем другой
    (cond ((stream-null? s1) s2)
          ((stream-null? s2) s1)
          ;; иначе
          (else
           ;; получаем первые элементы потоков
           (let ((s1car (stream-car s1))
                 (s2car (stream-car s2)))
             ;; смотрим, какой из них больше
             ;; меньший элемент включаем в новый поток и рекурсивно вызываем процедуру
             ;; с cdr потока, чей элемент мы включили в новый поток, и нетронутым
             ;; вторым потоком
             (cond ((< s1car s2car)
                    (cons-stream s1car (merge (stream-cdr s1) s2)))
                   ((> s1car s2car)
                    (cons-stream s2car (merge s1 (stream-cdr s2))))
                   (else
                    (cons-stream s1car
                                 (merge (stream-cdr s1)
                                        (stream-cdr s2)))))))))
#+END_SRC

Тогда требуемый поток можно получить с помощью ~merge~, заполнив
пропуски, таким образом:

Мы знаем, что нам нужно 2 потока.
- идея 1:  ~integer~ и ~cdr~ от него - не подходит, получим поток из всех
целых чисел без повторений, которые есть в обоих потоках
- идея 2: поток четных и поток нечетных чисел - не подходит по той же причине
- идея 3: использовать рекурсию от потока ~s~ и ~integers~ - не подходит по
той же причине
- идея 4: Возможно, нужен фильтер? Что если один поток будет отфильтрован
таким образом, что в нем будут только числа, которые делятся на 2, 3 или 5,
а в другом потоке будут числа, которые не будут делиться на остальные
простые числа - невозможно, поскольку все простые числа не указать, их
ряд бесконечен.
- идея 5: использовать поток, в котором числа делятся на 2, 3 или 5 (ставим
фильтр) Затем на новый поток накладываем еще фильтр: числа не должны
делиться на 7.
Получим такой первый поток:
2 3 4 5 6 8 9 15 16 18 20 22 24 25 26 27..
Похоже на правду. Мы можем не беспокоиться по поводу простых чисел 11,
13, 17, 19, 23 и т.д., поскольку их отсеит первый фильтр, поскольку ни
одно из них невозможно разделить на 2, 3 или 5 без остатка.
Каким должен быть второй поток, чтоб смержив его с первым получить
искомый ряд?
- идея 6: что если фильтры поделить между потоками? Числа в первом потоке
  должны делиться на 2 или 3 и не делиться на 7, а во втором - делиться
  на 5 и тоже не делиться на на 7.

первый: 2 3 4 6 8 10 12 15 16 18 20 22 24 26 30  и т.д.
второй: 5 10 15 20 25 30 40 45 50 55 60 65 75 и т.д.

Пробуем представить себе их мердж:
2 3 4 5 6 8 10 12 15 16 18 20 22 24 25 26 30 32 33 34

Проблема с числом 33 и 26: они отлично делится на 11 или 13. А это простые
числа. Идея со вторым фильтром, который должен поставлять нам числа,
которые не делятся на 7 не прокатывает.

- идея 7: Что если первый поток имеет числа, которые делятся на 2 или 3,
  а числа во втором потоке могут делиться только на 5 и ни на какое
  другое нечетное число больше 5?
Просто все простые числа кроме двойки - нечетные. Ведь если хотя бы одно
из них будет четным, значит, его можно поделить на 2, а значит это уже не
простое число.
Идея не подходит: как проверить, делится ли число на все нечетные числа?
Зависнем на проверке первого же числа навечно.

идея 8: замечаем сраную опечатку в описании задания и понимаем, что у нас
есть подсказка: "элементы ~(scale-stream S 2)~ также принадлежат
~S~". Вспоминаем, что у нас есть одноименная функция. Еще вспоминаем, что
обратная операция от деления - это умножение.

#+BEGIN_SRC scheme
  (define (scale-stream stream factor)
    (stream-map (lambda (x) (* x factor)) stream))

  (define S (cons-stream 1 (merge (scale-stream S 2) (merge (scale-stream S 3)
                                                            (scale-stream S 5)))))
#+END_SRC

~Упражнение 3.57~.
Сколько сложений происходит при вычислении n-го числа Фибоначчи, в
случае, когда мы используем определение ~fibs~ через процедуру
~add-streams~?
Покажите, что число сложений выросло бы экспоненциально, если бы мы
реализовали ~(delay <expr>)~ просто как ~(lambda () <expr>)~, без
оптимизации через процедуру ~memo-proc~ из раздела 3.5.1.

Сама процедура ~fibs~:
#+BEGIN_SRC scheme
  (define fibs
    (cons-stream 0
                 (cons-stream 1
                              (add-streams (stream-cdr fibs)
                                           fibs))))
#+END_SRC

Предположим, нам нужно вычислить число 5. Нам понадобится 4 операции
сложения, если использовать ~memo-proc~: 0+1, 1+1, 1+2, 2+3, если ряд
Фибоначчи еще вообще не вычислялся. Если до этого у нас ряд
Фибоначчи вычислен до числа 3, например, то нам нужно только 2 последних
числа, которые хранятся в ~cdr~ потока: 2 и 3. Т.е. понадобится всего 1
операция сложения, чтоб вычисллить следующее число.

В случае, если  ~memo-proc~ не используется, то на каждой итерации
рекурсии придется считать весь ряд сначала. Отсюда экспоненциальный рост.

~Упражнение 3.58.~
Дайте интерпретацию потоку, порождаемому следующей процедурой:

#+BEGIN_SRC scheme
  (define (expand num den radix)
    (cons-stream
     ;; получаем целую часть от деления произведеия num-radix на den
     ;; отправляем ее в новый поток
     (quotient (* num radix) den)
     ;; рекурсивно вызываем процедуру, в качестве numпередаем отстаток от деления
     ;; произведения num-radix на den
     (expand (remainder (* num radix) den) den radix)))
#+END_SRC

(Элементарная процедура ~quotient~ возвращает целую часть частного двух
целых чисел.) Каковы последовательные элементы потока, порожденного
выражением ~(expand 1 7 10)~? Что дает вычисление ~(expand 3 8 10)~?

Надо ли говорить, что запустив эту процедуру, мы получим переполнение
стека, поскольку условия остановки рекурсии нет?

Поток, порожденный ~(expand 1 7 10)~:
1 4 2 8 5 7 1 4 2...

Поток, порожденный ~(expand 3 8 10)~:
3 7 5 0 0...

~Упражнение 3.59~

Часть задания невозможно адекватно перенести сюда из-за формул,
см. стр 312.

a)
Определите процедуру ~integrate-series~, которая на
входе принимает поток a0 , a1 , a2 , ...., представляющую степенной
ряд, и возвращает поток a0 , 1/2 a1 , 1/3 a2 , . . . коэффициентов
при неконстантных членах интеграла последовательности. (Поскольку в
результате отсутствует постоянный член, он не представляет собой степенной ряд; при
использовании ~integrate-series~ мы через cons будем присоединять к началу
соответствующую константу.)

Перевод на русский язык:
интеграл - это сумма бесконечно малых слагаемых. На вход мы получим поток
степеней, а на выходе - коэфициенты для всех члагаемых интеграла, кроме
константы.

Не знаю, какой из вариантов решения правильный
#+BEGIN_SRC scheme
  ;;мой вариант
  (define (integrate-series stream)
   (let ((denom 2))
     (cons-stream (stream-car stream) (stream-map (lambda (x)
                                                    (let ((part (* (/ 1 denom) x)))
                                                      (+ 1 denom)
                                                      part))
                                                  (stream-cdr stream)))))
  ;; подсмотренный
  (define (integrate-series stream)
      (stream-map / stream integers))
#+END_SRC

б)

Функция x→ e^x равна своей собственной производной. Отсюда следует, что
e^x и интеграл e^x cуть одна и та же последовательность, с точностью до
постоянного члена, который равен e^0 = 1.
Соответственно, можно породить последовательность для e^x через
#+BEGIN_SRC scheme
  (define exp-series
    (cons-stream 1 (integrate-series exp-series)))
#+END_SRC

Покажите, как породить последовательности для синуса и косинуса, опираясь
на то, что производная синуса равна косинусу, а производная косинуса равна минус синусу:

#+BEGIN_SRC scheme
  (define cosine-stream
    (cons-stream 1 (scale-stream sine-series -1)))

  (define sine-series
    (cons-stream 0 (integrate-series cosine-stream)))
#+END_SRC

~Упражнение 3.60.~
Если степенной ряд представляется в виде потока своих коэффициентов, как
в упражнении 3.59, то сумма последовательностей реализуется посредством
~add-streams~. Завершите определение следующей процедуры для перемножения
последовательностей:

#+BEGIN_SRC scheme
  (define (mul-series s1 s2)
    (cons-stream .. (add-streams .. ..)))
#+END_SRC

~Упражнение 3.63.~
Хьюго Дум спрашивает, почему нельзя было написать ~sqrt-stream~ более
простым способом, без внутренней переменной ~guesses~:

#+BEGIN_SRC scheme
  (define (sqrt-stream x)
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             (sqrt-stream x))))
#+END_SRC

Лиза П. Хакер отвечает, что эта версия процедуры значительно менее
эффективна, поскольку производит избыточные вычисления. Объясните Лизин
ответ. Сохранилось бы отличие в эффективности, если бы реализация ~delay~
использовала только ~(lambda () <выражение>)~, без оптимизации через ~memo-proc~?

В оригинальной версии функции мы не просто ищем придлиженное значение, но
и сохраняем все промежуточные значения в потоке ~guesses~, т.е. в нашей
локальной переменной. Это значит, что при вычислении каждого следующего
предположения нам не надо вычислять всю цепочку от начала.

А во варианте, который предлагает Хьюго, хранить
промежуточные значения просто негде.

В случае с использованием ~delay~ без оптимизации, эффективность бы не
сохранилась, эффективность бы не сохранилась, поскольку пришлось бы
вычислять значение ~cdr~ потоков каждый раз заново.

~Упражнение 3.64.~
Напишите процедуру ~stream-limit~, которая в качестве аргумента принимает
поток и число (погрешность). Она должна просматривать поток, пока не найдется два
элемента подряд, различающихся меньше, чем на погрешность, и возвращать второй из этих
элементов. При помощи этой процедуры можно будет вычислять квадратные
корни с  заданной точностью так:

#+BEGIN_SRC scheme
  (define (sqrt x tolerance)
    (stream-limit (sqrt-stream x) tolerance))
#+END_SRC

#+BEGIN_SRC scheme
  (define (stream-limit stream  tolerance)
    (cond ((stream-null? stream) #f)
          ((<= (- (car (stream-cdr stream)) (stream-car stream)) tolerance)
           (car (stream-cdr stream)))
          (else (stream-limit (stream-cdr stream)  tolerance))))
#+END_SRC

~Упражнение 3.65.~
породите три последовательности приближений к натуральному логарифму 2,
так же, как мы выше сделали это для πи. Как быстро сходятся эти
последовательности?

Сначала адаптируем процедуру для нахождения пи под нахождение логарифма.
Это первый вариант, самый медленный.
#+BEGIN_SRC scheme
  (define (ln-summands n)
    (cons-stream (/ 1.0 n)
                 (stream-map - (ln-summands (+ n 1)))))

  (define ln-stream
    (partial-sums (ln-summands 1)))

#+END_SRC

Теперь воспользуемся ускорением Эйлера для порождения ускоренного
варианта:

#+BEGIN_SRC scheme
  (define (euler-transform s)
    (let ((s0 (stream-ref s 0))
          (s1 (stream-ref s 1))
          (s2 (stream-ref s 2)))
      (cons-stream (- s2 (/ (square (- s2 s1))
                            (+ s0 (* -2 s1) s2)))
                   (euler-transform (stream-cdr s)))))

  (euler-transform ln-stream)
#+END_SRC

И третий вариант. Будем использовать табло, т.е. поток потоков, где
каждый последующий поток - это результат модификации предыдущего.

Этот вариант будет самый быстрый.
#+BEGIN_SRC scheme
  (define (make-tableau transform s)
    (cons-stream s
                 (make-tableau transform
                               (transform s))))

  ;; формируем поток из первых элементов кажждой строки табло
  (define (accelerated-sequence transform s)
    (stream-map stream-car
                (make-tableau transform s)))


  (accelerated-sequence euler-transform ln-stream)
#+END_SRC

~Упражнение 3.66.~
Рассмотрим поток ~(pairs integers integers)~  Можете ли Вы что-то сказать о
порядке, в котором пары попадают в поток? Например, сколько приблизительно пар
предшествуют паре ~(1, 100)~? Паре ~(99, 100)~ ? ~(100, 100)~ ?
(Если Вы способны предоставить точные математические утверждения, —
прекрасно. Однако если Вы увязаете в деталях, достаточно качественных оценок.)

Сначала проанализируем саму процедуру ~pairs~. Эта процедура порождает
бесконечный поток, состоящий из потоков, состоящих из пар.

#+BEGIN_SRC scheme
  ;; сливает 2 потока в 1, чередуя их пары.
  (define (interleave s1 s2)
    (if (stream-null? s1)
        s2
        (cons-stream (stream-car s1)
                     (interleave s2 (stream-cdr s1)))))

  (define (pairs s t)
    (cons-stream
     ;; делаем пару из первых элементов потоков
     (list (stream-car s) (stream-car t))
     ;; сливаем 2 потока в 1
     (interleave
      ;; поочередно составляем пару из первого элемента s-потока и всех пар из хвоста t
      (stream-map (lambda (x) (list (stream-car s) x))
                  (stream-cdr t))
      ;; вызываем pairs рекурсивно, чтоб проделать описанные выше действия со всеми
      ;; для хвостов потоков
      (pairs (stream-cdr s) (stream-cdr t)))))
#+END_SRC

Теперь разберем саму задачу. У нас есть вызов ~(pairs integers
integers)~, где integers - это поток, содержащий все целые положительные
числа.
Ответы:
~(1, 100)~ предшествует сравнительно немного пар. Потому что пары пойдут в такой
последовательности: (1, 1), (1, 2) (1, 3) и т.д.

~(99, 100)~ - предшествует значительно больше пар. Невозможно сказать,
сколько, потому что сначала нужно составить из первого элемента первого
потока и всех пар второго, потом из второго элемента первого потока и
всех пар второго потока и т.д.

~(100, 100)~ - этой паре будет предшествовать еще больше пар, чем
предыдущей, по описанным выше причинам.

~Упражнение 3.67.~
Измените процедуру так, чтобы ~(pairs integers integers)~ порождало поток
из всех пар натуральных чисел (i, j), без дополнительного условия i ≤ j. Подсказка:
потребуется примешать еще один поток.

Я добавила еще один поток, порождаемый ~stream-map~ и перемешала его с
уже имеющимся.

#+BEGIN_SRC scheme
  (define (my-pairs s t)
    (cons-stream
     (list (stream-car s) (stream-car t))
     (interleave
      (stream-map (lambda (x) (list x (stream-car s)))
                  (stream-cdr t))
      (interleave
       (stream-map (lambda (x) (list (stream-car s) x))
                   (stream-cdr t))
       (pairs (stream-cdr s) (stream-cdr t))))))

  (define test2 (my-pairs integers integers))

  (display-stream test2)
#+END_SRC

~Упражнение 3.68.~
Хьюго Дум считает, что построение потока пар из трех частей — процедура
слишком сложная.
Он предлагает вместо того, чтобы отделять пару (S 0 , T 0 ), работать с
первой строкой целиком:

#+BEGIN_SRC scheme
  (define (pairs s t)
    (interleave
     (stream-map (lambda (x)
                   (list (stream-car s) x))
                 t)
     (pairs (stream-cdr s) (stream-cdr t))))

#+END_SRC

Будет ли такой код работать? Посмотрите, что произойдет, если мы
попытаемся вычислить ~(pairs integers integers)~, используя определение Хьюго.

Итак, мы получиличи переполнени стека из-за рекурсии. И происходит это
именно из-за отсутствия пары (S 0 , T 0 ). В прежней версии на выходе из
функции  ~pairs~ мы получали поток, сформированный ~cons-stream~ ,
который состоял из пары (S 0 , T 0 ) и ~обещания~ вычислить остальные
пары. Сейчас же поток нам должна вернуть функция ~interleave~, которая сделать
этого не может, пока не сформируются оба ее аргумента. Вычисления первого
аргумента, порождаемого ~stream-map~, не так страшно:
~stream-map~ возвращает результат применения операции к первому элементу
потока и все то же обещание применить операцию к остальным
элементам. Стек нам переполняет  вызов
~(pairs (stream-cdr s) (stream-cdr t))~, из которого теперь ничего не
возвращается. А раньше возвращалась первая пара, сформированная из первых
элементов хвоста потоков и пресловутого обещания вычислить оставшееся.

~Упражнение 3.69.~
Напишите процедуру ~triples~, которая берет три бесконечных потока S, T и U, и порожда-
ет поток троек (Si , Tj , Uk ), таких, что i ≤ j ≤ k. С помощью
~triples~ породите поток всех Пифагоровых троек натуральных чисел,
т. е. таких троек (i, j, k), что i ≤ j и i^2 + j^2 = k^2

- нам нужны 3 потока  ~integers~ (?)
- для получения пар, где i ≤ j можно воспользоваться ~pairs~
- нужен фильтр, который будет проверять условие i^2 + j^2 = k^2 и
  формировать поток только из тех значений, где это условие срабатывает
#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  ;; очень медленный вариант
  (define (triples s t u)
    (define (unsorted-triples ij-pairs u)
      (cons-stream (append (stream-car ij-pairs)
                           (list (stream-car u)))
                   (interleave
                    (stream-map (lambda (x)
                                  (append x (list (stream-car u))))
                                (stream-cdr ij-pairs))
                    (unsorted-triples (stream-cdr ij-pairs) (stream-cdr u))
                    )))
    (let* ((ij-pairs (pairs s t))
           (u-triples (unsorted-triples ij-pairs u)))
      (stream-filter (lambda (item)
                       (let ((i (car item))
                             (j (cadr item))
                             (k (caddr item)))
                         (= (+ (square i) (square j)) (square k))))
                     u-triples)))

  ;; побыстрее
  (define (triples s t u)
    (define (unsorted-triples s t u)
      (cons-stream (list (stream-car s) (stream-car t) (stream-car u))
                   (interleave
                    (stream-map (lambda (x)
                                  (append (list (stream-car u)) x))
                                (stream-cdr (pairs s t)))
                    (unsorted-triples (stream-cdr s) (stream-cdr t) (stream-cdr u)))))
    (let* ((u-triples (unsorted-triples s t u)))
      (stream-filter (lambda (item)
                       (let ((i (car item))
                             (j (cadr item))
                             (k (caddr item)))
                         (= (+ (square i) (square j)) (square k))))
                     u-triples)))

  (define tr (triples integers integers integers))

#+END_SRC

~Упражнение 3.70.~
Интересно было бы уметь порождать потоки в каком-либо полезном порядке, а
не в порядке, задаваемом к случаю придуманным процессом чередования. Можно
воспользоваться методом, подобным процедуре ~merge~ из упражнения 3.56,
если мы определим способ сказать, что одна пара целых чисел «меньше»
другой. Один из способов состоит в том, чтобы определить «функцию
взвешивания» W(i,j) и постановить, что (i1 ,j1 ) меньше, чем (i2,j2),
если W (i1 , j1 ) ≤ W (i2 , j2 ).
Напишите процедуру ~merge-weighted~, которая во всем подобна ~merge~, но только
дополнительного аргумента принимает процедуру ~weight~, которая вычисляет
вес пары, и используется для определения порядка, в котором элементы должны появляться
в получающемся смешанном потоке. При помощи ~merge-weighted~ напишите процедуру
~weighted-pairs~, обобщающую ~pairs~. Она должна принимать два потока и процедуру,
вычисляющую функцию взвешивания, и порождать поток пар, упорядоченных по весу. Породите,
используя эту процедуру:
а. Поток всех пар натуральных чисел (i, j) где i ≤ j, упорядоченных по
сумме i + j.
б. поток всех пар натуральных чисел (i, j), где i ≤ j, ни i, ни j не
делится ни на 2, ни на 3, ни на 5, (без остатка?) и пары упорядочены по
значению суммы 2i + 3j + 5ij.

С заданием "а" все достаточно тривиально. С заданием "б" чуть сложнее.
Суть в том, что нужно заранее формировать пары из чисел, которые не
деляется на 2, 3 или 5 без остатка, а только потом сортировать.
При этом нельзя проверять недилимость чисел выражением типа
~(= 0 (remainder x 2) (remainder x 3) (remainder x 5))~, поскольку если
число не делится на 2, то это не значит, что оно не может делиться на 3
или 5, а тем не менее, вычисление уже остановилось и нам вернули
~false~.

#+BEGIN_SRC scheme
  (define (merge-weighted s1 s2 pred)
    (cond ((stream-null? s1) s2)
          ((stream-null? s2) s1)
          (else
           (let ((s1car (stream-car s1))
                 (s2car (stream-car s2)))
             (if (<= (pred s1car) (pred s2car))
                 (cons-stream s1car (merge-weighted (stream-cdr s1) s2 pred))
                 (cons-stream s2car (merge-weighted s1 (stream-cdr s2) pred)))))))

  (define (weighted-pairs s t pred)
    (cons-stream (list (stream-car s) (stream-car t))
                 (merge-weighted
                  (stream-map (lambda (x) (list (stream-car s) x))
                              (stream-cdr t))
                  (weighted-pairs (stream-cdr s) (stream-cdr t) pred) pred)))


  (define (weight-a pair)
    (+ (car pair) (cadr pair)))
  ;;конструируем правильный поток чисел для задания "б"
  ;; числа не должны делиться на 2, 3 и 5
  (define (make-stream-for-b stream)
    (stream-filter (lambda (x)
                     (cond ((= 0 (remainder x 2)) #f)
                           ((= 0 (remainder x 3)) #f)
                           ((= 0 (remainder x 5)) #f)
                           (else #t)))
                   stream))

  (define (weight-b pair)
    (let ((i (car pair))
          (j (cadr pair)))
      (+ (* 2 i) (* 3 j) (* 5 i) (* 5 j))))


  (display-stream (weighted-pairs integers integers weight-a))
  (display-stream  (weighted-pairs (make-stream-for-b integers)
                                   (make-stream-for-b integers)
                                   weight-b))
#+END_SRC

~Упражнение 3.71.~
Числа, которые можно выразить в виде суммы двух кубов более, чем одним
способом, иногда называют числами Рамануджана (Ramanujan numbers), в честь математика
Шринивасы Рамануджана. Упорядоченные потоки пар предлагают изящное решение для задачи
порождения таких чисел. Чтобы найти число, которое можно двумя разными
способами записать в виде суммы двух кубов, требуется только породить
поток пар натуральных чисел (i, j), взвешенных согласно сумме i^3 + j^3
(см. упражнение 3.70), и искать в этом потоке две пары
подряд с одинаковым весом. Напишите процедуру для порождения чисел
Рамануджана. Первое такое число 1729. Каковы следующие пять?

#+BEGIN_SRC scheme
  (define (cube x)
    (* x x x))

  (define (cube-weight pair)
    (+ (cube (car pair)) (cube (cadr pair))))

  (define (ramanujan-numbers s t)
    (define (ramanujan-numbers-search stream)
      (if (= (cube-weight (stream-car stream)) (cube-weight
                                                (stream-car (stream-cdr stream))))
          (cons-stream (list (cube-weight (stream-car stream))
                                          (stream-car stream)
                                          (stream-car (stream-cdr stream)))
                       (ramanujan-numbers-search (stream-cdr stream)))
          (ramanujan-numbers-search (stream-cdr stream))))
    (ramanujan-numbers-search (weighted-pairs s t cube-weight)))

  (define test (ramanujan-numbers integers integers))

  (display-stream test)
#+END_SRC

~Упражнение 3.72.~
Используя метод, подобный описанному в упражнении 3.71, породите поток
всех чисел, которые можно записать как сумму двух квадратов тремя
различными способами
(и покажите, каковы эти способы).

#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  (define (square-weight pair)
    (+ (square (car pair)) (square (cadr pair))))

  (define (thee-square-numbers s t)
    (define (thee-square-numbers-search stream prev)
      (if (= (square-weight (stream-car stream))
             (square-weight (stream-car (stream-cdr stream)))
             (square-weight prev))
          (cons-stream (list (cube-weight (stream-car stream))
                                          (stream-car stream)
                                          (stream-car (stream-cdr stream))
                                          prev)
                       (thee-square-numbers-search (stream-cdr stream)
                                                   (stream-car stream)))
          (thee-square-numbers-search (stream-cdr (stream-cdr stream))
                                      (stream-car stream))))
    (let ((pairs (weighted-pairs s t square-weight)))
    (thee-square-numbers-search (stream-cdr pairs) (stream-car pairs))))

  (define test (thee-square-numbers integers integers))

  (display-stream test)
#+END_SRC

~Упражнение 3.73.~
Можно моделировать электрические цепи с помощью потоков, представляющих
значения тока или напряжения в определенные моменты времени. Допустим,
например, что у нас имеется цепь RC (RC circuit), состоящая из резистора
с сопротивлением R и конденсатора емкостью C, соединенных
последовательно.
Значение напряжения v в зависимости от заданного
тока i определяется формулой.
Напишите процедуру RC, моделирующую эту
цепь. На входе RC должна получать значения R, C и dt, и выдавать
процедуру, которая принимает на входе поток значений тока i и начальное
значение напряжения v 0 , а на выходе выдает поток значений
напряжения v. Например, у Вас должна быть возможность смоделировать при
помощи RC RC-цепь с R = 5 ом, C = 1 фараде, и временным шагом в 0,5
секунды, вычислив ~(define RC1 (RC 5 1 0.5))~. Здесь RC1
определяется как процедура, которая принимает на входе поток,
представляющий временную последовательность токов, и исходное напряжение
на конденсаторе, а на выходе дает временной поток напряжений.

#+BEGIN_SRC scheme

#+END_SRC

~Упражнение 3.74.~
Лиза П. Хакер разрабатывает систему для обработки сигналов, приходящих от
физических сенсоров. Один из важных инструментов, который она хочет построить, — это
сигнал, описывающий переходы входного сигнала через ноль
~(zero-crossings)~.
Выходной сигнал должен равняться +1, когда сигнал на входе
меняется с отрицательного на положительный, -1, когда сигнал меняется с
положительного на отрицательный, и 0 в остальных случаях. (Допустим, что
знак нулевого входа положителен).
В Лизиной системе сигнал от сенсора представляется как поток ~sense-data~,
а ~zero-crossings~ представляет соответствующий поток пересечений нуля. Для начала
Лиза пишет процедуру ~sign-change-detector~, которая берет два значения в качестве
аргументов и, сравнив их знаки, выдает 0, 1 или -1. Затем она строит
поток переходов через ноль следующим образом:

#+BEGIN_SRC scheme
  (define (make-zero-crossings input-stream last-value)
    (cons-stream
     (sign-change-detector (stream-car input-stream) last-value)
     (make-zero-crossings (stream-cdr input-stream)
                          (stream-car input-stream))))

  (define zero-crossings (make-zero-crossings sense-data 0))

#+END_SRC

Мимо проходит Лизина начальница Ева Лу Атор и замечает, что программа
приблизительно равносильна следующей, написанной с использованием обобщенной версии
~stream-map~ из упражнения 3.50. (т.е. принимает неограниченное кол-во
потоков)
Заполните пропуски.

ПРи переводе на более простой язык:
~sense-data~ - это входные значения
~zero-crossings~ - выходные значения
~sign-change-detector~ -  функция, которая формирует ~zero-crossings~,
сравнивая попарно значения из ~sense-data~ на предмет изменения знака.

Начальница Лизы предлагает более простой вариант реализации лизиной
идеи. Надо только заполнить пробелы. Исходя из порядка аргументов,
которые принимает ~stream-map~, мы понимаем, что вместо пропуска должен
быть какой-то поток, а раз ~sign-change-detector~ в изначальной версии
сравнивает значения в ~sense-data~ попарно, то пропуск заполним так:

#+BEGIN_SRC scheme
  (define zero-crossings
    (stream-map sign-change-detector sense-data (cons-stream 0 sense-data)))
#+END_SRC

Вместо ~(cons-stream 0 sense-data)~ можно было бы написать
~(stream-cdr sense-data)~ и работа ~zero-crossings~ не нарушилась бы, но
только при уловии, в ~sense-data~ заполнен ~cdr~, потому что если там
окажется только 1 значение, то попытавшись взять ~cdr~ от потока, мы бы
наткнулись на ~null~.

~Упражнение 3.75.~
К сожалению, Лизин детектор перехода через ноль из упражнения 3.74
оказывается недостаточным, потому что зашумленный сигнал от сенсоров приводит к ложным
срабатываниям. Инженер-электронщик Дайко Поправич предлагает Лизе сгладить сигнал, чтобы
отфильтровать шум, прежде, чем отлавливать пересечение нуля. Лиза
принимает его совет и решает извлечь переходы через ноль из сигнала,
полученного взятием среднего арифметического каждого значения входных
данных с предыдущим значением. Она объясняет задачу своему помощнику
Хьюго Думу, и тот пытается реализовать идею, но допускает ошибку. Найдите
ее, исправьте, не меняя логику программы. (Подсказка: придется увеличить
число аргументов ~make-zero-crossings~.)

Итак, замысел Лизы:
- берем среднее арифметическое попарно из всех сигналов из ~sense-data~
- извлекаем значение перехода через ноль из потока этих средних
  арифметических

Что сделал Хьюго неправильно:
- получает среднее арифметическое, используя не 2 значения из
  ~sense-data~, а предыдущее срежнее арифметическое и первое значение из
  ~sense-data~

#+BEGIN_SRC scheme
  (define (make-zero-crossings input-stream last-value avpt)
    (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
      (cons-stream (sign-change-detector avpt last-value)
                   (make-zero-crossings (stream-cdr input-stream)
                                        (stream-car input-stream) avpt))))
#+END_SRC

~Упражнение 3.76.~
Ева Лу Атор недовольна подходом Хьюго из упражнения 3.75. Написанная им
программа не модульна, поскольку смешивает операции сглаживания и отлова пересечений
ноля. Например, тест на пересечение не должен изменяться, если Лизе удастся найти другой
способ улучшить качество входного сигнала. Помогите Хьюго и напишите
процедуру ~smooth~, которая берет на входе поток, а на выходе выдает
поток, элементы которого получены усреднением каждых двух последовательных
элементов входного потока. Затем используйте ~smooth~ как компоненту и
реализуйте детектор перехода через ноль в более модульном стиле.


Есть 2 варианта модульной реализации ~make-zero-crossings~:
- первый вариант построен по принципу черного ящика: препобразование
  входного потока в поток арифметических значений выполнен внутри
  функции, так же пользователю не надо вводить самостоятельно первичное
  значение ~last-value~
- во втором варианте пользователь должен самостоятельно позаботиться о
  том, чтоб передать уже преобразованный поток в ~make-zero-crossings~

Второй вариант предоставляет больше свободы пользователю системы. Первый
же избавляет юзера от возможных ошибок в вводе данных.

#+BEGIN_SRC scheme
  (define (smooth stream)
    (cons-stream (/ (+  (stream-car stream)
                        (stream-car (stream-cdr stream))) 2)
                 (smooth (stream-cdr stream))))

  ;; первый вариант
  (define (make-zero-crossings input-stream)
    (define (make-zero-crossings-inside stream last-value)
      (cons-stream (sign-change-detector input-stream last-value)
                   (make-zero-crossings-inside (stream-cdr input-stream)
                                               (stream-car input-stream))))
    (make-zero-crossings-inside (smooth input-stream) 0))

  ;; второй вариант
  (define (make-zero-crossings input-stream last-value)
    (cons-stream (sign-change-detector input-stream last-value)
                 (make-zero-crossings (stream-cdr input-stream)
                                      (stream-car input-stream))))

  (make-zero-crossings-inside (smooth input-stream) 0)
#+END_SRC

~Упражнение 3.77.~
Вышеприведенная процедура ~integral~ была аналогична «непрямому»
определению бесконечного потока натуральных чисел из раздела 3.5.2. В
виде альтернативы можно дать определение ~integral~, более похожее на
~integers-starting-from~ (также в разделе 3.5.2).

В системах с циклами эта реализациея порождает такие же проблемы, как и
наша исходная версия ~integral~. Модифицируйте процедуру так, чтобы она
ожидала integrand как задержанный аргумент, а следовательно, могла быть
использована в процедуре ~solve~.

~Объяснение~:
В данном случае происходит "задержка в задержке".
Это нужно, когда для вычисления результата нужно вычислить аргументы, а
для вычисления аргументов нужно вычислить результат. В результате мы
получаем "змею, кусающую свой хвост", т.е. либо получим сообщени об
ошибке при попытке вычислить такое выражение, либо уйдем в вечный цикл
ожидания, пока вычислится какой-то аргумент.
Поэтому мы можем вычислять аргументы и результат по очереди, что
позволяет делать процедура ~solve~ и задержанное вычисление аргументов.

Чем задержанный аргумент отличается от просто потока? В потоке вычислен
car, а дальше мы по запросу вычисляем каждый элемент из cdr. В
задержанном аргументе не вычислено ничего, даже car.

Процедура ~solve~ показывает как работает описанный выше парадокс.
Нам нужно вычислить интеграл.

Внутри процедуры у нас определяется 2 величины: ~y~ и ~dy~. Обе нужны для
вычисления друг друга.
При определении ~y~ используется вызов
~integral~ с тремя формальными параметрами, первый из которых -
задержанный поток dy.
~dy~ определяется как бесконечный поток, который является результатом
применения функции к ~y~. Поскольку у нас функция - это лямбда,
возвращающая полученный аргумент, то значения в ~dy~ и ~y~ будут
совпадать.

Что происходит при вызове ~(stream-ref (solve (lambda (y) y) 1 0.001) 10)~
- ~f~ - это лямбда, которая принимает аргумент и возвращает его
же.
- ~initial-value~ - 1
- ~dt~ - 0.001

Вызываем ~integral~ внутри определения ~y~ с заданными значениями.
Внутри ~integral~ есть ~cons-stream~, которая сразу возвращает нам поток,
состоящий из ~initial-value~ и ~обещания~ вычислить остальное. Так мы
вычислили первое значение ~y~.

Таким образом при первом вызове ~(solve (lambda (y) y) 1 0.001)~ мы
получим на выходе поток, чей первый элемент - 1, а хвост - обещание
вычислить прочие элементы.

Но ~stream-ref~ заставит вычислиться хвост этого потока 10 раз, т.е. мы
получим 10 элементов хвоста.

Каким образом будет вычисляться хвост?
Итак, нам теперь известно, что  первый элемент потокав ~y~ - это 1.
Начинаем вычислять хвост ~y~.
Вот тут заработает часть кода, начинающася с ~if~. Если по какой-то
причине переданный ~dy~ окажется пустым, то мы просто вернем пустой
поток.
В противном случае начнется самое интересное.
Вызываем ~force~, которая инициирует вычисление потока ~dy~, который до
этого момента не был вычислен вообще. Даже его первый элемент пока что
неизвестен. (Нельзя использовать ~stream-car~ вместо force, поскольку эта
процедура не вычисляет первый элемент потока, а лишь возвращает его.)

Мы помним, что dy - это результат вызова ~stream-map~. Так что вызвав
~force~,мы вызываем ~stream-map~, тот возвращает нам
поток, состоящий из применения функции к первому элементу потока ~y~ и
~обещания~ вычислить остальное. Этот поток попадает в локальную переменню
~integrand~. C его помощью его car мы изменяем ~initial-value~, а его
обещание вычислить его cdr передаем как новый задержанный поток в
рекурсивный вызов.

Почему вызов ~(stream-cdr integrand)~ обзательно нужно обернуть в
~delay~? Потому что чтоб вычислить этот хвост - хвост ~dy~ - нам нужно
новое значение ~y~, которое мы получим только перейдя на следующую
ступень рекурсии, где ~cons-stream~ снова вернет поток, состоящий из
~initial-value~ и обещания вычислить остальное.

Без использования ~delay~ мы попадем в бесконечный цикл вычисления y и
dy, потому что попытка вычисления хвоста dy будет вызывать попытку
вычислить хвост y, а тот будет снова пытаться вычислить dy. И это будет
продолжаться до исчерпания стека.

#+BEGIN_SRC scheme
  (define (solve f y0 dt)
    (define y (integral (delay dy) y0 dt))
    (define dy (stream-map f y))
    y)

  (define (integral delayed-integrand initial-value dt)
    (cons-stream initial-value
                 (if (stream-null? delayed-integrand)
                     the-empty-stream
                     (let ((integrand (force delayed-integrand)))
                       (integral (delay (stream-cdr integrand))
                                 (+ (* dt (stream-car integrand))
                                    initial-value)
                                 dt)))))


  (stream-ref (solve (lambda (y) y) 1 0.001) 1000)
#+END_SRC

~Упражнение 3.78.~
Рассмотрим задачу проектирования системы обработки сигналов для решения
гомогенных линейных дифференциальных уравнений второго порядка.
Выходной поток, моделирующий y, порождается сетью, содержащей цикл. Этот
цикл возникает потому, что значение d^2y/dt^2 зависит от значений y и dy/dt, а они оба
получаются интегрированием d^2 y/dt^2 .
Напишите процедуру ~solve-2nd~, которая в качестве аргументов берет константы a, b и
dt и начальные значения y0 и dy0 для y и dy, и порождает поток последовательных
значений y.

Итак, нам нужно построить другую версию процедуры ~solve~, только теперь
у нас больше величин, которе зависят друг от друга.

#+BEGIN_SRC scheme
  ;; поток y должен возрасти на величину b
  ;; поток dy должен возрасти на величину a
  ;; затем их надо сложить.
  ;; и тогда мы получим выходной поток y
  (define (solve-2nd a b dt y0 dy0)
    (define y (integral (delay dy) y0 dt))
    (define dy (integral (delay ddy) dy0 dt))
    (define ddy (add-streams (scale-stream dy a) (scale-stream y b)))
    y)
#+END_SRC

~Упражнение 3.79.~
Обобщите процедуру ~solve-2nd~ из упражнения 3.78 так, чтобы с ее помощью
можно было решать дифференциальные уравнения второго порядка общего вида
d^2y/dy^2 = f(dy/dt, y)
#+BEGIN_SRC scheme
  (define (solve-2nd f dt y0 dy0)
    (define y (integral (delay dy) y0 dt))
    (define dy (integral (delay ddy) dy0 dt))
    (define ddy (stream-map f dy y))
      y)
#+END_SRC


~Упражнение 3.80~
Последовательная RLC-цепь (series RLC circuit) состоит из резистора,
конденсатора и катушки индуктивности, соединенных последовательно, как показано на
рис. 3.36. Если сопротивление, индуктивность и емкость равны,
соответственно, R, L и C, то отношения между напряжением v и током i на
трех элементах описываются уравнениями (см. стр. 328)
Напишите процедуру RLC, которая в качестве аргументов берет параметры
цепи R, L и C и точность по времени dt. Подобно процедуре RC из упражнения 3.73, RLC
должна порождать процедуру, которая берет начальные значения переменных
состояния vC0 и iL0 и порождает (через cons) пару потоков состояния v
C и i L .
С помощью RLC породите пару потоков, которая моделирует
поведение RLC-цепи c K = 1 ом, C = 0.2 фарад, L = 1 генри, dt = 0.1
секунды, и начальными значениями iL0 = 0 ампер и vC0 = 10 вольт.

Резистор: устанавливается в электрической цепи для ограничения тока,
протекающего через цепь.
Конденсатор: может сосредотачивать, накапливать и отдавать заряд тока
другим элементам цепи. Отличие от батарейки: заряд накапливает долго, а
разряжаться может быстро, в виде импульса (привет вспышкам фотиков)

R - сопросивление
L - индуктивность
C - емкость
V - напряжение
i - ток

#+BEGIN_SRC scheme
  (define (RLC R L C dt)
    (lambda (vC0 iL0)
      (define Li (integral (delay diL) iL0 dt))
      (define vC (integral (delay dvC) vC0 dt))
      (define dvC (scale-stream Li (exact->inexact (/ -1 C))))
      (define diL (add-streams (scale-stream Li (exact->inexact (/  (/ R -1) L)))
                               (scale-stream vC (exact->inexact (/ 1 L)))))
      (cons Li vC)
      ))
#+END_SRC

~Упражнение 3.81.~
В упражнении 3.6 обсуждалась возможность обобщить генератор случайных
чисел и позволить пользователю сбрасывать последовательность случайных чисел, так, чтобы
можно было порождать воспроизводимые «случайные» последовательности. Постройте потоковый
вариант такой же процедуры-генератора, которая работает со входным потоком запросов вида
generate — породить новое число, либо reset — сбросить последовательность
в нужную точку, и которая порождает требуемый поток случайных чисел.
Не используйте в своем решении присваивание.

Итак, нам надо переделать решение для упражнения 3.6 таким образом, чтоб
не использовать присваивания и использовать потоки.
На вход процедура принимает пототок и возвращает поток.
Вот решение из упражнения 3.6.
#+BEGIN_SRC scheme
  (define rand
    (let ((x random-init))
      (lambda (arg)
        (cond ((eq? arg 'generate) (begin (set! x (rand-update x)) x))
              ((eq? arg 'reset ) (lambda (value) (set! x value)
                                         x))
              (else x)))))

  (define random-init
  (random (expt 2 31)))

  (define (rand-update x)
    (let ((a 13)
          (b 67)
          (m 6))
      (+ (* x a) (* (abs m) b))))

  ;; тесты
  (rand 'generate)
  ((rand 'reset) 3)
#+END_SRC

Входной поток будет состоять из меток
generate и reset. В зависимости от запроса мы будем вычислять cdr
выходного потока тем или иным способом.

Начинаем генерить поток с случайного числа, затем в соответствии с
полученными инструкциями (надо бы как-то переделать генерацию потока
инструкций, чтоб процесс был более рандомным).

#+BEGIN_SRC scheme
  (define (rand-update x)
    (let ((a 13)
          (b 67)
          (m 6))
      (+ (* x a) (* (abs m) b))))

  (define random-init
    (random (expt 2 31)))

  (define (rand stream)
    (define (iter int-value input-stream)
      (cons-stream int-value (if (and (pair? (stream-car input-stream))
                                      (eq? (car (stream-car input-stream)) 'reset))
                                 (iter (cdr (stream-car input-stream))
                                       (stream-cdr input-stream))
                                 (iter (rand-update int-value) (stream-cdr input-stream)))))
    (iter random-init stream))


  (define (make-instructions-stream x n)
    (cons-stream x
                 (if (= (remainder n 2) 0)
                     (make-instructions-stream (cons 'reset 2) (+ n 3))
                     (make-instructions-stream 'generate (+ n 4)))))

  (define instructions-stream (make-instructions-stream (cons 'reset 3) 1))

  (define (show-stream stream n)
    (if (= n 0)
        'done
        (begin
          (display (stream-car stream))
          (newline)
          (show-stream (stream-cdr stream) (- n 1)))))

  (show-stream (rand instructions-stream) 6)
#+END_SRC

~Упражнение 3.82.~
Переделайте на основе потоков упражнение 3.5 на интегрирование методом
Монте-Карло. Потоковая версия процедуры ~estimate-integral~ не требует
аргумента, который говорит, сколько проводить испытаний.
Вместо этого она порождает поток оценок, основанных на все большем
количестве испытаний.

Решение упражнения 3.5.
#+BEGIN_SRC scheme
  ;; необходимые для работы функции
  (define (random-in-range low high)
    (let ((range (- high low)))
      (+ low (random (abs range)))))

  ;; определенные мной процедуы и переменные

  ;; радиус и координаты центральной точки окружности
  (define radius 1)
  (define center-x 1)
  (define center-y 1)

  (define (square x)
    (* x x))

  ;; предикат для проверок принадлежности точки окрнужности
  (define (test x y)
    (<= (+ (square (- x center-x))
           (square (- y center-y)))
        (square radius)))

  (define (monte-carlo trials experiment)
    (define (iter trials-remaining trials-passed)
      (cond ((= trials-remaining 0)
             (/ trials-passed trials))
            ((experiment)
             (iter (- trials-remaining 1) (+ trials-passed 1)))
            (else
             (iter (- trials-remaining 1) trials-passed))))
    (iter trials 0))

  (define (square x) (* x x))

  (define (estimate-integral P x1 x2 y1 y2 n)
    ;; находит площать прямоугольника
    (define (S x1 x2 y1 y2)
      (* (- y2 y1) (- x2 x1)))
    (exact->inexact
     (* (abs (S x1 x2 y1 y2)) (monte-carlo n (lambda () (P (random-in-range x1 x2)
                                                           (random-in-range y1 y2)))))))
  (estimate-integral test 0.0 2.0 0.0 2.0 7000)
#+END_SRC

Переделанное решение для потоков.

#+BEGIN_SRC scheme
  (define radius 1)
  (define center-x 1)
  (define center-y 1)

  (define (square x)
    (* x x))

  (define (test x y)
    (<= (+ (square (- x center-x))
           (square (- y center-y)))
        (square radius)))

  (define (random-in-range low high)
    (let ((range (- high low)))
      (+ low (random (abs range)))))


  (define (estimate-integral P x1 x2 y1 y2)
    (define (S x1 x2 y1 y2)
      (* (- y2 y1) (- x2 x1)))
     (scale-stream (monte-carlo (lambda () (P (random-in-range x1 x2)
                                              (random-in-range y1 y2))))
                                (abs (S x1 x2 y1 y2))))

  (define (monte-carlo experiment)
    (define (iter passed failed)
      (cons-stream
       (/ passed (+ passed failed))
       (if (experiment)
           (iter (+ 1 passed) failed)
           (iter passed (+ 1 failed)))))
    (iter 1 1))
  (estimate-integral test 0.0 2.0 0.0 2.0)


  (show-stream-from-to (estimate-integral test 0.0 2.0 0.0 2.0) 1500 1510)
#+END_SRC
** Глава 4

Все(?) процедуры, указанные в мане для построения метациклического
интерпретатора

~метациклический интерпретатор~

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define apply-in-underlying-scheme apply)

  (define (apply procedure arguments)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure procedure arguments))
          ((compound-procedure? procedure)
           (eval-sequence
            (procedure-body procedure)
            (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
          (else
           (error
            "Неизвестный тип процедуры -- APPLY" procedure))))

  (define (list-of-values exps env)
    (if (no-operands? exps)
        '()
         (cons (eval (first-operand exps) env)
               (list-of-values (rest-operands exps) env))))

  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))

  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))

  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
                         (eval (assignment-value exp) env)
                         env)
    'ok)

  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)

  (define (self-evaluating? exp)
    (cond ((number? exp) true)
          ((string? exp) true)
          (else false)))

  (define (variable? exp) (symbol? exp))

  (define (quoted? exp)
    (tagged-list? exp 'quote))

  (define (text-of-quotation exp) (cadr exp))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  (define (assignment? exp)
    (tagged-list? exp 'set!))

  (define (assignment-variable exp) (cadr exp))

  (define (assignment-value exp) (caddr exp))

  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (definition-variable exp)
    (if (symbol? (cadr exp))
        (cadr exp)
        (caadr exp)))

  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))

  (define (lambda? exp) (tagged-list? exp 'lambda))

  (define (lambda-parameters exp) (cadr exp))

  (define (lambda-body exp) (cddr exp))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (if? exp) (tagged-list? exp 'if))

  (define (if-predicate exp) (cadr exp))

  (define (if-consequent exp) (caddr exp))

  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
        (cadddr exp)
        'false))

  (define (make-if predicate consequent alternative)
    (list 'if predicate consequent alternative))

  (define (begin? exp) (tagged-list? exp 'begin))

  (define (begin-actions exp) (cdr exp))

  (define (last-exp? seq) (null? (cdr seq)))

  (define (first-exp seq) (car seq))

  (define (rest-exps seq) (cdr seq))

  (define (sequence->exp seq)
    (cond ((null? seq) seq)
          ((last-exp? seq) (first-exp seq))
          (else (make-begin seq))))

  (define (make-begin seq) (cons 'begin seq))

  (define (application? exp) (pair? exp))

  (define (operator exp) (car exp))

  (define (operands exp) (cdr exp))

  (define (no-operands? ops) (null? ops))

  (define (first-operand ops) (car ops))

  (define (rest-operands ops) (cdr ops))

  (define (cond? exp) (tagged-list? exp 'cond))

  (define (cond-clauses exp) (cdr exp))

  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))

  (define (cond-predicate clause) (car clause))

  (define (cond-actions clause) (cdr clause))

  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false
                                          ; нет ветви else
         (let ((first (car clauses))
               (rest (cdr clauses)))
           (if (cond-else-clause? first)
               (if (null? rest)
                   (sequence->exp (cond-actions first))
                   (error "Ветвь ELSE не последняя -- COND->IF"
                          clauses))
               (make-if (cond-predicate first)
                        (sequence->exp (cond-actions first))
                        (expand-clauses rest))))))

  (define (true? x)
    (not (eq? x false)))

  (define (false? x)
    (eq? x false))

  (define (make-procedure parameters body env)
  (list 'procedure parameters body env))

  (define (compound-procedure? p)
    (tagged-list? p 'procedure))

  (define (procedure-parameters p) (cadr p))

  (define (procedure-body p) (caddr p))

  (define (procedure-environment p) (cadddr p))

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define the-empty-environment '())

  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))

  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Получено слишком много аргументов" vars vals)
            (error "Получено слишком мало аргументов" vars vals))))

  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (car vals))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная -- SET!" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define (define-variable! var val env)
    (let ((frame (first-frame env)))
      (define (scan vars vals)
        (cond ((null? vars)
               (add-binding-to-frame! var val frame))
              ((eq? var (car vars))
               (set-car! vals val))
              (else (scan (cdr vars) (cdr vals)))))
      (scan (frame-variables frame)
            (frame-values frame))))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-names)
                               (primitive-procedure-objects)
                               the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))

  (define (primitive-procedure? proc)
    (tagged-list? proc 'primitive))

  (define (primitive-implementation proc) (cadr proc))

  (define primitive-procedures
    (list (list 'car car)
          (list 'cdr cdr)
          (list 'cadr cadr)
          (list 'cdar cdar)
          (list 'cddr cddr)
          (list 'caddr caddr)
          (list 'first first)
          (list 'second second)
          (list 'third third)
          (list 'fourth fourth)
          (list 'cons cons)
          (list 'null? null?)
          (list 'list list)
          (list 'assoc assoc)
          (list 'append append)
          (list 'not not)
          (list 'eq? eq?)
          (list 'equal? equal?)
          (list 'xor xor)
          (list 'memq memq)
          (list 'newline newline)
          (list 'last-pair last-pair)
          (list '< <)
          (list '> >)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list '+ +)
          (list '- -)
          (list 'display display)
          (list 'member member)
          (list 'even? even?)
          (list 'remainder remainder)
          ))

  (define (primitive-procedure-names)
    (map car
         primitive-procedures))

  (define (primitive-procedure-objects)
    (map (lambda (proc) (list 'primitive (cadr proc)))
         primitive-procedures))

  (define (apply-primitive-procedure proc args)
    (apply-in-underlying-scheme
     (primitive-implementation proc) args))

  (define input-prompt ";;; Ввод M-Eval:")
  (define output-prompt ";;; Значение M-Eval:")

  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output (eval input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)))
    (driver-loop))

  (define (prompt-for-input string)
    (newline) (newline) (display string) (newline))

  (define (announce-output string)
    (newline) (display string) (newline))

  (define (user-print object)
    (if (compound-procedure? object)
        (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '<procedure-env>))
        (display object)))

  (define the-global-environment (setup-environment))
#+END_SRC


~Отделение анализа от исполнения~
#+BEGIN_SRC scheme
  (define (eval exp env)
    ((analyze exp) env))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  (define (analyze-self-evaluating exp)
    (lambda (env) exp))

  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))

  (define (analyze-variable exp)
    (lambda (env) (lookup-variable-value exp env)))

  (define (analyze-assignment exp)
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      (lambda (env)
        (set-variable-value! var (vproc env) env)
        'ok)))

  (define (analyze-definition exp)
    (let ((var (definition-variable exp))
          (vproc (analyze (definition-value exp))))
      (lambda (env)
        (define-variable! var (vproc env) env)
        'ok)))

  (define (analyze-if exp)
    (let ((pproc (analyze (if-predicate exp)))
          (cproc (analyze (if-consequent exp)))
          (aproc (analyze (if-alternative exp))))
      (lambda (env)
        (if (true? (pproc env))
            (cproc env)
            (aproc env)))))

  (define (analyze-lambda exp)
    (let ((vars (lambda-parameters exp))
          (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env) (make-procedure vars bproc env))))

  (define (analyze-sequence exps)
    (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (loop (car procs) (cdr procs))))

  (define (analyze-application exp)
    (let ((fproc (analyze (operator exp)))
          (aprocs (map analyze (operands exp))))
      (lambda (env)
        (execute-application (fproc env)
                             (map (lambda (aproc) (aproc env))
                                  aprocs)))))
  (define (execute-application proc args)
    (cond ((primitive-procedure? proc)
           (apply-primitive-procedure proc args))
          ((compound-procedure? proc)
           ((procedure-body proc)
            (extend-environment (procedure-parameters proc)
                                args
                                (procedure-environment proc))))
          (else
           (error
            "Неизвестный тип процедуры -- EXECUTE-APPLICATION"
            proc))))
#+END_SRC

~ленивый интерпретатор~

Залей все для метациклического оператора (можно без кода для анализа
выражений до исполнения)

Можно, теоретически, проверить этим упражнения на ленивый интерпретатор:

И потом залей это:
Дополнения:
#+BEGIN_SRC scheme
  (define (actual-value exp env)
    (force-it (eval exp env)))

  (define (eval exp env)
    ;; самовычисляющееся? - вычислить сразу
    (cond ((self-evaluating? exp) exp)
          ;; переменная? - запусть ее поиск в окружении
          ((variable? exp) (lookup-variable-value exp env))
          ;; построение списока? - вернуть список или заковыченное выражение
          ((quoted? exp) (text-of-quotation exp))
          ;; присваивание? - запустить процесс присваивания
          ((assignment? exp) (eval-assignment exp env))
          ;; определение? - запустить процесс определения
          ((definition? exp) (eval-definition exp env))
          ;; особая форма if? - вычислить if
          ((if? exp) (eval-if exp env))
          ;; особая формя lambda? - создать процедуру
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ;; форма begin? - создать блок begin
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ;; cond? - превратить его в вложенные ифы
          ((cond? exp) (eval (cond->if exp) env))
          ;;вызов процедуры? - запустить вычисление процедуры
          ((application? exp)
           (apply (actual-value (operator exp) env)
                  (operands exp)
                  env))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define (apply procedure arguments env)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure
            procedure
            (list-of-arg-values arguments env))) ; изменение
          ((compound-procedure? procedure)
           (eval-sequence
            (procedure-body procedure)
            (extend-environment
             (procedure-parameters procedure)
             (list-of-delayed-args arguments env) ; изменение
             (procedure-environment procedure))))
          (else
           (error
            "Неизвестный тип процедуры -- APPLY" procedure))))

  (define (list-of-arg-values exps env)
    (if (no-operands? exps)
        '()
         (cons (actual-value (first-operand exps) env)
               (list-of-arg-values (rest-operands exps)
                                   env))))
  (define (list-of-delayed-args exps env)
    (if (no-operands? exps)
        '()
         (cons (delay-it (first-operand exps) env)
               (list-of-delayed-args (rest-operands exps)
                                     env))))

  (define (eval-if exp env)
    (if (true? (actual-value (if-predicate exp) env))
        (eval (if-consequent exp) env)
        (eval (if-alternative exp) env)))

  (define input-prompt ";;; Ввод L-Eval:")
  (define output-prompt ";;; Значение L-Eval:")
  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output
             (actual-value input the-global-environment)))
        (announce-output output-prompt)
        (user-print output)))
    (driver-loop))

  (define the-global-environment (setup-environment))

  (define (delay-it exp env)
    (list 'thunk exp env))

  (define (thunk? obj)
    (tagged-list? obj 'thunk))

  (define (thunk-exp thunk) (cadr thunk))

  (define (thunk-env thunk) (caddr thunk))

  (define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))

  (define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

  (define (force-it obj)
    (cond ((thunk? obj)
           (let ((result (actual-value
                          (thunk-exp obj)
                          (thunk-env obj))))
             (set-car! obj 'evaluated-thunk)
             (set-car! (cdr obj) result)
                                          ; заменить exp на его значение
             (set-cdr! (cdr obj) '()) ; забыть ненужное env
             result))
          ((evaluated-thunk? obj)
           (thunk-value obj))
          (else obj)))

#+END_SRC


~Упражнение 4.1.~
Заметим, что мы не можем сказать, вычисляет ли метациклический
интерпретатор операнды слева направо или справа налево. Порядок
вычисления наследуется от нижележащего Лиспа: если аргументы ~cons~ в
процедуре ~list-of-values~ вычисляются слева направо, то и
операнды в ~list-of-values~ будут вычисляться слева направо. Если же вычисление
аргументов ~cons~ происходит справа налево, то и ~list-of-values~ будет
вычислять операнды справа налево.
Напишите версию ~list-of-values~, которая вычисляет операнды слева направо,
вне зависимости от порядка вычислений в нижележащем Лиспе. Напишите также версию,
которая вычисляет операнды справа налево.

Определение исходной версии ~list-of-values~

#+BEGIN_SRC scheme
  ;; принимает на вход список выражений и окружение
  ;; на выходе получим список рехультатов выражений
  (define (list-of-values exps env)
    (if (no-operands? exps)
        '()
         (cons (eval (first-operand exps) env)
               (list-of-values (rest-operands exps) env))))
#+END_SRC

Было похожее ~упражнение 3.8~, в котором требовалось именить порядок
вычисления.
В этом нам помог ~set!~, поскольку порядок вычисления формы ~set!~ всегда
будет один и тот же: сначала вычисляем выражение, результ которого
запишем в переменную, и только затем присвоим результат переменной.

Исходя из формулировки упражнения ясно, что ~cons~ использовать нельзя,
поскольку порядок вычислений может меняться. Значит нам надо соединить
результаты вычисления в список вручную, используя присваивание.

#+BEGIN_SRC scheme
  ;;вычисляет аргументы слева направо
  (define (my-list-of-values exps env)
    (define (iter exps env results)
    (if (no-operands? exps)
        results
        (let ((first-exp-result (list (eval (first-operand exps) env))))
          (if (null? results)
              (begin
                (set! results (list first-exp-result))
                (iter (rest-operands exps) env results))
              (begin
                (set-cdr! (last-pair results) (list first-exp-result))
                (iter (rest-operands exps) env results))))))
    (iter exps env '()))

  ;; поскольку my-list-of-values, определенную выше, протестить пока невозможно,
  ;; пишем аналогичную функцию и тестим ее
  (define (test list-args)
    (define (iter list-args results)
      (if (null? list-args)
          results
          (let ((first-elt (list (car list-args))))
            (if (null? results)
                (begin
                  (set! results (list first-elt))
                  (iter (cdr list-args) results))
                (begin
                  (set-cdr! (last-pair results) (list first-elt))
                  (iter (cdr list-args) results))))))
    (iter list-args '()))

  (test '(1 2 3 4))

  ;;вычисляет аргументы справа налево
  ;; выглядит как грязный хак, но работает
  (define (my-list-of-values exps env)
      (if (no-operands? exps)
          '()
          (let ((first-exp-result (eval (first-operand exps) env))
                (rest-args (my-list-of-values (rest-operands exps) env)))
            (cons first-exp-result rest-args))))

  ;; пишем аналогичную тестовую функцию
  (define (test list-args)
    (if (null? list-args)
        '()
        (let ((first (list (car list-args)))
              (rest (test (cdr list-args))))
          (cons first rest))))

  (test '(1 2 3 4))
#+END_SRC

~Упражнение 4.2.~
Хьюго Дум хочет переупорядочить ветви ~eval~ так, чтобы ветвь для вызова
процедур располагалась перед веткой для присваивания. Он утверждает, что при этом
интерпретатор станет эффективнее: поскольку в программах обычно больше
вызовов процедур, чем присваиваний, определений и т. д., его
усовершенствованный eval обычно будет рассматривать меньше вариантов,
чем исходный, при распознавании типа выражения.

а. Что за ошибка содержится в плане Хьюго? (Подсказка: что сделает его
интерпретатор с выражением (define x 3)?)

б. Хьюго расстроен, что его план не сработал. Он готов пойти на любые
жертвы, чтобы позволить интерпретатору распознавать вызовы процедур до того, как он
проверяет все остальные типы выражений.
Помогите ему, изменив синтаксис интерпретируемого языка
так, чтобы вызовы процедур начинались с символа call.
Например, вместо (factorial 3) нам теперь придется
писать (call factorial 3), а вместо (+ 1 2) — (call + 1 2).

Ответ а:
Хьюго в первом задании предлагает ветку исполнения процедур поместить в
начале, поскольку вызовы процедур встречаются чаще, значит, не придется
проверять все ветки каждый раз.

Но возникает проблема с определениями процедур типа (define x 3)
Срабатывает предикат ~defenition?~, поскольку выражение начинается с
~define~, затем вызывается данная процедура:

#+BEGIN_SRC scheme
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)
#+END_SRC

Получаем имя переменной, затем вычисляем значение выражения в данном
окружении и присваиваем значение имени. Проблема в том, что define - это
синтаксический сахар для лямбды, которая в нем содержится. Это значит,
что (define x 3) может быть воспринят как вызов процедуры, в результате
таг define будет воспринят как оператор, который следует применить к
аргументм x и 3. В результате нас ждут ошибки.

Ответ б:
Чтоб избежать проблемы, описанной выше, нам теперь перед каждым вызовом
процедуры нужно будет писать, что это именно вызов, т.е. ~call~ или любой
другой зарезервированный для этого символ, что довольно неудобно.
И тогда редикат application? следует переписать таким образом, чтоб
первым делом он проверял наличие соответствующего тага у выражения.
Например, так:

#+BEGIN_SRC scheme
  (define (application? exp)
    (tagged-list? exp 'call))
#+END_SRC

~Упражнение 4.3.~
Перепишите ~eval~ так, чтобы диспетчеризация происходила в стиле,
управляемом данными. Сравните результат с дифференцированием, управляемым
данными, из упражнения 2.73. (Можно использовать car составного выражения
в качестве типа этого выражения, так как это хорошо
сочетается с синтаксисом, реализованным в этом разделе.)

Итак, раз нас просят использовать стиль, управляемый данными, значит, нам
нужно представить, что у нас есть таблица типов, как в колнце второй
главы и использовать ее. Предположим, что все операции уже помещены в
таблицу и теперь нам только достать их с gjvjom. ~apply-generic~, которая
самостоятельно найдет операцию в таблице для типов данных аргументов и
применит ее, если операция существует.

Некоторые процедуры будут вызываться самостоятельно, без ~apply-generic~,
поскольку сущесвуют в единственном виде для всех типов, остальные
выражения будут обрабатываться с помощью ~apply-generic~. Здесь есть
важное дополнение: чтоб данный способ сработал, вызов процедур должен
иметь вид (call вызов_нужной_процедуры), поскольку в исходном варианте
~eval~ вызовом процедуры считается любое выражение, которое является
списком и не подошло ни под одно предыдущее условие ~cond~

Сравнение с упражнением 2.73 выглядело бы более корректным, если бы я
использовала ~get~ вместо ~apply-generic~. Так что я напишу второй
вариант как в упражнении 2.73. В этом сучае так же придется изменить
представление вызова процедур.

Данное представление ~eval~, как и представление ~deriv~ делает программу
более гибкой, поскольку в случае добавления типов выражений, которые мы
хотим вычислить, нам не придется менять саму ~eval~, мы просто добавим
дополнительную процедуру в таблицу.

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          (else
           (apply-generic 'eval exp env))))

  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          (else
           ((get 'eval (car exp)) (cdr exp) env))))

#+END_SRC

~Упражнение 4.4.~
Вспомним определения особых форм and и or из главы 1:

- and: выражения вычисляются слева направо. Если значение какого-то из
  них оказывается ложным, возвращается ложь; оставшиеся выражения не
  вычисляются. Если все выражения оказываются истинными, возвращается
  значение последнего из них. Если нет ни одного выражения, возвращается истина.
- or: выражения вычисляются слева направо. Если значение какого-то из
  них оказывается истинным, возвращается это значение; оставшиеся
  выражения не вычисляются. Если все выражения оказываются ложными,
  или нет ни одного выражения, возвращается ложь.

Введите and и or в качестве новых особых форм интерпретатора, определив
соответствующие синтаксические процедуры и процедуры выполнения eval-and и eval-or. В
качестве альтернативы покажите, как можно реализовать and и or в виде
производных выражений.

Вариант а:
#+BEGIN_SRC scheme
  (define (or? exp)
    (tagged-list? exp 'or))

  (define (and? exp)
    (tagged-list? exp 'and))

  (define (eval-and exp env)
    (define (eval-and-iter exps env)
      (display exps)
      (newline)
      (cond ((null? exps) #t)
            ((null? (rest-exps exps)) (eval (first-exp exps) env))
            ((eval (first-exp exps) env) (eval-and-iter (rest-exps exps) env))
            (else #f)))
    (eval-and-iter (cdr exp) env))

  (define (eval-or exp env)
    (define (eval-or-iter exps env)
    (if (null? exps)
        #f
        (let ((some-result (eval (first-exp exps) env)))
          (if some-result
              some-result
              (eval-or (rest-exps exps) env)))))
    (display "eval-or")
    (newline)
    (display exp)
    (newline)
    (eval-or-iter (cdr exp) env))
#+END_SRC

Вставляем необходиые ветки в eval  и задливаем все в интерпретатор для проверки.
#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((or? exp) (eval-or exp env))
          ((and? exp) (eval-and exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

Вариант с производными выражениями:

#+BEGIN_SRC scheme
  (define (expand-and exp)
    (define (expand-and-iter exps)
      (if (null? exp)
          #t
          (let ((first (first-exp exps))
                (rest (rest-exps exps)))
            (if (null? rest)
                (sequence->exp (list first))
                (make-if first
                         (expand-and-iter (rest-exps exps))
                         #f)))))
    (expand-and-iter (cdr exp)))

  (define (expand-or exp)
    (define (expand-or-iter exps)
    (if (null? exps)
        #f
        (let ((first (first-exp exps))
              (rest (rest-exps exps)))
          (make-if first
                   (sequence->exp (list first))
                   (expand-or-iter (rest-exps exps))))))
    (expand-or-iter (cdr exp)))
#+END_SRC

Вставляем процедуры в eval и заливаем в интерпретатор
#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((or? exp) (expand-or exp))
          ((and? exp) (expand-and exp))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

~Упражнение 4.5.~
В языке Scheme есть дополнительная разновидность синтаксиса вариантов
cond, (проверка) => (потребитель). Если результат вычисления <проверки> оказывается
истинным значением, то вычисляется <потребитель>. Его значение должно быть
одноместной процедурой; эта процедура вызывается со значением <проверки>
в качестве аргумента, и результат этого вызова возвращается как значение
выражения cond. Измените обработку cond так, чтобы она поддерживала этот
расширенный синтаксис.

У меня получилось только полностью его заменить..
#+BEGIN_SRC scheme
  (define (=>? exp)
    (tagged-list? exp '=>))

  (define (expand-clauses clauses)
    (if (null? clauses)
        'false
        (let ((first (car clauses))
              (rest (cdr clauses)))
          (if (cond-else-clause? first)
              (if (null? rest)
                  (sequence->exp (cond-actions first))
                  (error "Ветвь ELSE не последняя -- COND->IF"
                         clauses))
              (begin
                (display (sequence->exp
                          (list (append (cond-actions (cdr first))
                                        (list (cond-predicate first))))))
              ;; если первый символ из списка действий в текущем выражении =>
              ;; и при этом предикат истинен
              (make-if (and (=>? (cond-actions first)) (cond-predicate first))
                       ;; создаем выражение, в котором передаем действию из выражения
                       ;; значение предиката
                       (sequence->exp
                        (list (append (cond-actions (cdr first))
                                      (list (cond-predicate first)))))

                       ;; иначе создаем стандартный иф для cond
                       (make-if (cond-predicate first)
                                  (sequence->exp (cond-actions first))
                                  (expand-clauses rest))))))))

  (cond ((assoc 'v '((a 1) (b 2))) => cadr)
        ((assoc 'b '((a 3) (b 4))) => cadr)
        (else false))

#+END_SRC

~Упражнение 4.6.~
Выражения let производны, поскольку раскрываются в лямбду.
Напишите синтаксическое преобразование ~let->combination~, которое сводит
вычисление let-выражений к вычислению комбинаций указанного вида, и добавьте
соответствующую ветку для обработки let к eval.

#+BEGIN_SRC scheme
  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))

;; тест
  (let ((a 3)
        (b 4))
    (let ((v 5)
          (g 7))
    (+ a b g v)))

#+END_SRC

Добавляем ветку в ~eval~

#+BEGIN_SRC scheme
  (define (eval exp env)
      (cond ((self-evaluating? exp) exp)
            ((variable? exp) (lookup-variable-value exp env))
            ((quoted? exp) (text-of-quotation exp))
            ((assignment? exp) (eval-assignment exp env))
            ((definition? exp) (eval-definition exp env))
            ((if? exp) (eval-if exp env))
            ((lambda? exp)
             (make-procedure (lambda-parameters exp)
                             (lambda-body exp)
                             env))
            ((begin? exp)
             (eval-sequence (begin-actions exp) env))
            ((cond? exp) (eval (cond->if exp) env))
            ((let? exp) (eval (let->combination exp) env))
            ((application? exp)
             (apply (eval (operator exp) env)
                    (list-of-values (operands exp) env)))
            (else
             (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

~Упражнение 4.7~.
Особая форма ~let*~ подобна let, но только связывания переменных в let*
происходят последовательно, и каждое следующее связывание происходит в
окружении, где видны все предыдущие.
Объясните, каким образом можно переписать выражение ~let*~ в виде
набора вложенных выражений ~let~, и напишите процедуру ~let*->nested-lets~,
которая проделывает это преобразование. Если мы уже реализовали let (упражнение 4.6)
и хотим теперь расширить интерпретатор так, чтобы он обрабатывал let*, достаточно ли
будет добавить в ~eval~ ветвь, в которой действием записано
~(eval (let*->nested-lets exp) env)~
или нужно явным образом преобразовывать let* в набор непроизводных
выражений?

Преобразование формы let* -> вложенные let -> вложенные лямбды:
#+BEGIN_SRC scheme
  (let* ((x 3)
         (y (+ x 2))
         (z (+ x y 5)))
    (* x z))

  (let ((x 3))
    (let ((y (+ x 2)))
      (let ((z (+ x y 5)))
        (* x z))))

  ((lambda (x)
    ((lambda (y)
       ((lambda (z)
          (* x z)) (+ x y 5))) (+ x 2))) 3)
#+END_SRC

Пишем преобразование let* в вложенные let:

#+BEGIN_SRC scheme
  (define (make-let param-and-expr-list body)
    (list 'let param-and-expr-list body))

  (define (let*? exp)
    (tagged-list? exp 'let*))

  (define (let*->nested-lets exp)
    (define (iter param-and-expr-list body)
      (if (null? param-and-expr-list)
          body
          (make-let (list (car param-and-expr-list))
                    (iter (cdr param-and-expr-list) body))))
    (iter (cadr exp) (car (last-pair exp))))

  ;; тест
    (let* ((x 3)
           (y (+ x 2))
           (z (+ x y 5)))
      (* x z))

#+END_SRC

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((let? exp) (eval (let->combination exp) env))
          ((let*? exp) (eval (let*->nested-lets exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

#+END_SRC

Отдельно преобразовывать let* в вложенные лямбды не нужно, поскольку
~eval~ все доделает за нас:
 - при получении let* eval раскроет его в вложенные let благодаря
   сработавшей ветке  ~(eval (let*->nested-lets exp) env)~,
 - затем let будет преобразован в лямбду, а все вложенные let станут телом
   лямбды.
 - при вычислении процедуры вычисляется ее тело и аргументы. При
   вычислении тела лямбды мы наткнемся на вложенные ~let~ и раскроем их
   тоже.

И так до тех пор, пока выражение не превратится в такое, которое можно
вычислить полностью, поскольку именно к этому стремится ~eval~

~Упражнение 4.8.~
«Именованный let» — это вариант let, который имеет вид
(let <переменная> <связывание> <тело>)
Измените преобразование ~let->combination~ из упражнения 4.6 так, чтобы оно
поддерживало именованный let.

Пример именованного ~let~:
#+BEGIN_SRC scheme
  (define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))
#+END_SRC

Обычно ~let~ раскрывается в вызов лямбды, а именованая лямбда выглядит так:
#+BEGIN_SRC scheme
  (define square
    (lambda (x) (* x x)))
#+END_SRC

Соответственно, нам просто нужно ракрыть вызов именованного ~let~ в
именованную лямбду. Это в общем случае. В конкретном пришлось
использовать промисы из-за имеющейся рекурсии, поэтому данное
преобразование годится только для этого примера.

Пока в матециклическом интерпретаторе проверить не удалось.
#+BEGIN_SRC scheme
  (define (fib n)
    (let fib-iter ((a 1)
                   (b 0)
                   (count n))
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1)))))

  ;; именованный let должен раскрыться в:
    (define fib-iter
      (lambda (a b count)
        (cons-stream a
                     (if (= count 0)
                         b
                         (fib-iter (+ a b) a (- count 1))))))

  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (show-stream stream n)
    (if (= n 0)
        'done
        (begin
          (display (stream-car stream))
          (newline)
          (show-stream (stream-cdr stream) (- n 1)))))

  (define (let->combination exp)
    (define (get-all-params exp)
      (map (lambda (x) (car x)) exp))
    (define (get-all-exps exp)
      (map (lambda (x) (cadr x)) exp))
    (list 'define (cadr exp)
          (make-lambda (get-all-params (caddr exp))
                       (list (list
                              'cons-stream (car (get-all-params (caddr exp)))
                              (cadddr exp))))))

  (let->combination '(let fib-iter ((a 1)
                                    (b 0)
                                    (count n))
                       (if (= count 0)
                           b
                           (fib-iter (+ a b) a (- count 1)))))
#+END_SRC

~Упражнение 4.9~.
Во многих языках имеются различные конструкции для построения циклов,
например, do, for, while и until. В Scheme итеративные процессы можно
выразить через обычные вызовы процедур, так что особые конструкции не
дают никакого существенного выигрыша в вычислительной мощности.
С другой стороны, часто они удобны. Придумайте какие-нибудь
конструкции для итерации, дайте примеры их использования и покажите, как
их реализовать в виде производных выражений.

Попробуем реализовать относительно несложный цикл ~while~. Итерации
происходят до тех пор, пока условие while истинно.

#+BEGIN_SRC scheme
  (define (make-while condition step-form body)
    (list 'while condition step-form body ))

  (define (while? exp)
    (tagged-list? exp 'while))

  (define (eval-while exp env)
    (define (eval-while-iter condition body)
      (if (eval condition env)
          (begin
            (eval-sequence body env)
            (eval-while-iter condition body))
          'done
          ))
    (let ((exp-without-tag (rest-exps exp)))
      (eval-while-iter (first-exp exp-without-tag) (rest-exps exp-without-tag))))


  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((let? exp) (eval (let->combination exp) env))
          ((let*? exp) (eval (let*->nested-lets exp) env))
          ((while? exp) (eval-while exp env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define test 0)

  (while (< test 10)
         (display test)
         (set! test (+ test 1)))


#+END_SRC

И попробуем реализовать цикл ~for~.

#+BEGIN_SRC scheme
  (define (make-for var-and-init-value step-form condition body)
    (list 'for var-and-init-value step-form condition body))


  (define test (for (list i 0) (set! i (+ i 1)) (> i 20)
                     (display i))

  (define (for? exp)
    (tagged-list? exp 'for))

  (define (eval-for exp env)
    (define (eval-for-iter condition step-form-and-body)
      (if (not (eval condition env))
          (begin
            (eval-sequence step-form-and-body env)
            (eval-for-iter condition step-form-and-body))
          'done))
    (let* ((initial-form (first-exp (rest-exps exp)))
           (var (car initial-form))
           (init-value (cadr initial-form))
           (step-form (third exp))
           (condition (fourth exp))
           (step-form-and-body (append (cddddr exp) (list step-form))))
      (eval `(define ,var ,init-value) env)
      (eval-for-iter condition step-form-and-body)))

  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((let? exp) (eval (let->combination exp) env))
          ((let*? exp) (eval (let*->nested-lets exp) env))
          ((while? exp) (eval-while exp env))
          ((for? exp) (eval-for exp env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))
#+END_SRC

~Упражнение 4.11.~
Вместо того, чтобы представлять кадр в виде списка списков, его можно
представить как список связываний, где каждое связывание является парой из имени и
значения. Перепишите операции с окружениями в соответствии с этим
альтернативным представлением.

Исходное представление окружения:
- окружение - это список, состоящий из списокв
- каждый подсписок - это кадр
- каждый кадр содержит в себе два списка: список переменных и список их значений:

~'((a b c d) (1 2 3 4))~
Вместо исходного представления кадра нам предлагается представить кадр
как список списков, где каждый подсписок - это пара переменная-значение:
~'((a 1) (b 2) (c 3) (d 4))~

Значит, нам надо только изменить процедуры, работающие непосредственно с
кадрами.

Функции ~look-up-for-variable~ и ~extend-environment~ изменять не
пришлось
Проверено через обычную схему
#+BEGIN_SRC scheme
  (define the-empty-environment '())

  (define (enclosing-environment env) (cdr env))

  (define (first-frame env) (car env))

  (define (make-frame vars vals)
    (map (lambda (x y)
           (list x y )) vars vals))

  (define test-frame (make-frame '(a b c d) '(1 2 3 4)))

  (define (frame-variables frame)
    (map (lambda (x)
           (car x)) frame))

  (frame-variables test-frame)

  (define (frame-values frame)
    (map (lambda (x)
           (cadr x)) frame))

  (frame-values test-frame)

  (define (add-binding-to-frame! var val frame)
    (cons (list var val) frame))

  (add-binding-to-frame! 'e 5 test-frame)

  (define base-env (list test-frame test-frame))

  ;; присоединяем новый кадр к текущему окружению
  ;; изменять не пришлось
  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
        (cons (make-frame vars vals) base-env)
        (if (< (length vars) (length vals))
            (error "Получено слишком много аргументов" vars vals)
            (error "Получено слишком мало аргументов" vars vals))))

  (set! base-env (extend-environment '(r t y u) '(5 6 7 8) base-env))

  (define (define-variable! var val env)
    (let ((cur-frame (first-frame env)))
      (define (scan frame)
        (if (null? frame)
            (begin
            (set-car! env
                      (add-binding-to-frame! var val cur-frame))
            #t)
            (let ((cur-pair (car frame)))
              (if (eq? var (car cur-pair))
                  (begin
                    (set-cdr! cur-pair (list val))
                    #t)
                  (scan (cdr frame))))))
      (scan cur-frame)))

  (define-variable! 't 0 base-env)
  (define-variable! 'k 0 base-env)

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (define (scan frame)
        (if (null? frame)
            (env-loop (enclosing-environment env))
            (let ((cur-pair (car frame)))
              (if (eq? var (car cur-pair))
                  (begin
                    (set-cdr! cur-pair (list val))
                    #t)
                  (scan (cdr frame))))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная -- SET!" var)
          (let ((frame (first-frame env)))
            (scan frame))))
    (env-loop env))

  (set-variable-value! 'r 13 base-env)
  (set-variable-value! 'a 8 base-env)
  (set-variable-value! 'g 0 base-env)

  ;; ничего менять не пришлось
  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (car vals))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (lookup-variable-value 'd base-env)
#+END_SRC

~Упражнение 4.12.~
Процедуры ~set-variable-value!~, ~define-variable!~ и ~lookup-variable-value~
можно выразить посредством более абстрактных процедур для просмотра структуры
окружений. Определите абстракции, которые фиксируют общую схему
поведения, и с их помощью перепишите эти три процедуры.

Я так понимаю, что нам нужно написать общую процедуру, через которую мы
сможем выразить три названные процедуры.

Чем похожи эти процедуры?
- все три ищут переменные в окружении
- все делают это более-менее похожим образом

Напишем общую процедуру для поиска чего-либо внутри окружения/кадра. Она
будет искать переменную в кадре и если найдет, то вернет ее индекс в
списке переменных (индекс начинается с нуля) или же #f если ничего нет.

Так же внутри исходной функции ~scan~ при нахождении нужной переменной
выполняются заданные действия, например, присвоение переменной другого
значения или же генерирование нового связывния и добавления его в текущий
кадр.

Мы для этого напишем отдельные функции: ~get-value-by-indx!~ и
~set-value-by-indx!~, они оба принимают индекс.
~get-value-by-indx!~ - возвращает хначение пересенной
~set-value-by-indx!~ - устанавливает значение переменной

Зачем нам индексы вообще? Дело в том, что список переменных и их значений
идет параллельно. Т.е. первый элемент списка переменных соответстввует
первому элементу писка значений и т.д. Соответственно, когда мы ищем
переменную, мы возвращаем ее порядковый номер, индекс, чтоб в дальнейшем
могли добраться до ее значения или ее самой по индексу.

Недостаток этого подхода заключается в том, что приходится дважды
проходить по спискам: первый раз когда ищем переменную и второй, когда
возвращаем/устанавливаем значение

Проверено через обычную схему
#+BEGIN_SRC scheme
  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))

  (define base-env (list (make-frame '(a b c d) '(1 2 3 4))
                         (make-frame '(e f v n) '(5 6 7 8))))

  (define (set-value-by-indx! val vals indx)
    (if (= indx 0)
        (set-car! vals val)
        (set-value-by-indx! val (cdr vals) (- indx 1))))

  (define (scan var vars vals indx)
    (if (null? vars)
        #f
        (if (eq? var (car vars))
            indx
            (scan var (cdr vars) (cdr vals)))))

  (define (get-value-by-indx! vals indx)
    (if (= indx 0)
        (car vals)
        (get-value-by-indx! (cdr vals) (- indx 1))))

  (define (define-variable! var val env)
    (let* ((frame (first-frame env))
           (get-var-indx (scan var
                               (frame-variables frame)
                               (frame-values frame) 0)))
      (if get-var-indx
          (set-value-by-indx! val (frame-values frame)
                              get-var-indx)
          (add-binding-to-frame! var val frame))))

  (define-variable! 'd 10 base-env)

  (define (set-variable-value! var val env)
    (define (env-loop env)
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная -- SET!" var)
          (let* ((frame (first-frame env))
                 (get-var-indx (scan var
                                     (frame-variables frame)
                                     (frame-values frame) 0)))
                 (if get-var-indx
                     (set-value-by-indx! val (frame-values frame)
                                         get-var-indx)
                     (env-loop (cdr env))))))
    (env-loop env))

  (set-variable-value! 'd 14 base-env)

  (define (lookup-variable-value var env)
    (define (env-loop env)
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let* ((frame (first-frame env))
                (get-var-indx (scan var
                                    (frame-variables frame)
                                    (frame-values frame) 0)))
            (if get-var-indx
                (get-value-by-indx! (frame-values frame)
                                    get-var-indx)
                (env-loop (cdr env))))))
    (env-loop env))

  (lookup-variable-value 'd base-env)
#+END_SRC

~Упражнение 4.13.~
Scheme позволяет создавать новые связывания через define, но не дает
никакого способа избавиться от связывания. Реализуйте в интерпретаторе особую форму
make-unbound!, которая изымает связывание данного символа из окружения, в
котором make-unbound! выполняется.

Задача определена не до конца. Например, нужно ли удалять связывания в
других кадрах, кроме первого? Дополните спецификацию и объясните свой выбор вариантов.

Наверное, прежде чем дополнять спецификацию, стоит подумать, зачем нам
отвязывание.

Освободить имя? Но имен очень много, вряд ли возникнет ситуация, когда
нужен именно этот символ и именно для конкретных целей, а он уже занят
какой-то другой привязкой.

Я думаю, что имеет смысл отвязывать переменные ради экономии
памяти. Тогда нам нужно отвязаться переменную во всех кадрах окружения,
убедившись перед этим, что на нее нигде нет ссылок. Тогда мы
сконструируем нечто, сильно напоминающее "сборщик мусора", а это сделать
непросто.

Поэтому я сделаю промежуточную версию сборщика мусора. Если поступит
команда отвязать переменную, я буду отвязывать ее во всех кадрах текущего
окружения. Мне кажется это более безопасным с точки зрения
программирования. Если этого не сделать, то могут возникнуть
сложноотслеживаемые баги. Например, у нас есть два кадра с одной и той же
переменной. Предположим, в первом кадре мы отвязали символ от текущей
переменной и присвоили его функции. Но во втором кадре этот символ занят
все еще переменной. Через какое-то время можно легко забыть, с чем в
каком кадре связан символ и потом долго гадать, почему интерпретатор
утверждает, что мы пытаемся обратиться к переменной как к функции и
наоборот. Особенно весело будет отлаживать такие вещи в большом проекте.

Предполагается, что кадры организованы как в мане, т.е. в виде пары с
двумя подсписками: в одном все переменные, в другом их значения

Проверено через обычную схему
#+BEGIN_SRC scheme
  (define (make-frame variables values)
    (cons variables values))

  (define (frame-variables frame) (car frame))

  (define (frame-values frame) (cdr frame))

  (define (scan-and-copy-frame var old-vars-list old-vals-list
                               new-vars-list new-vals-list)
    (cond ((null? old-vars-list)
           (make-frame new-vars-list new-vals-list))
          ((eq? var (car old-vars-list))
           (make-frame (append new-vars-list (cdr old-vars-list))
                       (append new-vals-list (cdr old-vals-list))))
          (else (scan-and-copy-frame var (cdr old-vars-list) (cdr old-vals-list)
                                     (append new-vars-list (list (car old-vars-list)))
                                     (append new-vals-list (list (car old-vals-list)))))))

  (scan-and-copy-frame 'f '(a s d f) '(1 2 3 4) '() '())

  (define (make-unbound! var env)
    (define (env-loop env)
      (if (eq? env the-empty-environment)
          'ok
          (let ((frame (first-frame env)))
            (set-car! env
                  (scan-and-copy-frame var (frame-variables frame)
                                       (frame-values frame)'() '()))
            (env-loop (cdr env)))))
    (env-loop env))

  (define test-env (list (make-frame '(a s d f) '(1 2 3 4))
                         (make-frame '(g s f k) '(5 6 7 8))))

  (make-unbound! 'd test-env)
  (make-unbound! 's test-env)
  (make-unbound! 'e test-env)
#+END_SRC

~Упражнение 4.14.~
Ева Лу Атор и Хьюго Дум экспериментируют с метациклическим
интерпретатором каждый по отдельности. Ева вводит определение ~map~ и
запускает несколько тестовых программ с его использованием. Они
замечательно работают.
Хьюго, со своей стороны, ввел системную версию ~map~
как примитив метациклического интерпретатора. Когда он пытается его
выполнить, все ломается самым ужасным образом.
Объясните, почему у Хьюго map не работает, а у Евы работает.

Ответ:
Думаю дело в парсинге всего выражения. Иными словами, если
метациклический интерпретатор встретит map Хьюго, map будет воспринят как
примитив.
Значит, eval сразу передаст метациклическому ~apply~ оператор и
аргументы, чтобы ~apply~ вызвал вызвал нижележащий ~apply~ и исполнил
вызов примитива. Возможная проблема в том, что перед передачей аргументов
в apply метациклический eval попытается вычислить аргументы операции,
чтоб передать в процедуру их значения. А аргументы map - это лямбда и
список. Если список eval еще можен корректно вычислить, то как она
вычислит лямбду, то вычисление лямбды может не совпадать у
метациклического и нижележащего интерпретатора. Нам в мане говорилось,
что данные eval и apply достаточно примитивны и совершенно не отражают
всю полноту вычислений и всех нюансов, которые происходят в настоящем
интерпретаторе.

~Упражнение 4.15.~
Если даны одноаргументная процедура p и объект a, то говорят, что p
«останавливается» на a, если выражение (p a) возвращает значение
(а не печатает сообщение об ошибке или выполняется
вечно).
Покажите, что невозможно написать процедуру halts?, которая бы
точно определяла для любой процедуры p и любого объекта a, останавливается ли p на
a. Используйте следующее рассуждение: если бы имелась такая процедура
halts?, можно было бы написать следующую программу:

#+BEGIN_SRC scheme
  (define (run-forever) (run-forever))

  (define (try p)
    (if (halts? p p)
        (run-forever)
        'halted))
#+END_SRC

Теперь рассмотрите выражение (try try) и покажите, что любое возможное
завершение (остановка или вечное выполнение) нарушает требуемое поведение
halts?

Разберем код, представленный выше. Нам сказано, что ~p~ - это
одноаргументная процедура. В процедуре ~try~ мы пытаемся
выявить, останавливается ли процедура ~p~ на переданном ей параметре - той
же процедуре ~p~. Процедура здесь является и данными, и процедурой.

Теперь рассмотрим вызов (try try). При проверке условия ифа, мы вызовем
операцию ~p~ с аргументов  ~p~ - в нашем случае это превратится в вызов
(try try) снова, и так до бесконечности. То есть мы просто навечно
зациклимся внутри ~try~, а до предиката исполнение так и не дойдет. То
есть мы не можем вернуть ~false~, если вычисление не останавливается,
потому что чтоб что-то вернуть, вычисление должно остановиться.

Чтоб построить процедуру ~halts?~, нам бы понадобился многопоточный
интерпретатор, если такой вообще можно сделать. Тогда, предположим, если
один поток интерпретатора долго не отвечает, то другие потоки могут
известить прогаммиста, что вычисление в одном из потоков зациклилось.

~Упражнение 4.16.~
В этом упражнении мы реализуем только что описанный метод обработки
внутренних определений. Мы предполагаем, что интерпретатор поддерживает
let (см. упражнение 4.6).
а. Измените процедуру ~lookup-variable-value~ (раздел 4.1.3) так, чтобы
она, обнаруживая в качестве значения символ *unassigned*, сообщала об ошибке.
б. Напишите процедуру ~scan-out-defines~, которая берет тело процедуры и
возвращает его эквивалент без внутренних определений, выполняя описанное нами
преобразование.
в. Вставьте ~scan-out-defines~ в интерпретатор, либо в ~make-procedure~, либо
в ~procedure-body~. Какое из этих мест лучше? Почему?

Проверено через обычную схему
#+BEGIN_SRC scheme
  ;;преобразование, описанное в мане
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (set! u <e1>)
      (set! v <e2>)
      <e3>))

  ;; необходимые для работы функции
  (define (definition? exp)
    (tagged-list? exp 'define))

  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        #f))

  ;; задание А
  (define (lookup-variable-value var env)
    (define (env-loop env)
      (define (scan vars vals)
        (cond ((null? vars)
               (env-loop (enclosing-environment env)))
              ((eq? var (car vars))
               (if (eq? (car vals) '*unassigned*)
                   (error "Значение не определено" (car vals))
                   (car vals)))
              (else (scan (cdr vars) (cdr vals)))))
      (if (eq? env the-empty-environment)
          (error "Несвязанная переменная" var)
          (let ((frame (first-frame env)))
            (scan (frame-variables frame)
                  (frame-values frame)))))
    (env-loop env))

  (define env (list (make-frame '(a b c d) '(1 2 3 *unassigned*))
                    (make-frame '(h b s f) '(3 9 5 7))))

  (lookup-variable-value 'd env)

  ;;Задание Б

  ;; принимает тело исходной лямбды
  ;; возвращает список, состоящий из трех подсписков: имена, значения имен, остальное тело
  (define (split-names-values-body body-proc names values body)
    (if (null? body-proc)
        (list names values body)
        (let ((exp (car body-proc)))
          (if (definition? exp)
              (split-names-values-body  (cdr body-proc)
                             (append names (list (cadr exp)))
                             (append values (list (caddr exp))) body)
              (split-names-values-body  (cdr body-proc) names values
                                        (append body (list exp)))))))

  ;; создает заготовку для let:
  ;; принимает список имен
  ;; возвращает список списков, где car каждого подсписка - имя, а cdr - символ '*unassigned*
  (define (make-unassigned-let names)
    (map (lambda (name)
           (list name '*unassigned*)) names))

  ;; создает "присваивания" (ничего не присваивается на самом деле, мы просто соединяем
  ;; элементы присваивания (set! имя значение) в спики
  ;; возвращаем список, где все подсписки - это формы готовые выражения для присваивания
  (define (make-sets names values sets)
    (if (null? names)
        sets
        (make-sets (cdr names) (cdr values)
                   (append sets (list (list 'set! (car names) (car values)))))))

  ;; (make-sets (car test) (cadr test) '())

  (define (scan-out-defines proc)
    (let ((names-values-body (split-names-values-body (cddr proc)
                                                      '() '() '())))
      (list 'lambda (cadr proc)
            (append (list 'let (make-unassigned-let (car names-values-body)))
                          (make-sets (car names-values-body)
                                     (cadr names-values-body) '())
                          (caddr names-values-body)))))

  (define test '(lambda (x y z)
                  (define u 4)
                  (define k 5)
                  (+ u k)
                  (define h 6)))

  (scan-out-defines test)

#+END_SRC

Я бы вставила ~scan-out-defines~ непосредственно в интерпретатор, так мы
бы смогли использовать процедуру где угодно.

~Упражнение 4.17~.
Нарисуйте диаграммы окружения, которое находится в силе в момент
выполнения выражения <e3i> из процедуры выше по тексту, и сравните его устройство при
последовательной обработке определений и при описанном выше
преобразовании.
Откуда в преобразованной программе берется дополнительный кадр?
Объясните, почему это различие никогда не отражается на поведении
корректных программ. Придумайте, как заставить интерпретатор реализовать
правило «одновременной» сферы действия для внутренних определений без создания
дополнительного кадра.

#+BEGIN_SRC scheme
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (set! u <e1>)
      (set! v <e2>)
      <e3>))

#+END_SRC

Итак, дополнительный кадр образуется из-за использования формы ~let~,
которая всегда создает свое собственное окружение, поскольку раскрывается
в лямбду. Тело letстановится телом лямбды, объявляемые переменные
становятся параметрами лямбды, а выражения, которые присваивались
переменным, становятся аргументами, которые мы передаем лямбде при ее
вызове.

Справедливости ради надо отметить, что ~define~ тоже создает свое
собственное окружение, просто оно "закрывается" раньше, что <e3> начнет
выполняться, поскольку ~define~ объявляет свою переменную "глобально" для
окружения, в котором находится, поскольку раскрывается в именованную
лямбду. Поэтому к ней можно обратиться даже за пределами ее соственного
окружения, при условии, что ссылка на имя происходит после определения.

Разичия в поведении коректных программ из-за объявления через ~define~ или
через ~let~ нет, поскольку, фактически, все что не ~define~, т.е. не
определение - это тело функции. В нашем случае тело функции заключается в
тело ~let~, внутри которого мы имеем свободный доступ к объявленным
переменным.

Чтоб нам не пришлось создавать дополнительный кадр, нужно, чтоб у нас
остались ~define~, только при объявлении мы сделаем их *unassigned*, а
затем присвоим значение, какое планировали изначально.
Таким образом у нас получится такое преобразование:

#+BEGIN_SRC scheme
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (define u '*unassigned*)
    (define v '*unassigned*)
    (set! u <e1>)
    (set! v <e2>)
      <e3>)

#+END_SRC

~Упражнение 4.18~.
Рассмотрим альтернативную стратегию обработки определений, которая
совершает такое преобразование:

#+BEGIN_SRC scheme
  (lambda <переменные>
    (define u <e1>)
    (define v <e2>)
    <e3>)

  (lambda <переменные>
    (let ((u '*unassigned*)
          (v '*unassigned*))
      (let ((a <e1i>)
            (b <e2>))
        (set! u a)
        (set! v b))
      <e3>))
#+END_SRC

Здесь a и b представляют новые имена переменных, созданные
интерпретатором, которые не встречаются в пользовательской программе.
Рассмотрим процедуру solve из раздела 3.5.4. Будет ли эта процедура
работать, если внутренние определения преобразуются так, как предлага-
ется в этом упражнении? А если так, как в тексте раздела? Объясните.

#+BEGIN_SRC scheme
  (define (solve f y0 dt)
    (define y (integral (delay dy) y0 dt))
    (define dy (stream-map f y))
    y)
#+END_SRC

Итак, solve - это пример цикличского задержанного выражения или промисов
внутри промисов. Чтоб вычислить ~y~ нам нужно знать ~dy~ и
наоборот. Поэтому мы вычисляем оба этих потока по очереди и поэтому
вычисление ~dy~ отложено.
Посмотрим, во что раскроется это выражение согласно тому, как это
предложено в этом упражнении:

#+BEGIN_SRC scheme
  (define solve
    (lambda (f y0 dt)
      (let ((y '*unassigned*)
            (dy '*unassigned*))
        (let ((a (integral (delay dy) y0 dt))
              (b (stream-map f y)))
          (set! y a)
          (set! dy b)) y)))   ;;----------->

  (define solve
    (lambda (f y0 dt)
      ((lambda  (y dy)
         ((lambda (a b)
            (set! y a)
            (set! dy b)) (integral (delay dy) y0 dt)
            (stream-map f y))
         y)
       '*unassigned* '*unassigned*)))

#+END_SRC

Данная трансформация не сработает. До присвоение мы попытаемся вычислить
аргументы ~a~ и ~b~ во внутренней лямбде. С аргументов ~a~ у нас все
получится, поскольку вычисление ~dy~ задержано. Но вот вычисление
аргумента ~b~ не состоится, поскольку выражение ~(stream-map f y)~
использует ~y~, значение которого не определено.

Теперь рассматриваем, что будет, если выражение раскроется, как описано в тексте:
#+BEGIN_SRC scheme
  (define solve
    (lambda (f y0 dt)
      (let ((y '*unassigned*)
            (dy '*unassigned*))
        (set! y (integral (delay dy) y0 dt))
        (set! dy (stream-map f y))
        y))) ;; --------------->

  (define solve
    (lambda (f y0 dt)
      ((lambda (y dy)
        (set! y (integral (delay dy) y0 dt))
        (set! dy (stream-map f y))
        y) '*unassigned* '*unassigned*)))

#+END_SRC

При вычислении этого выражения все сработает. Сначала значение ~y~ и ~dy~
не определено, но затем мы вычисляем выражения одно за другим и вовремя
присваиваем переменным реультаты вычисления выражения.

~Упражнение 4.19.~
Бен Битобор, Лиза П. Хакер и Ева Лу Атор спорят о том, каким должен быть
результат выражения

#+BEGIN_SRC scheme
  (let ((a 1))
    (define (f x)
      (define b (+ a x))
      (define a 5)
      (+ a b))
    (f 10))
#+END_SRC

Бен говорит, что следует действовать согласно последовательному правилу
для ~define~: ~b~ равно 11, затем ~a~ определяется как 5, так что общий
результат равен 16. Лиза возражает, что взаимная рекурсия требует правила
одновременной сферы действия для внутренних определений и нет причин
рассматривать имена процедур отдельно от прочих имен. То есть она
выступает за механизм, реализованный в упражнении 4.16.
При этом ~a~ оказывается не определено в момент, когда определяется ~b~.
Следовательно, по мнению Лизы, процедура должна выдавать ошибку. Ева не согласна с
обоими. Она говорит, что если определения вправду должны считаться
одновременными, то 5 как значение ~a~ должно использоваться при вычислении
~b~. Следовательно, по мнению Евы, ~a~ должно равняться 5, ~b~ должно
быть 15, а общий результат 20.
Какую из этих точек зрения Вы поддерживаете (если у Вас нет своей
четвертой)?
Можете ли Вы придумать способ реализации внутренних определений, который
бы работал так, как предлагает Ева?

Я попробовала запустить данное выражение и столкнулась с ошибкой
"переменная а уже зарезервирована". Это понятно, потому что происходит
внутри окружения ~let~, которая объявляет переменную ~a~ и присваивает ей
значение 1.
Соответственно, мы не можем объявить переменную с таким же именем.
Теперь предположим, что нам это все-таки удалось.
Тогда в этом случае при определении ~b~ мы будем использоват ранее
объявленное значение ~a~ и тогда пойдем по сценарию Бена, особенно если
будем использовать интерпретатор, который описан в этой главе.
В нем если мы встречаем повторное объявление переменной в том же
окружении, то мы просто присваиваем ей новое значение.

Чтоб реализовать вариант Евы, мы можем использовать промисы внутри
промисов. То есть отложить вычисление ~a~ или ~b~ до тех пор, пока они не
понадобятся.

Получится что-то вроде этого:
#+BEGIN_SRC scheme
  (let ((a 1))
    (define (f x)
      (define b (cons-stream x (+ (delay a) x)))
      (define a (cons-stream 5 5))
      (cons-stream x (add-streams a (force b)))
    (f 10)))
#+END_SRC

Это несовершенный вариант (я даже не уверена, что он может сработать),
поскольку первое значение, которое вернет нам поток, не будет правильным,
придеся ждать второе, к тому времени ~b~ будет полность вычислено и мы
сможем корректно посчитать результат.

~Упражнение 4.20.~
Поскольку внутренние определения выглядят последовательными, а на самом
деле параллельны, некоторые предпочитают их вовсе избегать и вместо этого
пользуются особой формой ~letrec~.
Letrec выглядит так же, как ~let~, поэтому неудивительно, что переменные в
нем связываются одновременно и имеют одинаковую для всех сферу действия.
Можно переписать процедуру-пример ~f~ из текста без внутренних
определений, но при этом в точности с тем же
значением, так:

#+BEGIN_SRC scheme
  (define (f x)
    (define (even? n)
      (if (= n 0)
          true
          (odd? (- n 1))))
    (define (odd? n)
      (if (= n 0)
          false
          (even? (- n 1))))
    <остаток тела f>) ;; -------->

  (define (f x)
    (letrec ((even?
              (lambda (n)
                (if (= n 0)
                    true
                    (odd? (- n 1)))))
             (odd?
              (lambda (n)
                (if (= n 0)
                    false
                    (even? (- n 1))))))
      <остаток тела f>))
#+END_SRC

Letrec является вариантом let, в котором выражения <выр i>, устанавливающие
начальные значения для переменных <пер i>, вычисляются в окружении,
которое включает все связывания letrec.
Это делает возможным рекурсию между связываниями, к примеру, взаимную
рекурсию even? и odd? в последнем примере, или вычисление факториала 10
через

#+BEGIN_SRC scheme
  (letrec ((fact
            (lambda (n)
              (if (= n 1)
                  1
                  (* n (fact (- n 1)))))))
    (fact 10))
#+END_SRC

а. Реализуйте ~letrec~ как производное выражение, переводя выражение letrec
в выражение ~let~, как показано в тексте раздела или в упражнении 4.18. То есть
переменные ~letrec~ должны создаваться в ~let~, а затем получать значение через set!.

б. Хьюго Дум совсем запутался во всех этих внутренних определениях. Ему
кажется, что если кому-то не нравятся ~define~ внутри процедуры, то пусть
пользуются обычным ~let~.
Покажите, что́ в его рассуждениях неверно. Нарисуйте диаграмму, показывающую
окружение, в котором выполняется <остаток тела f> во время вычисления
выражения (f 5), если ~f~ определена как в этом упражнении.
Нарисуйте диаграмму окружений для того же вычисления, но только с ~let~
на месте ~letrec~ в определении ~f~.

Проверено через обычную схему.
Задание а:
#+BEGIN_SRC scheme
  ;;получаем список имен и список значений, с ними связанных
  (define (split-names-values letrec-binds names values)
    (if (null? letrec-binds)
        (list names values)
        (let ((cur-bind (car letrec-binds)))
          (split-names-values (cdr letrec-binds)
                              (append names (list (car cur-bind)))
                              (append values (cdr cur-bind))))))

  (split-names-values (cadr test) '() '())

  ;; создаем связывания имен с *unassigned*
  (define (make-unassigned-let names)
    (map (lambda (name)
           (list name '*unassigned*)) names))

  ;;присваиваем именам правильные значения
  (define (make-sets names values sets)
    (if (null? names)
        sets
        (make-sets (cdr names) (cdr values)
                   (append sets (list (list 'set! (car names) (car values)))))))


  ;; совершаем трансформацию
  (define (letrec->let expr)
    (let ((names-and-values (split-names-values (cadr expr) '() '())))
      (append (list 'let (make-unassigned-let (car names-and-values)))
              (make-sets (car names-and-values)
                         (cadr names-and-values) '())
              (cddr expr))))


  (define test '(letrec ((even?
                          (lambda (n)
                            (if (= n 0)
                                true
                                (odd? (- n 1)))))
                         (odd?
                          (lambda (n)
                            (if (= n 0)
                                false
                                (even? (- n 1))))))
                  '()))

  (letrec->let test)
#+END_SRC

Задание б:
Проблема в окружениях, которые создают ~let~ и ~define~. Если мы везде
используем ~let~,то все операции, которые выполняются с переменными,
объявленными через let, должны выполняться внутри тела самого ~let~. Если
мы определяем пременную через ~define~, то можем ссылаться на нее и за
пределами ее окружения - если define раскрывается в именованную лямбду.

Теперь рассмотрим наш случай: если let реализован как обычно, не как в
упр. 4.18, то связывание происходит последовательно, а не одновременно,
как в ~letrec~,поэтому в ~let~ не получится реализовать взаимную
рекурсию.

~Упражнение 4.21.~
Как ни удивительно, интуитивная догадка Хьюго (в упражнении 4.20)
оказывается верной. Действительно, можно строить рекурсивные процедуры
без использования ~letrec~ (и даже без define), только способ это сделать
намного тоньше, чем казалось Хьюго.
Следующее выражение вычисляет факториал 10 с помощью рекурсивной процедуры:

#+BEGIN_SRC scheme
  ((lambda (n)
     ((lambda (fact)
        (fact fact n))
      (lambda (ft k)
        (if (= k 1)
            1
            (* k (ft ft (- k 1)))))))
   10)
#+END_SRC

Задание а.
Проверьте, что это выражение на самом деле считает факториалы
(вычисляя его). Постройте аналогичное выражение для вычисления чисел
Фибоначчи.
Итак, выражение действительно вычисляет факториал. Вариант для Фибоначчи:

#+BEGIN_SRC scheme
  ;;исходный вариант
  (define (fib n)
    (define (fib-iter a b count )
      (if (= count 0)
          b
          (fib-iter (+ a b) a (- count 1))))
    (fib-iter 1 0 n))

  ;; переработанный
  ((lambda (n a b)
     ((lambda (fib-iter)
        (fib-iter fib-iter a b n))
      (lambda (fib-it a b count)
        (if (= count 0)
            b
            (fib-it fib-it (+ a b) a (- count 1)))))
     )
   4 1 0 )
#+END_SRC

Задаие б:
Рассмотрим следующую процедуру, включающую взаимно рекурсивные внутренние
определения:

#+BEGIN_SRC scheme
  (define (f x)
    (define (even? n)
      (if (= n 0)
          true
          (odd? (- n 1))))
    (define (odd? n)
      (if (= n 0)
          false
          (even? (- n 1))))
    (even? x))
#+END_SRC

Восстановите пропуски в выражениях:

#+BEGIN_SRC scheme
  (define (f x)
    ((lambda (even? odd?)
       (even? even? odd? x))
     (lambda (ev? od? n)
       (if (= n 0) true (od? ev? od? (- n 1))))
     (lambda (ev? od? n)
       (if (= n 0) false (ev? ev? od? (- n 1))))))

#+END_SRC

~Упражнение 4.22.~
Расширьте интерпретатор из этого раздела так, чтобы он поддерживал
let. (См. упражнение 4.6.)

Упражнение 4.6 гласит:
выражения let производны, поскольку раскрываются в лямбду.
Напишите синтаксическое преобразование ~let->combination~, которое сводит
вычисление let-выражений к вычислению комбинаций указанного вида, и добавьте
соответствующую ветку для обработки let к eval.

Значит, сейчас нам надо сейчас вставить уже имеющееся преобразование ~let~
в новый интерпретатор.
Реализация преобразования let из упражнение 4.6:

#+BEGIN_SRC scheme
  (define (make-lambda parameters body)
    (cons 'lambda (cons parameters body)))

  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))

  (let ((a 1)
        (b 2))
    (+ a b))
#+END_SRC
Добавление его в интерпретатор:

#+BEGIN_SRC scheme
  (define (eval exp env)
    ((analyze exp) env))

  (define (analyze exp)
  (cond ((self-evaluating? exp)
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((let? exp) (analyze (let->combination exp)))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else
         (error "Неизвестный тип выражения -- ANALYZE" exp))))
#+END_SRC

~Упражнение 4.23~.
Лиза П. Хакер не понимает, зачем делать ~analyze-sequence~ такой
сложной. Все остальные процедуры анализа — простые трансформации
соответствующих вычисляющих процедур (или ветвей eval) из раздела 4.1.1.
Лиза ожидала, что ~analyze-sequence~ будет выглядеть так:

#+BEGIN_SRC scheme
  (define (analyze-sequence exps)
    (define (execute-sequence procs env)
      (cond ((null? (cdr procs)) ((car procs) env))
            (else ((car procs) env)
                  (execute-sequence (cdr procs) env))))
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (lambda (env) (execute-sequence procs env))))
#+END_SRC

Ева Лу Атор объясняет Лизе, что версия в тексте проделывает больше работы
по вычислению последовательности во время анализа. В Лизиной исполнительной процедуре
вызовы частичных исполнительных процедур, вместо того, чтобы быть встроенными,
перебираются в цикле. В результате, хотя отдельные выражения в
последовательности оказываются проанализированы, сама последовательность
анализируется во время выполнения.
Сравните две версии ~analyze-sequence~. Рассмотрите, например, обычный
случай (типичный для тел процедур), когда в последовательности только одно
выражение. Какую работу будет делать исполнительная процедура,
предложенная Лизой?
А процедура из текста раздела? Как соотносятся эти две процедуры в случае
последовательности из двух выражений?

Исходный вид ~analyze-sequence~:
#+BEGIN_SRC scheme
  ;;анализирует блоки выражений типа begin или тела процедуры
  (define (analyze-sequence exps)
    (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
    ;; получаем все исполнительные проедуры для выражения
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (loop (car procs) (cdr procs))))
#+END_SRC

Исходный вариант ~analyze-sequence~ сначала применит ~analyse~ к
выражению (выражениям), таким образом мы получим исполнительную процедуру
выражения. Затем вызовется ~loop~, и поскольку процедура одна, мы сразу
ее вернем. Если ~analyze-sequence~ на вход получит 2 выражения, то мы все
так же их проанализируем, затем ~loop~ соберет их в общую исполнительную
процедуру и так вернет.
Теперь посмотрим на Лизин вариант.
Мы возвращаем лямбду, внутри которой вызов ~execute-sequence~. Таким
образом у нас преобразование не закончено:
только при вызове этой лямбды мы начнем анализировать выражения дальше. К
тому же это еще и каждый раз делать придется.

~Упражнение 4.25.~
Предположим, что мы (в обычной Scheme с аппликативным порядком
вычислений) определяем ~unless~ как показано выше, а затем определяем
~factorial~ через ~unless~:

#+BEGIN_SRC scheme
  (define (unless condition usual-value exceptional-value)
    (if condition exceptional-value usual-value))

  (define (factorial n)
    (unless (= n 1)
            (* n (factorial (- n 1)))
            1))
#+END_SRC

Что произойдет, если мы попытаемся вычислить (factorial 5)? Будут ли наши
определения работать в языке с нормальным порядком вычислений?

Итак, в апликативном порядке вычислений аргументы процедуры вычисляются
до ее использования. Это значит, что все аргументы ~unless~ будут
вычислены до ее вызова, в том числе и  ~(* n (factorial (- n 1)))~,
попытавшись вычислить эото аргумент ~unless~, мы входим в бесконечную
рекурсию. Почему? Пока ~unless~ не вычислит все свои аргументы, она не
запуститcя, а до вычисления своего третьего аргумента она дойти никак не
может: вычисляя второй аргумент мы "проваливаемся" в вызов факториала,
затем снова пытаемся вычислить аргументы ~unless~ и так до тех пор, пока
стек не кончится.

В нормальном порядке вычислений этого не произошло бы, поскольку там
аргументы вычисляются только по требованию, когда они нужны. ~unless~
спокойно бы запустилась, мы бы проверили условие и в зависимости от того,
как оно сработало, мы бы вычислили остальные аргументы. Бесконечной
рекурссии бы не было.

~Упражнение 4.26.~
Бен Битобор и Лиза П. Хакер расходятся во мнениях о важности ленивых
вычислений для реализации конструкций вроде ~unless~.  Бен указывает, что
при аппликативном порядке ~unless~ можно реализовать как особую форму.
Лиза отвечает, что в таком случае ~unless~ будет просто синтаксисом, а не
процедурой, которую можно использовать в сочетании с процедурами высших
порядков. Проясните детали в обеих позициях. Покажите, как реализовать
~unless~ в виде производного выражения (вроде cond или let), и приведите
пример ситуации, когда имеет смысл, чтобы ~unless~ была процедурой,
а не особой формой.

Трансформация ~unless~ в соответствующее ему условное выражение.
#+BEGIN_SRC scheme
  (define (unless->if exp)
    (let ((condition (cadr exp))
          (usual-value (caddr exp))
          (exceptional-value (cadddr exp)))
      (list 'if condition exceptional-value usual-value)))


  (unless->if '(unless (= n 1)
                      (* n (factorial (- n 1)))
                      1))
#+END_SRC

Если использовать ~unless~ как особую форму при аппликативном порядке,
как предлагает Бен, то все будет работать правильно, поскольку в ифе
будут вычисляться только те ветки, которые будут соответствовать условию,
а не все подряд. С другой стороны, ~unless~  просто станет синтаксическим
сахаром для ифа.

Может возникнуть ситуация, когда нам не нужно будет вычислять аргументы
~unless~, то есть ~unless~ должна стать нестрогой процедурой по своим
аргументам. Например, если ~unless~ понадобится для работы над
структурами данных, хотя я не очень представляю, зачем нам может быть
нужна ~unless~ в этом случае.

~Упражнение 4.27.~
Допустим, мы вводим в ленивый интерпретатор следующее выражение:

#+BEGIN_SRC scheme
  (define count 0)

  (define (id x)
    (set! count (+ count 1))
    x)
#+END_SRC

Вставьте пропущенные значения в данной ниже последовательности действий и
объясните свои ответы:

#+BEGIN_SRC scheme
  (define w (id (id 10)))

  ;;; Ввод L-Eval:
  count
  ;;; Значение L-Eval:
  <вывод>
  ;;; Ввод L-Eval:
  w
  ;;; Значение L-Eval:
  <вывод>
  ;;; Ввод L-Eval:
  count
  ;;; Значение L-Eval:
  <вывод>

#+END_SRC

Рассмотрим, что произойдет при вводе ~(define w (id (id 10)))~.
Вызов  ~(id 10)~, переданный как аргумент, вычислен не будет, станет
санком. Так что при вызове ~id~ с таким аргументом, мы его же и вернем,
не вычисляя.

Так что:
#+BEGIN_SRC scheme
  (define w (id (id 10)))

  ;;Ввод:
  count
  ;; Вывод, поскольку санк вычислен не будет, присовение count стработает только 1 раз
  1

  ;; Ввод:
  w
  ;; Вывод, поскольку при вызове w санк, который она собой представляет, вычислится
  10

  ;;; Ввод:
  count
  ;; Вывод, поскольку раз вычислился и санк, то присваивание внутри id сработало второй раз.
  2

#+END_SRC

~Упражнение 4.28.~
~Eval~, передавая оператор в ~apply~, вычисляет его не при помощи ~eval~, а
через ~actual-value~, чтобы вынудить. Приведите пример, который показывает, что такое
вынуждение необходимо.

Оператор мы вычисляем сразу, чтоб понять, составная это процедура или
примитив. При этом нигде не сказано, что оператор не может быть санком. А
попытка применить аргументы к невычисленному санку обернется ошибкой.

Эта ситуация может возникнуть, есть оператор - это евычесленный аргумент
какой-то процедуры, который аон вернула.

Например:
#+BEGIN_SRC scheme
  (cons (lambda (x)
          (* x x))
        (lambda (y)
          (+ y y )) ......)
#+END_SRC

Если cons у нас нестрогая и интерпретатор у нас ленивый, то cons вообще не
нужно вычислять свои аргументы, чтоб составить из них список. Тем более,
что с точки зрения интерпретатора любое выражение - это список. То есть
для cons вообще нет никакой разницы, что представляет собой список на
самом деле: вызов процедуры, список чисел и т.д.

Теперь представляем себе, что полученный список процедур мы будем
применять к разным аргументам. А по факту у нас не список процедур, а
список санков и вычисление санка нужно вынудить. А еще при вычислении
санка мы можем получить новый санк, так что нужно будет вынудить все
санки до того, как мы получим оператор, который можно применить к
аргументам.

~Упражнение 4.29~.
Придумайте пример программы, которая, по Вашему мнению, будет работать
намного медленнее без мемоизации, чем с мемоизацией.

Рассмотрим, помимо
этого, следующую последовательность действий, в которой процедура ~id~
определена как в упражнении 4.27, а счетчик ~count~ начинает с 0.
Укажите, как будет выглядеть вывод в случае с мемоизирующим
интерпретатором и с немемоизирующим.

#+BEGIN_SRC scheme
  ;;меморизирующий
  (define (square x)
    (* x x))

  ;; Ввод L-Eval:
  (square (id 10))
  ;;; Значение L-Eval:
  100
  ;;; Ввод L-Eval:
  count
  ;;; Значение L-Eval:
  1 ;; потому что санк вычисляет один раз, соответственно, присваивание срабатывает 1 раз

#+END_SRC

При немеморизирующих санках вычисление ~(id 10)~, переданного как
аргумент ~square~, произойдет дважды, поэтому ~count~ будет = 2.

А вообще меморизация окажется дико полезна в циклах, где мы вычисляем
одно и то же с незначительными вариациями. К примеру:

#+BEGIN_SRC scheme
  (define (square x)
    (* x x))

  (define (test n arg)
    (if (< n 0)
        'ok
        (begin
        (display (square arg))
        (newline)
        (test (- n 1) arg))))

  (test 10 (id 10))
#+END_SRC

Без меморизации ~(id 10)~ будет вычислено 20 раз вместо одного. И это у
цикла только 10 итераций и процедура ~id~ сравнительно простая.

~Упражнение 4.30~
Пабло Э. Фект, бывший программист на языке C, беспокоится, что ленивый
интерпретатор не вынуждает выражения в последовательности, и оттого некоторые побочные
эффекты могут никогда не произойти. Поскольку ни у одного выражения
в последовательности, помимо конечного, значение не используется
(выражение стоит там только ради своего эффекта, например, чтобы
присвоить значение переменной или что-нибудь напечатать), у значения
такого выражения не может впоследствии быть применения, для которого его потребуется
вынудить (например, в качестве аргумента элементарной процедуры). Поэтому
П.Э. Фект считает, что при выполнении последовательности нужно все
выражения, кроме последнего, вынуждать. Он предлагает изменить
~eval-sequence~ из раздела 4.1.1 так, чтобы она вместо eval использовала actual-value:

#+BEGIN_SRC scheme
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (actual-value (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))
#+END_SRC

а. Бен Битобор считает, что Пабло неправ. Он показывает ему процедуру
for-each из упражнения 2.23 — важный пример последовательности с
побочными эффектами:

#+BEGIN_SRC scheme
  (define (for-each proc items)
    (if (null? items)
        'done
         (begin (proc (car items))
                (for-each proc (cdr items)))))
#+END_SRC
Он утверждает, что интерпретатор из текста (с исходным eval-sequence)
правильно работает с этой процедурой:

#+BEGIN_SRC scheme
  (for-each (lambda (x) (newline) (display x))
            (list 57 321 88))

#+END_SRC

Объясните, почему Бен прав насчет поведения for-each.
Итак, побочные эффекты - это любое измениене окружения, объекта или файла
из-за вызова процедуры. Например, присваивание глобальной переменной
какое-то значение внутри процедуры - это побочный эффект процедуры.

Исходный вид ~eval-sequaence~:
#+BEGIN_SRC scheme
  (define (eval-sequence exps env)
    (cond ((last-exp? exps) (eval (first-exp exps) env))
          (else (eval (first-exp exps) env)
                (eval-sequence (rest-exps exps) env))))
#+END_SRC

Бен прав, потому что ~display~ внутри лямбды является примитивной процедурой,
следовательно, ее аргументы будут вычислены до вызова. В ленивом
интерпретаторе примитивы - строгие процедуры.

б. Пабло соглашается с Беном по поводу примера с for-each, но говорит,
что, предлагая изменить eval-sequence, он имел в виду другой тип
программ. Он определяет в ленивом интерпретаторе следующие две процедуры:

#+BEGIN_SRC scheme
  (define (p1 x)
    (set! x (cons x '(2)))
    x)

  (define (p2 x)
    (define (p e)
      e
      x)
    (p (set! x (cons x '(2)))))
#+END_SRC

Какие значения вернут (p1 1) и (p2 1) с исходной eval-sequence? Каковы
будут значения с изменением, которое предлагает Пабло?

C исходной ~eval-sequence~:
~(p1 1)~ вернет (1 2)
~(p2 1)~ вернет 1. Процедура ~p~ принимает аргумент ~e~, мы ей в
качестве аргумента передаем выражение ~(set! x (cons x '(2)))~, которое
является санком, поскольку интерпретатор ленивый, и  вычисляется не
сразу, а только внутри процедуры ~p~, когда мы возвращаем ~e~. Только вот
~eval~ санки вычислять не умеет, соответственно, присваивание не
сработает И ЗНАЧЕНИЕ ~x~ останется прежним.

С версией Пабло:
~(p1 1)~ вернет (1 2)
~(p2 1)~ вернет (1 2).
Внутри ~eval-sequence~ верссии Пабло вызывается
~actual-value~, которая вызывает процедуру ~force-it~ - она вынуждает
санк. Соответственно присваивание будет вычислено.

в. в. Пабло указывает также, что изменение eval-sequence, которое он
предлагает, не влияет на поведение примера из части a. Объясните, почему
это так.

Потому что внутри лямбды у нас используются примитивы, следовательно, их
аргументы в любом случае были бы вычислены. Теперь мы просто вычисляем
их, потому что они санки, а не потому что они аргументы примитивов.

г. Как, по-Вашему, нужно работать с последовательностями в ленивом
интерпретаторе? Что Вам нравится больше: подход Пабло, подход,
приведенный в тексте, или что-нибудь третье?

Подход пабло хорош, потому что используя ленивый интерпретатор, мы будем
постоянно натыкаться на санки и в последовательностях тоже, так что их
нужно вынуждать, чтоб они вычислились.

~Упражнение 4.31. разобраться~
Подход, принятый в этом разделе, нехорош тем, что вносит изменение в
Scheme, не сохраняя ее семантику. Было бы приятнее реализовать ленивые вычисления как
совместимое расширение (upward-compatible extension), то есть так, чтобы
обычные программы на Scheme работали как прежде.
Например, определение

#+BEGIN_SRC scheme
  (define (f a (b lazy) c (d lazy-memo))
    ...)
#+END_SRC

делало бы f процедурой от четырех аргументов, причем первый и третий
вычисляются при вызове процедуры, второй задерживается, а четвертый
задерживается и мемоизируется.
Таким образом, обыкновенные определения процедур будут задавать такое же
поведение, как в обычной Scheme, а добавление декларации ~lazy-memo~ к
каждому параметру каждой составной процедуры приведет к поведению, как у
ленивого интерпретатора, описанного в этом разделе. Разработайте и реализуйте
изменения, с помощью которых можно получить такое расширение Scheme. Вам
придется реализовать новые синтаксические процедуры для нового синтаксиса
~define~.
Кроме того, надо будет добиться, чтобы eval и apply определяли,
когда надо задерживать аргументы, и соответствующим образом задерживали и
вынуждали их. Наконец, придется обеспечить,чтобы вынуждение было с
мемоизацией или без оной, смотря по обстоятельствам.

Итак, если раньше мы отдельано реализовывали аппликативный порядок
вычислений и отдельно нормальный, то теперь нас просят реализовать
гибрид.

Главный финт - это вычислить сразу все аргументы, кроме тех, что
отложены. А те, что отложены, вычислить только перед их непосредственным
применением.
Значит, мы вычислим с помощью ~eval~ все, что не задержано и передадим
процедуру с аргументами, среди которых могут оказаться санки, в
~apply~. А apply перед применением процедуры к аргументам должна пройтись
по аргументам и вынудить те, что являются санками и только после этого
исполнить процедуру.

К тому же, у нас санки могут быть меморизированные, а могут быть и нет.
Процедура вынуждения для не меморизированного санка:

#+BEGIN_SRC scheme
  (define (force-it-not-memo obj)
    (if (thunk? obj)
        (actual-value (thunk-exp obj) (thunk-env obj))
        obj))
#+END_SRC

Механизм вынуждения санка с меморизацией:

#+BEGIN_SRC scheme
  (define (evaluated-thunk? obj)
    (tagged-list? obj 'evaluated-thunk))

  (define (thunk-value evaluated-thunk) (cadr evaluated-thunk))

  (define (force-it-memo obj)
    (cond ((thunk? obj)
           (let ((result (actual-value
                          (thunk-exp obj)
                          (thunk-env obj))))
             (set-car! obj 'evaluated-thunk)
             (set-car! (cdr obj) result)
                                          ; заменить exp на его значение
             (set-cdr! (cdr obj) '()) ; забыть ненужное env
             result))
          ((evaluated-thunk? obj)
           (thunk-value obj))
          (else obj)))
#+END_SRC

В мане обе процедуры вынуждения имеют название force-it, но поскольку
нужны нам обе, то воизбежание переопределения назовем их по-разному и
будем вызывать каждую в зависимости от ситуации.

Создадим предикаты и процедуры, который будут превращать аргументы в
санки того или иногт вида.

#+BEGIN_SRC scheme
  (define (tagged-list? exp tag)
    (if (pair? exp)
        (eq? (car exp) tag)
        false))

  ;; создает санк с меморизацией или без, в зависимости от аргумта tag
  (define (delay-it exp env tag)
    (list tag exp env))

  ;;проверяет, является ли санк меморизированным
  (define (memo-thunk? obj)
    (tagged-list? obj 'lazy-memo))

  ;; проверяет, является ли санк не меморизированным
  (define (not-memo-thunk? obj)
    (tagged-list? obj 'lazy))

  ;; задерживает аргумент, если пользователь хочет его задержать и возвращает как есть,
  ;; если пользователь задерживать аргумент не планирует
  (define (delay-arg? arg env)
    (cond ((not (pair? arg))
           arg)
           ((memo-thunk? (last-pair arg))
            (delay-it exp env 'lazy-memo))
           ((not-memo-thunk? (last-pair arg))
            (delay-it exp env 'lazy))
          (else arg)))

  ;; тесты
  (delay-arg? '((lambda (x)
                  (+ x x)) lazy) '(some-env))

  (delay-arg? '(lambda (x)
                 (+ x x)) '(some-env))

  (delay-arg? 1 '(some-env))
#+END_SRC

~delay-arg~ устроена таким образом, что если последняя пара переданного
аргумента - это символ lazt или lazy-memo, мы считаем, что пользователь
хочет задержать данный аргумент. В остальном случае мы возвращаем
аргумент в том виде, в котором его получили.

Данная процедура не рассматривает 2 аспекта:
- символами lazy и lazy-memo могут быть названы переменные (ну,
  вдруг). Надо бы проверять окружение на наличие этих символов, чтоб
  обедиться, что игде нет таких переменных, и если есть, выдывать
  ошибку.
- мы не учитываем, что пользователь может передать какой-то другой тэг
  для аргумента или написать опечататься.

Но поскольку у нас примитивная модель интерпретатора думаю, эти проблемы
можно опустить, и представить, что наши юзеры всегда точно знают, что
делают.

Теперь нам нужно встроить механизм упаковки аргументов в санки (если
этого хочет пользователь) в ~eval~.

Для этого мы изменим процедуру ~list-of-values~, которая собирает все
аргументы вызова процедуры в список перед тем, как будет вызван
apply. Мы не просто объединим все аргументы в список, а проверим, не
хочет ли пользователь задержать какие-то из них. И если да, то мы сначала
упакуем данные аргументы санки и только потом вклчим их в общий список
аргументов.

Пишем определение дефайна.
eval получает на вход определение. Срабатывает ветка ~definition?~ в
cond, вызывается ~eval-definition~ , которая должна вычислить определение:

#+BEGIN_SRC scheme
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)
#+END_SRC

Мы берем имя. полученное из переданного выражения, и вычисляем значение
выражения и упаковываем все это вместе с окружением в новую
переменную. Если мы определяем процедуру,то имени присваивается лямбда с
указанными в определении аргументами.

#+BEGIN_SRC scheme
  (define (definition-value exp)
    (if (symbol? (cadr exp))
        (caddr exp)
        (make-lambda (cdadr exp)
                     (cddr exp))))
#+END_SRC

То есть определение раскроется так:

#+BEGIN_SRC scheme
  (define (f a (b lazy) c (d lazy-memo))
    ...)

  (define f
    (lambda (a (b lazy) c (d lazy-memo))
      <тело>))


  (define (f a (b lazy) c (d lazy-memo))
    ...)

  (define f
    (lambda (a b  c d))
      <тело>))
#+END_SRC

 Теперь надо понять, устраивает нас такое раскрытие или нет. По идее,
 должно быть как-то так:

#+BEGIN_SRC scheme
  (define (f a (b lazy) c (d lazy-memo))
    ...)

  (define f
    (lambda (a b c d))
      <тело>)

  ;; не сработает, потому что b и d сначала вычислятся, только потом вызовется лямбда,
  ;; и только после этого они станут санками. А если один из них бесконечный поток данных?
  ;; зациклимся до конца стека
  (define f
    (lambda (a b c d))
    (b lazy)
    (d lazy-memo)
    <тело>)

#+END_SRC

И при этом где-то надо хранить информацию, что перед вызовом лямбды
аргументы b и dнадо задержать указанными способами и передать в лямбду уже санками.



#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (eval (operator exp) env)
                  (list-of-values (operands exp) env)))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define (apply procedure arguments)
    (cond ((primitive-procedure? procedure)
           (apply-primitive-procedure procedure arguments))
          ((compound-procedure? procedure)
           (eval-sequence
            (procedure-body procedure)
            (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
          (else
           (error
            "Неизвестный тип процедуры -- APPLY" procedure))))
#+END_SRC

Разберемся с изначальным синтаксисом ~define~. Он у нас различный, в зависимости от
того, объявляем мы процедуру или переменную.
Синтаксис для объявления переменной:
Обяъвление представляет собой список, который наинчается с define. Затем
идет символ, обозначающий имя переменной, затем выраение или число,
значение которых станет значеним переменной.
Синтексис для процедуры:
Тоже список, начинается с define. Затем идет подсписок, где первый
символ - имя процедуры, а остальные элементы - аргументы. Следующий
подсписок - это тело объявляемой процедуры.

Значит, мы модем определить, что если за символом define следует список -
мы объявляем процедуру. А иначе - переменную. В обоих случаях нам надо
будет определить,

~Упражнение 4.32.~
Приведите несколько примеров, которые показывают разницу между потоками
из главы 3.5.4 и «более ленивыми» списками, описанными в этом разделе. Как можно
воспользоваться этой дополнительной ленивостью?

Итак, у ранее описанных ленивых потоков задерживался только ~cdr~. Теперь
у них задерживает и ~car~, и ~cdr~, более того, то, что мы "вынудим"
какой-то элемент потока, совершенно не значит, что его значение
вычислится. Оно может быть обернуто в санк и будет вычисляться только
когда в нем возникнет прямая необходимость.

У нас было упражнение 3.80, в котором требовалось построить/симулировать
работу RLC-цепи. Так выглядело опрееление процедуры с потоками из главы
3:

#+BEGIN_SRC scheme
  (define (RLC R L C dt)
    (lambda (vC0 iL0)
      (define Li (integral (delay diL) iL0 dt))
      (define vC (integral (delay dvC) vC0 dt))
      (define dvC (scale-stream Li (exact->inexact (/ -1 C))))
      (define diL (add-streams (scale-stream Li (exact->inexact (/  (/ R -1) L)))
                               (scale-stream vC (exact->inexact (/ 1 L)))))
      (cons Li vC)
      ))
#+END_SRC

 А вот так будет выглядеть сейчас:

#+BEGIN_SRC scheme
  (define (RLC R L C dt)
    (lambda (vC0 iL0)
      (define Li (integral diL iL0 dt))
      (define vC (integral dvC vC0 dt))
      (define dvC (scale-stream Li (exact->inexact (/ -1 C))))
      (define diL (add-streams (scale-stream Li (exact->inexact (/  (/ R -1) L)))
                               (scale-stream vC (exact->inexact (/ 1 L)))))
      (cons Li vC)
      ))
#+END_SRC

Похожие изменения будут в упражнении 3.79.

Ранее нам было показано, что деление на процедуры и данные может быть
достаточно условным, и что процедуры можно представлять как
данные. Предположим, что у нас поток состоит из вызовов процедур. Внутри
этих процедур у нас динамически выделяется память, а так же предположим,
что они обладают побочными эффектами, например, меняют окружение из-за
присваивания. Если мы пользуемся потоками, показаными в главе три, то при
вычислении ~car~ потока мы уже не можем отсрочить выполнение вызова
процедуры, хотя, предположим, нам нужно само выражение, а не результат
его вызова. Тогда придется его дополнительно задерживать или же оформлять
вызовы процедур в виде заковчнных списков.

~Упражнение 4.33.~
Бен Битобор проверяет вышеописанную реализацию при помощи выражения
~(car '(a b c))~

К его большому удивлению, в ответ выдается ошибка. После некоторого
размышления он понимает, что «списки». которые получаются при чтении
кавычек, отличаются от списков, управляемых новыми определениями cons,
car и cdr.
Измените работу интерпретатора с закавыченными выражениями так, чтобы при
вводе списковых выражений в цикле управления получались настоящие
ленивые списки.

Новые определения cons, car и cdr:
#+BEGIN_SRC scheme
  (define (cons x y)
    (lambda (m) (m x y)))

  (define (car z)
    (z (lambda (p q) p)))

  ;;((lambda (m) (m x y)) (lambda (p q) p))

  (define (cdr z)
    (z (lambda (p q) q)))

  ;; эксперимент
  (define f (cons 1 2))
  (car f)
  (cdr f)

  (define (list-ref items n)
    (if (= n 0)
        (car items)
        (list-ref (cdr items) (- n 1))))

  (define (map proc items)
    (if (null? items)
        '()
         (cons (proc (car items))
               (map proc (cdr items)))))

  (define (scale-list items factor)
    (map (lambda (x) (* x factor))
         items))

  (define (add-lists list1 list2)
    (cond ((null? list1) list2)
          ((null? list2) list1)
          (else (cons (+ (car list1) (car list2))
                      (add-lists (cdr list1) (cdr list2))))))

  (define ones (cons 1 ones))

  (define integers (cons 1 (add-lists ones integers)))
#+END_SRC

Итак, проблема у Бена возникает потому, что новая версия cons возвращает
не список: она возвращает лямбду, которая принимает процедуру ~m~. И вот
уже в зависимости от процедуры мы увидим тот или иной результат. Поэтому
новый ~car~ на месте заковыченного списка ожидает увидеть на самом деле
лямбду, соответственно, все ломается.

Итак, при встрече заковыченного выражения в ~eval~ срабатывает ветка
~quoted?~ и вызывается вот эта процедура:

#+BEGIN_SRC scheme
  (define (text-of-quotation exp) (cadr exp))
#+END_SRC

Как мы видим, она просто возвращает выражение без ковычки. А нам нужно,
чтоб вызывался новый cons, да еще и неоднократно, если в выражении больше
двух элементов.

Немножно изменим eval так, чтоб при вызове text-of-quatation  в нее
передавалось и окружение. Это нужно, чтоб обратиться к eval если
переданное закавыченное выражение состоит из подпар (ну, вдруг).

Сначала мы составляем выражение, которое представляет собой вызов
вложенных друг в друга cons и только затем вычисляем его.

Есть очень важное дополнение: мы переопределили car, cons и cdr внутри
ленивого интерпретатора, т.е. внутри driver-loop. То есть в встроенном,
изначальном интерпретаторе у нас cons, car и cdr
стандартные. Соответственно, мы можем их использовать, чтоб проходиться
по списку, пока мы строим выражение, которое, будучи пропущенное через
eval и apply внутри ленивого интерпретатора, построит новое представление
списка. То есть у нас параллельно в двух интерпретаторах существуют два
разных представления cons, car и cdr и не пересекаются они потому, что у
каждого интерпретатора свое базовое окружение.

#+BEGIN_SRC scheme
  (define (eval exp env)
    (cond ((self-evaluating? exp) exp)
          ((variable? exp) (lookup-variable-value exp env))
          ((quoted? exp) (text-of-quotation exp env))
          ((assignment? exp) (eval-assignment exp env))
          ((definition? exp) (eval-definition exp env))
          ((if? exp) (eval-if exp env))
          ((lambda? exp)
           (make-procedure (lambda-parameters exp)
                           (lambda-body exp)
                           env))
          ((begin? exp)
           (eval-sequence (begin-actions exp) env))
          ((cond? exp) (eval (cond->if exp) env))
          ((application? exp)
           (apply (actual-value (operator exp) env)
                  (operands exp)
                  env))
          (else
           (error "Неизвестный тип выражения -- EVAL" exp))))

  (define (text-of-quotation exp env)
    (let ((result (cadr exp)))
      (if (pair? result)
          (eval (make-lst result) env)
          result)))

  (define (make-lst s)
    (if (null? s)
        '()
        (list 'cons
              (list 'quote (car s))
                          (make-lst (cdr s)))))
#+END_SRC

~Упражнение 4.34.~
Измените управляющий цикл интерпретатора так, чтобы ленивые пары и списки
печатались каким-либо разумным образом. (Как Вы собираетесь работать с бесконечными
списками)? Вероятно, понадобится также изменить представление ленивых
пар, чтобы при печати интерпретатор их распознавал и печатал особым образом.

Итак, нам нужно научить цикл печатать ленивые пары (пары, в которых cdr -
промис), списки (которые сейчас фактически являются вложенными лямбдами)
и бесконечные списки.

Основная проблема состоит в том, что с точки зрения driver-loop список -
это такая же процедура (лямбда), как и другие процедуры. Соответственно,
надо как-то указать, что вот эта процедура на самом деле список, а вот
эта - не список.


В мане нам сказано, что благодаря ленивому вычислению списки и
потоки-данных, которые мы проходили в главе 3, теперь одно и то же. И
благодаря переопределенным cons, car и cdr мы можем больше не делать
между ними разницы. Соответственно, любая пара теперь ленивая, поскольку
мы не вычисляем ее car и cdr до тех пор, пока они не понадобятся и любой
список у нас потенциально бесконечный, поскольку пока мы не вычислим cdr,
мы не узнаем, что в нем.

Основная проблема состоит в том, что с точки зрения driver-loop список -
это такая же процедура (лямбда), как и другие процедуры. Соответственно,
мы изменим представление пары. Данные функции надо вгрузить в стандартный
интерпретатор (если вгрузить внутри драфвер лупа, то list не
распознается), заnем обновить окружение ленивого интерпретатора.

#+BEGIN_SRC scheme
  (define (new-cons x y)
    (cons 'pair (lambda (m) (m x y))))

  (define (new-car z)
    ((cadr z) (lambda (p q) p)))

  (define (new-cdr z)
    ((cadr z) (lambda (p q) q)))

  (define (new-pair? exp)
    (tagged-list? exp 'pair))

  (define primitive-procedures
    (list (list 'cons cons)
          (list 'car new-car)
          (list 'cdr new-cdr)
          (list 'pair? new-pair?)
          (list 'null? null?)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list 'display display)
          (list '+ +)
          (list '- -)
          ))

  (define the-global-environment (setup-environment))
#+END_SRC


#+BEGIN_SRC scheme
  (define (user-print object)
    (cond ((pair? object)
           (let ((pair (cadr object)))
           (display (list 'pair
                          (list (new-car pair))
                          '<promise>))))
          ((compound-procedure? object)
           (display (list 'compound-procedure
                          (procedure-parameters object)
                          (procedure-body object)
                          '<procedure-env>)))
          (else (display object))))


#+END_SRC

Не понимаю, почему не работает.

~Упражнение 4.35.~
Напишите процедуру ~an-integer-between~, которая возвращает целое число,
лежащее между двумя заданными границами. С ее помощью можно следующим образом
реализовать процедуру для поиска Пифагоровых троек, то есть троек чисел
(i, j, k) между заданными границами, таких, что i ≤ j и i^2 + j^2 = k^2 :

#+BEGIN_SRC scheme
  (define (a-pythagorean-triple-between low high)
    (let ((i (an-integer-between low high)))
      (let ((j (an-integer-between i high)))
        (let ((k (an-integer-between j high)))
          (require (= (+ (* i i) (* j j)) (* k k)))
          (list i j k)))))
#+END_SRC

Итак, новый интерпретатор (который нам пока не показали)
реализует поиск в глубину следующим образом:
при возможных вариантах выбора мы всегда выбираем самый первый вариант.
Если этот выбор приводит к неудаче, мы возвращаемся к точке
выбора  и выбираем второй вариант и т.д., пока либо мы не исчерпаем
варианты, либо не вернем какое-то выражение. Надо учитывать, что один
выбор может приводить к другим точкам выбора.

Пока что мы знаем о процедуре ~amb~ 2 вещи:
1. она инициирует поиск выборов в глубину, описанный выше
2. принимает 2 параметра: первый выбор и остальные.

Так что мы будем создавать всех возможных начений от нижней до верхней
границы, нижнюю границу будем передавать как первый выбор, а cdr
полученного списка значений как остальные возможные выборы.

#+BEGIN_SRC scheme
  (define (an-integer-between min max)
    (define (make-integers min max)
      (if (> min max)
          '()
          (cons min (make-integers (+ min 1) max))))
    (let ((integers (make-integers min max)))
      (amb (car integers) (cdr integers))))
#+END_SRC


~Упражнение 4.36.~
В упражнении 3.69 рассматривалась задача порождения потока всех
Пифагоровых троек, без всякой верхней границы диапазона целых чисел, в котором надо
искать. Объясните, почему простая замена ~an-integer-between~ на
~an-integer-starting-from~ в процедуре из упражнения 4.35
не является адекватным способом порождения произвольных Пифагоровых
троек.
Напишите процедуру, которая решает эту задачу. (Это значит, что Вам нужно написать
процедуру, для которой многократный запрос try-again в принципе способен
породить все Пифагоровы тройки.)

Отсутствие верхней границы означает, что нам нужны бесконечные потоки
чисел. То есть списки становятся потоками (не очень поняла, является ли
данный интерпретатор ленивым.. На всякий случай будем
считать, что нет)

В упражнении 3.69 мы создавали 3 бесконечных потока и перемешивали их таким образом,
чтоб тройки выходили "случайными": если бы мы пытались перемешать их
обычным способом, пытаясь поставить в пару каждым элементом первого
потока каждый элемент второго, то зависли бы навечно, поскольку первый
поток никогда не кончился бы. Здесь будет та же проблема, поскольку мы
будем двигаться по потокам "параллельно", поскольку всегда рассматриваем
все первые варианты как верные, затем вторые и т.д.
Так что нам надо не только породить 3 потока чисел, но и перемешать их между
собой. И вот уже оттуда выбирать чила.

#+BEGIN_SRC scheme
  ;; функция для перемешивания потоков
  (define (interleave s1 s2)
    (if (stream-null? s1)
        s2
        (cons-stream (stream-car s1)
                     (interleave s2 (stream-cdr s1)))))

  (define ones (cons-stream 1 ones))

  (define (add-streams s1 s2)
    (stream-map + s1 s2))

  (define integers (cons-stream 1 (add-streams ones integers)))

  ;; перемешиваем 3 потока в один
  (define interleave-integers
    (interleave (stream-cdr integers)
                (interleave integers (stream-cdr integers))))

  ;; получаем число "рандомно"
  (define (an-integer)
    (amb (stream-car interleave-integers)
         (stream-cdr interleave-integers)))

  ;; вид собранной процедуры
  (define (a-pythagorean-triple-between)
    ;; получили 3 числа
    (let* ((i (an-integer))
           (j (an-integer))
           (k (an-integer)))
      ;; добавили новое условие, что i <= j
      (require (and (<= i j)
                    (= (+ (* i i) (* j j)) (* k k))))
      (list i j k)))
#+END_SRC

~Упражнение 4.37~.
Бен Битобор утверждает, что следующий метод порождения Пифагоровых троек
эффективнее, чем приведенный в упражнении 4.35. Прав ли он?
(Подсказка: найдите, сколько вариантов требуется рассмотреть.)

#+BEGIN_SRC scheme
  (define (a-pythagorean-triple-between low high)
    ;; получаем числов внутри диапазона
    (let ((i (an-integer-between low high))
          ;; получаем максимально большой возможный квадрат числа в данном диапазоне
          (hsq (* high high)))
      (let ((j (an-integer-between i high)))
        ;; получаем сумму квадратом i и j
        (let ((ksq (+ (* i i) (* j j))))
          (require (>= hsq ksq))
          (let ((k (sqrt ksq)))
            (require (integer? k))
            (list i j k))))))
#+END_SRC

Да, Бен однозначно прав. Мы знаем, что пифагоровы тройки - это тройки,
где: i ≤ j и i^2 + j^2 = k^2, ищем мы эти тройки в заданных границах.
Мы знаем, что максимальное значение k^2 - это верхняя граница диапазона в
квадрате. Соответственно, сразу установив ее, мы можем сразу отмести
варианты i и j, суммы квадратов которых больше верхней границы в
квадрате. Если это условие совпадает -   k мы не ищем среди всех
возможных вариантов, а определяем как квадрат суммы уже известных i и j.
Таким образом мы ведем поиск в глубину по двум элементам i и j, вместо
трех: i, j и k.

~Упражнение 4.38.~
Измените процедуру ~multiple-dwelling~, отказавшись от требования, что Смит
и Флетчер живут не на соседних этажах. Сколько решений имеется у
измененной загадки?

Текст загадки:
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах пятиэтаж-
ного дома. Бейкер живет не на верхнем этаже. Купер живет не на первом
этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже. Миллер жи-
вет выше Купера. Смит живет не на соседнем с Флетчером этаже. Флетчер
живет не на соседнем с Купером этаже. Кто где живет?

#+BEGIN_SRC scheme
  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5))
          (cooper (amb 1 2 3 4 5))
          (fletcher (amb 1 2 3 4 5))
          (miller (amb 1 2 3 4 5))
          (smith (amb 1 2 3 4 5)))
      (require
       (distinct? (list baker cooper fletcher miller smith)))
      (require (not (= baker 5)))
      (require (not (= cooper 1)))
      (require (not (= fletcher 5)))
      (require (not (= fletcher 1)))
      (require (> miller cooper))
      ;; (require (not (= (abs (- smith fletcher)) 1)))  - убрали условие
      (require (not (= (abs (- fletcher cooper)) 1)))
      (list (list 'baker baker)
            (list 'cooper cooper)
            (list 'fletcher fletcher)
            (list 'miller miller)
            (list 'smith smith))))

  ;; все возможные варианты:
  ((baker 1) (cooper 2) (fletcher 4) (miller 3) (smith 5))
  ((baker 1) (cooper 2) (fletcher 4) (miller 5) (smith 3))
  ((baker 1) (cooper 4) (fletcher 2) (miller 5) (smith 3))
  ((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
  ((baker 3) (cooper 4) (fletcher 2) (miller 5) (smith 1)))
#+END_SRC

~Упражнение 4.39.~
Влияет ли порядок ограничений в процедуре multiple-dwelling на ответ?
Влияет ли он на время, необходимое для поиска ответа? Если Вы считаете, что он имеет
значение, то покажите, как можно ускорить программу, переупорядочив
ограничения. Если Вы считаете, что порядок значения не имеет, объясните,
почему.

Я думаю, что порядок ограничений не меняет ответа задачи, поскольку нам
нужно проверить их все, поэтому если какое-то из ограничений мы не
соблюли, мы об этом узнаем.
Но да, я думаю, что порядок ограничений может влиять на скорость.
Мы знаем, что каждый раз в ситуации выбора будем выбирать первый
указанный вариант, надеясь, что он верный. Если он таковым не окажется,
мы вернемся в точку выбора и выберем следующий. Соответственно, имеет
смысл первыми выставить ограничения, которые сообщают нам, что первый
выбор - не верный. В данном случае это "флетчер не живет на первом
этаже" и "купер не живет на первом этаже". Встретив два эти ограничения
сразу, мы должны будем тут же вернуться в точку выбора. Таким образом
сэкономим время.
Затем я бы поставила ограничение "миллер живет выше купера" и "смит и
флетчер живут не на соседних этажах" и "флетчер и купер живут не на
соседних этажах" и только после этого "бейкер не живет на верхнем этаже",
"флетчер не живет на верхнем этаже", поскольку они наименее вероятные,
поскольку чтоб их достигнуть, надо перебрать все остальные.

Получилось бы так:
#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5))
          (cooper (amb 1 2 3 4 5))
          (fletcher (amb 1 2 3 4 5))
          (miller (amb 1 2 3 4 5))
          (smith (amb 1 2 3 4 5)))
      (require
       (distinct? (list baker cooper fletcher miller smith)))
      (require (not (= cooper 1)))
      (require (not (= fletcher 1)))
      (require (> miller cooper))
      (require (not (= (abs (- smith fletcher)) 1)))
      (require (not (= (abs (- fletcher cooper)) 1)))
      (require (not (= baker 5)))
      (require (not (= fletcher 5)))
      (list (list 'baker baker)
            (list 'cooper cooper)
            (list 'fletcher fletcher)
            (list 'miller miller)
            (list 'smith smith))))
#+END_SRC

~Упражнение 4.40.~
Сколько возможных соответствий между людьми и этажами имеется в задаче о
проживании, если учитывать требование, что все живут на разных этажах, и если его не
учитывать? Крайне неэффективно порождать все возможные соответствия между
людьми и этажами, а затем полагаться на то, что поиск с возвратом отсечет
лишнее.
Например, большая часть ограничений зависит только от одной или двух
переменных, соответствующих людям, и их можно было бы проверять
раньше, чем этажи выбраны для всех действующих лиц. Напишите и
продемонстрируйте значительно более эффективную недетерминистскую
процедуру, которая бы решала задачу, порождая только те варианты, которые
еще не исключены благодаря предыдущим ограничениям. (Подсказка:
потребуется набор вложенных выражений let.)

Если у нас нет условия, что все жильцы проживают на разных этажах, то
число возможных комбинаций резко увеличивается.

Новый вариант будет выглядеть так:
#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    (let ((baker (amb 1 2 3 4 5)))
      (require (not (= baker 5)))
      (let ((cooper (amb 1 2 3 4 5)))
        (require (not (= cooper 1)))
        (let ((fletcher (amb 1 2 3 4 5)))
          (require (not (= fletcher 1)))
          (require (not (= fletcher 5)))
          (let ((miller (amb 1 2 3 4 5)))
            (require (> miller cooper))
            (let ((smith (amb 1 2 3 4 5)))
              (require
               (distinct? (list baker cooper fletcher miller smith)))
              (require (> miller cooper))
              (require (not (= (abs (- smith fletcher)) 1)))
              (require (not (= (abs (- fletcher cooper)) 1)))
              (list (list 'baker baker)
                    (list 'cooper cooper)
                    (list 'fletcher fletcher)
                    (list 'miller miller)
                    (list 'smith smith))))))))
#+END_SRC

Второй вариант.
Есть идея, что если мы знаем ограничения заранее (а мы их знаем из текста
задачи), то некоторые варианты можно и не предлагать. Например, не имеет
смысла предлагать варианты всех этажей для Флетчера и затем проверять их с
первого по пятый, если мы знаем, что Флетчер не живет ни на первом, ни на
пятом.
УБрав некоторые варианты, мы уже можем не кодировать некоторые
ограничения.
#+BEGIN_SRC scheme
  (define (multiple-dwelling)
    ;; Купер не живет на 1 этаже
    (let ((cooper (amb 2 3 4 5))
          ;; а Миллер может быть только выше Купера
          (miller (amb 3 4 5)))
      (require (> miller cooper))
      ;; флетчер не живет ни на 1 ни на 5
      (let ((fletcher (amb 2 3 4))
            ;; Смит живет на любом этаже
            (smith (amb 1 2 3 4 5))
            ;; Бэйкер не живет на последнем
            (baker (amb 1 2 3 4)))
        ;; теперь вставляем оставшиеся ограничения
        (require
         (distinct? (list baker cooper fletcher miller smith)))
        (require (not (= (abs (- smith fletcher)) 1)))
        (require (not (= (abs (- fletcher cooper)) 1)))
          (list (list 'baker baker)
                        (list 'cooper cooper)
                        (list 'fletcher fletcher)
                        (list 'miller miller)
                        (list 'smith smith)))))
#+END_SRC

~Упражнение 4.41.~
Напишите процедуру для решения задачи о проживании на обычной Scheme

Текст загадки:
Бейкер, Купер, Флетчер, Миллер и Смит живут на разных этажах пятиэтаж-
ного дома. Бейкер живет не на верхнем этаже. Купер живет не на первом
этаже. Флетчер не живет ни на верхнем, ни на нижнем этаже. Миллер жи-
вет выше Купера. Смит живет не на соседнем с Флетчером этаже. Флетчер
живет не на соседнем с Купером этаже. Кто где живет?

Тут начинаешь понимать прелести недетерминистского
интерпретатора. Программа проучилась неэффективной.
#+BEGIN_SRC scheme
  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (multiple-dwelling)
    (define (iter baker cooper fletcher miller smith)
      (display baker) (display cooper) (display fletcher)
      (display miller) (display smith) (newline)
      (cond ((<= cooper 1) (iter baker (+ cooper 1) fletcher miller smith))
            ((< smith 1) (iter baker cooper fletcher miller (+ smith 1)))
            ((< baker 1) (iter (+ baker 1) cooper fletcher miller smith))
            ((<= fletcher 1) (iter baker cooper (+ fletcher 1) miller smith))
            ((>= baker 5) (iter (- baker 1) cooper fletcher miller smith))
            ((>= fletcher 5) (iter baker cooper (- fletcher 1) miller smith))
            ((> miller 5) (iter baker cooper fletcher (- miller 1) smith))
            ((<= miller cooper) (iter baker (- cooper 1) fletcher (+ miller 1) smith))
            ((= (abs (- smith fletcher)) 1)
             (iter baker cooper (random  5) miller (random  6)))
            ((= (abs (- fletcher cooper)) 1)
             (iter baker (random  6) (random  5) miller smith))
            ((distinct? (list baker cooper fletcher miller smith))
             (list (list 'baker baker)
                   (list 'cooper cooper)
                   (list 'fletcher fletcher)
                   (list 'miller miller)
                   (list 'smith smith)))
            (else (iter (random  5) (random  6) (random  5) (random  6) (random  6)))))
    (iter (random  5) (random  6) (random  5) (random  6) (random  6)))
#+END_SRC
~Упражнение 4.42.~

Решите задачу «Лгуньи» (из Phillips 1934):
Пять школьниц писали экзаменационную работу. Им показалось, что их
родители чересчур интересовались результатом, и поэтому они решили, что каждая
девочка должна написать домой о результатах экзамена и при этом сделать одно
верное и одно неверное утверждение. Вот соответствующие выдержки из их писем:
Бетти: «Китти была на экзамене второй, а я только третьей».
Этель: «Вам будет приятно узнать, что я написала лучше всех. Второй была
Джоан».
Джоан: «Я была третьей, а бедная Этель последней».
Китти: «Я оказалась второй. Мэри была только четвертой».
Мэри: «Я была четвертой. Первое место заняла Бетти».

В каком порядке на самом деле расположились отметки девочек?

Нам известно:
- каждая девочка написала 2 утверждения
- одно из этих утверждения ложно, другое правдиво
- позиции девочек в рейтинге не повторяются

?:
- результат должен быть независим от порядка утверждений девочек в
  задачке

В качестве данных у нас утверждения.
#+BEGIN_SRC scheme
  (define (xor a b)
    ;; или первое утверждение НЕ правда, а второе тогда правда,
    ;; или второе утверждение НЕ правда, а первое тогда правда
    ;;( мы знаем, что одно из утверждений всегда true, а другое всегда false)
    (or (and (not a) b)
        (and (not b) a)))

  ;; если бетти не третья, то китти вторая (и наоборот)
  (define (betty-statement betty kitty)
    (xor (= betty 3) (= kitty 2)))

  ;; если этель не первая, то джоан - вторая (и наоборот)
  (define (ethel-statement ethel joan)
    (xor (= ethel 1) (= joan 2)))

  ;; если джоан не третья, то этель - пятая (и наоборот)
  (define (joan-statement joan ethel)
    (xor (= joan 3) (= ethel 5)))

  ;; если китти не вторая, то мэри - четвертая (и наоборот)
  (define (kitty-statement kitty mary)
    (xor (= kitty 2) (= mary 4)))

  ;; если мэри не четвертая, то бетти - первая
  (define (mary-statement mary betty)
    (xor (= mary 4) (= betty 1)))

#+END_SRC

Теперь у нас есть 5 утверждений, каждое из которых принимает 2 числовых
значения от 1 до 5.
Если в ~betty-statement~ будет передано 1 и 2 (Бетти первая, а Джоан -
вторая), то ~xor~ вернет #t - нам достаточно, чтоб только один операнд
~or~ дал #t. Таким образом получится, что утверждение "Джоан - вторая"
верно. Принцип сохранится для всех утверждений.

Теперь надо собрать все утверждения, прогнать через них разные значения,
собрать результаты и объединить их в список.

С недетерминистским интерпретатором:
#+BEGIN_SRC scheme
  (define (liers)
    (let ((betty (amb 1 2 3 4 5))
          (ethel (amb 1 2 3 4 5))
          (joan (amb 1 2 3 4 5))
          (kitty (amb 1 2 3 4 5))
          (mary (amb 1 2 3 4 5)))
      (require (distinct? (list betty ethel joan kitty mary)))
      (require (betty-statement betty kitty))
      (require (ethel-statement ethel joan))
      (require (joan-statement joan ethel))
      (require (kitty-statement kitty mary))
      (require (mary-statement mary betty))
      (list (list 'betty betty)
            (list 'ethel ethel)
            (list 'joan joan)
            (list 'kitty kitty)
            (list 'mary mary))))
#+END_SRC

Через обычную scheme:
#+BEGIN_SRC scheme
  (define prev-n #f)

  ;; создадим функцию, которая генерит случайные числа в заданном интервали
  ;; при этом мы следим, чтоб не выпадало подряд дважды одно и то же число
  (define (generate-number-interval min max)
    (let ((n (random (+ max 1))))
      (cond ((eq? prev-n n) (if (< n max)
                                (begin (set! prev-n (+ prev-n 1))
                                       (+ n 1))
                                (begin (set! prev-n (- prev-n 1))
                                       (- n 1))))
            ((< n min) (begin (set! prev-n min) min))
            (else (begin (begin (set! prev-n n) n))))))

  (define (liers)
    (define (iter betty ethel joan kitty mary)
      (if  (and (distinct? (list betty ethel joan kitty mary))
                (and (betty-statement betty kitty)
                     (ethel-statement ethel joan)
                     (joan-statement joan ethel)
                     (kitty-statement kitty mary)
                     (mary-statement mary betty)))
           (list (list 'betty betty)
                 (list 'ethel ethel)
                 (list 'joan joan)
                 (list 'kitty kitty)
                 (list 'mary mary))
           (iter (generate-number-interval 1 5)
                 (generate-number-interval 1 5)
                 (generate-number-interval 1 5)
                 (generate-number-interval 1 5)
                 (generate-number-interval 1 5))))
    (iter 1 2 3 4 5))
#+END_SRC


~Упражнение 4.43.~
Решите с помощью amb-интерпретатора следующую задачу:
У отца Мэри Энн Мур есть яхта, и у каждого из четверых его друзей
тоже. Эти четверо друзей — полковник Даунинг, мистер Холл, сэр Барнакл Худ и доктор
Паркер. У каждого из них тоже есть по дочери, и каждый из них назвал свою
яхту в честь дочери одного из своих друзей. Яхта сэра Барнакла называется
Габриэлла, яхта мистера Мура — Лорна, а у мистера Холла яхта Розалинда. Мелисса, яхта
полковника Даунинга, названа в честь дочери сэра Барнакла. Отец Габриэллы владеет
яхтой, названной в честь дочери доктора Паркера. Кто отец Лорны?

Попытайтесь написать программу так, чтобы она работала эффективно
(см. упражнение 4.40).
Кроме того, определите, сколько будет решений, если не указывается, что
фамилия Мэри Энн — Мур.

Итак, у нас есть 5 друзей: Даунинг, Холл, Худ, Мур и Паркер. У каждого из
них есть яхта, и имя яхты - это имя дочери кого-то из его друзей.
Известно:
- дочь Мура - Мэри, яхта - Лорна.
- яхта Даунинга - Мелисса
- дочь Худа - Мелисса, яхта - Габриэлла,
- яхта Холла - Розалинда
- отец Габриэллы владеет яхтой, которая названа в честь дочери Паркера

Неизвестены:
- отец Габриэллы
- отец Розалинды
- отец Лорны
- яхта и дочь Паркера

?:
- дочь Паркера - Розалинда, яхта - Мэри
- дочь Холла - Габриэлла
- дочь Даунинга - Лорна.

Отец Габриэллы - Холл, поскольку:
- имя его дочери мы не знаем
- Даунинг - не отец Габриэллы, поскольку сказано, что его яхта назыана в
  честь дочери Худа, а не Паркера
- имена дочерей остальных известны, кроме имени дочери Паркера.

Про реазизацию:
- На выходе мы должны получить списки из 3х имен, где первым будет идти
  имя одного из друзей, затем имя его дочери и потом имя его яхты
- исходные данные: каждому женскому имени присваиваем пару отец-хозяин
  яхты

Требования (негласные):
- имя дочери и имя яхты не повторяется у одного и того же друга:
  у отца Габриэллы яхта НЕ называется Габриэлла
- имена дочерей НЕ повторяются
- имена яхт НЕ повторяются

Реализация осуществлена согласно идее из второго варианта решения упр. 4.40
Исходим из идеи, что мы предлагаем ~amb~ только действительно возможные
варианты. Например, если нам известно, что дочь Мура - Мэри, а яхта -
Лорна, то мы сразу это установить и таким образом не писать явным образом
это ограничение + уберем лишние исследования вариантов для
интерпретатора.

#+BEGIN_SRC scheme
  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (map fn args-list)
    (define (iter fn args-list result-list)
      (if (null? args-list)
          result-list
          (iter fn (cdr args-list) (append result-list (list (fn (car args-list)))))))
  (iter fn args-list'()))

  (define (require p)
    (if (not p) (amb)))

  (define daughter first)

  (define boat second)


  (define (daughters-and-boats)
    ;; дочь и яхта Мура известны, варианты ни к чему
    ;; теперь мы помним, что имя Мэри занято для дочери, а Лорна - для яхты
    (let ((moor (list 'mary 'lorna))
          ;; известна яхта Холла
          (hall (list (amb 'lorna 'gabrielle 'melissa)
                      'rosalinda))
          ;; известна яхта Даунинга
          (downing (list (amb 'lorna 'gabrielle 'rosalinda)
                         'melissa)))
      ;; яхта Худа известна, а имя дочери = яхта Даунингаа
      (let ((hood (list (second downing) 'gabrielle))
            ;; дочь и яхта Паркера неизвесты, но:
            ;; для яхт заняты все имена кроме Мэри
            (parcker (list (amb 'lorna 'gabrielle 'rosalinda)
                           'mary)))
        (let ((gabrielle-father (amb hall downing parcker))
              (lorna-father (amb hall downing parcker)))
        ;; -- осуществляем все оставшиеся ограничения--
        ;; имена дочерей у мужчин не повторяются
        (require
         (distinct? (map (lambda (x)
                           (daughter x)) (list downing moor hood parcker hall))))
        ;; имена яхт не повторяются
        (require
         (distinct? (map (lambda (x)
                           (boat x)) (list downing moor hood parcker hall))))
        (require (eq? (daughter gabrielle-father) 'gabrielle))
        (require (eq? (daughter lorna-father) 'lorna))
        (require (distinct? lorna-father))
        (require (distinct? gabrielle-father))
        (require (eq? (daughter parcker)
                      (boat gabrielle-father)))

        (list (list 'moor's 'daughter: (daughter moor) 'boat: (boat moor))
              (list 'hall's 'daughter: (daughter hall) 'boat: (boat hall))
              (list 'downing's 'daughter: (daughter downing) 'boat: (boat downing))
              (list 'hood's 'daughter: (daughter hood) 'boat: (boat hood))
              (list 'parcker's 'daughter: (daughter parcker) 'boat: (boat parcker)))
        ))))

#+END_SRC

Если не говорить, что Мур - отец Мэри, то у Даунинга, Паркера и Холла
появляется одно имя для Дочери, а у Мура - сразу 4 возможных. При этом
количество возможных комбинаций вырастает больше, чем
экспоненциально. Думаю, если раньше это был !3, то теперь это !4.

~Упражнение 4.44.~
В упражнении 2.42 описывалась «задача о восьми ферзях», в которой
требуется расставить на шахматной доске восемь ферзей так, чтобы ни один
не бил другого. Напишите недетерминистскую программу для решения этой задачи.

Один из способов решать эту задачу состоит в том, чтобы идти поперек
доски, устанавливая по ферзю в каждой вертикали. После того, как k − 1
ферзя мы уже разместили, нужно разместить k-го в таком месте, где он не
бьет ни одного из тех, которые уже находятся на доске. Этот подход можно
сформулировать рекурсивно: предположим, что мы уже породили
последовательность из всех возможных способов разместить k − 1 ферзей на
первых k − 1 вертикалях доски. Для каждого из этих способов мы порождаем
расширенный набор позиций, добавляя ферзя на каждую горизонталь k-й
вертикали. Затем эти позиции нужно отфильтровать, оставляя только те, где
ферзь на k-й вертикали не бьется ни одним из остальных. Продолжая этот
процесс, мы породим не просто одно решение, а все решения этой задачи.

Воспользумся наработками из упражнения 2.42
#+BEGIN_SRC scheme
  (define (queens board-size)
    (define (queen-cols k)
      (if (= k 0)
          (list empty-board)
          (map (lambda (rest-of-queens)
                 ;; произвольным образом выбираем номер от 1 до максимума и прсоединяем его
                 ;; к остальным взможным вариантам
                 (let ((new-board (adjoin-position (an-element-of
                                                    (enumerate-interval 1 board-size))
                                                   rest-of-queens)))
                   ;; проверяем, пересекается ли k с каким-либо из вариантов
                   (require (safe? new-board))
                   ;; если нет, возвращаем полученные варианты
                   ;; иначе amb вернется назад и будет пробовать остальные варианты
                   new-board))
               (queen-cols (- k 1)))))
    (queen-cols board-size))

  (define (adjoin-position new-row rest-of-queens)
    (cons new-row rest-of-queens))

  (define empty-board
    (list))

  ;; проверяем, занимает ли какой-то ферзь дигональ или вертикаль других ферзей
  (define (safe? k positions)
    (not (or (= k (car positions)) (= k (cdr positions)))))
#+END_SRC


~Упражнение 4.45.~
Согласно заданной выше грамматике, следующее предложение можно
проанализировать пятью различными способами: The professor lectures to
the student in the class with the cat («Профессор читает лекцию студенту
в аудитории с кошкой»). Покажите эти пять разборов и объясните разницу
в оттенках значения между ними.

Заданная грамматика:
#+BEGIN_SRC scheme
  (define nouns '(noun student professor cat class))
  (define verbs '(verb studies lectures eats sleeps))
  (define articles '(article the a))
  (define prepositions '(prep for to in by with))
  ;;сюда зпишем весь ввод
  (define *unparsed* '())

  ;; запускает парсинг ввода и возвращает результат парсинга
  (define (parse input)
    (set! *unparsed* input)
    (let ((sent (parse-sentence)))
      (require (null? *unparsed*))
      sent))

  ;; принимает список слов и ищет среди этого списка первое слово из нераспарсенных
  (define (parse-word word-list)
    (require (not (null? *unparsed*)))
    (require (memq (car *unparsed*) (cdr word-list)))
    ;; если нашел, то выкидывает это слово из списка нераспарсенных
    (let ((found-word (car *unparsed*)))
      (set! *unparsed* (cdr *unparsed*))
      ;; соединяет слово с тегом (какая это часть речи) и возвращает
      (list (car word-list) found-word)))

  ;; парсим словосочетание предлог + существительное
  (define (parse-prepositional-phrase)
    (display "parse-prepositional-phrase")
    (newline)
    (list 'prep-phrase
           (parse-word prepositions)
           (parse-noun-phrase)))

  ;; парсим предложение подлежащие + сказуемое
  (define (parse-sentence)
    (list 'sentence
           (parse-noun-phrase)
           (parse-verb-phrase)))

  ;; парсим глагол (может оказаться как одним словом, так и с предлогом)
  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      (display "parse-verb-phrase")
      (newline)
      (display verb-phrase)
      (newline)
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                                verb-phrase
                                (parse-prepositional-phrase)))))
    (maybe-extend (parse-word verbs)))

  ;; парсинг существительных с артиклями
  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
           (parse-word articles)
           (parse-word nouns)))

  ;; парсинг существительных в связке с другими существительными и предлогами
  (define (parse-noun-phrase)
    (define (maybe-extend noun-phrase)
      (display "parse-noun-phrase")
      (newline)
      (display noun-phrase)
      (newline)
      (amb noun-phrase
           (maybe-extend (list 'noun-phrase
                               noun-phrase
                               (parse-prepositional-phrase)))))
    (maybe-extend (parse-simple-noun-phrase)))
#+END_SRC

"The professor lectures to the student in the class with the cat"
Все это предложение попадает в  *unparsed*, затем мы вызываем
~parse-sentence~. ~parse-sentence~ представляет из себя вызов ~parse-noun-phrase~
и ~parse-verb-phrase~. ~parse-noun-phrase~ распарсит все существительные
с их предлогами, а ~parse-verb-phrase~ распарсит все глаголы с их
предлогами.

#+BEGIN_SRC scheme
  ;; профессор с кошкой читают лекцию студенту в классе
  (sentence (simple-noun-phrase (article the)
                                (noun professor))
            (verb-phrase
             (verb-phrase
              (verb-phrase
               (verb lectures)
               (prep-phrase (prep to)
                            (simple-noun-phrase (article the) (noun student))))
              (prep-phrase (prep in) (simple-noun-phrase (article the) (noun class))))
             (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))

  ;; профессор читает лекцию  в классе кошкой студенту
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb-phrase
              (verb lectures)
              (prep-phrase (prep to)
                           (simple-noun-phrase (article the) (noun student))))
             (prep-phrase (prep in)
                          (noun-phrase
                           (simple-noun-phrase (article the) (noun class))
                           (prep-phrase (prep with)
                                        (simple-noun-phrase (article the) (noun cat)))))))

  ;; профессор с кошккой (типа на руках) читает лекцию студенту в классе
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb-phrase
              (verb lectures)
              (prep-phrase (prep to)
                           (noun-phrase
                            (simple-noun-phrase (article the) (noun student))
                            (prep-phrase (prep in)
                                         (simple-noun-phrase (article the) (noun class))))))
             (prep-phrase (prep with) (simple-noun-phrase (article the) (noun cat)))))

  ;; профессор читает лекцию студенту  с кошкой (типа кошка на руках у студента) в классе
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb lectures)
             (prep-phrase (prep to)
                          (noun-phrase
                           (noun-phrase
                            (simple-noun-phrase (article the) (noun student))
                            (prep-phrase (prep in)
                                         (simple-noun-phrase (article the) (noun class))))
                           (prep-phrase (prep with)
                                        (simple-noun-phrase (article the) (noun cat)))))))

  ;; профессор читает лекцию студенту в классе, где есть кошка
  (sentence (simple-noun-phrase (article the) (noun professor))
            (verb-phrase
             (verb lectures)
             (prep-phrase (prep to)
                          (noun-phrase
                           (simple-noun-phrase (article the) (noun student))
                           (prep-phrase (prep in)
                                        (noun-phrase
                                         (simple-noun-phrase (article the)
                                                             (noun class))
                                         (prep-phrase (prep with)
                                                      (simple-noun-phrase (article the)
                                                                          (noun cat)))))))))
#+END_SRC

~Упражнение 4.46.~
Интерпретаторы в разделах 4.1 и 4.2 не определяют, в каком порядке
вычисляются операнды при вызове процедуры. Мы увидим, что
amb-интерпретатор вычисляет их слева направо. Объясните,
почему программа разбора не стала бы работать, если бы операнды
вычислялись в каком-нибудь другом порядке.

Нам в предложении важен порядок слов (особенно в английском
языке), поэтому и парсить слова следует в том порядке, в котором их
ввели.
К тому же, различные функции парсинга ожидают увидеть определенные
части речи в определенном месте разбираемого предложения. Если мы анализируем
аргументы в другом порядке, то нужных частей речи может просто не
оказаться на месте, соответственно, мы не распарсим предложение.

К примеру, если у нас целиком не распарсено 'the cat sleeps', а мы
сначала вызываем вот эту функцию:

#+BEGIN_SRC scheme
  (define (parse-sentence)
    (list 'sentence
           (parse-noun-phrase)
           (parse-verb-phrase)))
#+END_SRC

и сначала сработает парсиинг глагола, то мы ничего не найдем: the -
значится в списке артиклей, попытка найти его в списке глаголов сфейлится
и мы ничего не распарсим.
Кстати говоря, данная программа, даже используя вычисление слева направо,
не распарсит предложение а-ля мастер Йода "чувствую силу в тебе я",
программа ожидает увидеть в начале предложения подлежащее, как в любом
нормальном предложении английского языка.


~Упражнение 4.47.~
Хьюго Дум говорит, что поскольку глагольная группа — это либо глагол,
либо глагольная группа плюс предложная группа, было бы намного
естественнее  определить процедуру parse-verb-phrase так
(и то же сделать для именных групп):
#+BEGIN_SRC scheme
  (define (parse-verb-phrase)
    (amb (parse-word verbs)
         (list 'verb-phrase
                (parse-verb-phrase)
                (parse-prepositional-phrase))))

#+END_SRC

Работает ли этот вариант? Изменится ли поведение программы, если мы
поменяем местами выражения в amb?

Исходный вид parse-verb-phrase:
#+BEGIN_SRC scheme
  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      ;; аmb получает на вход первый глагол из распарсенных и
      ;; список, который вернет рекурсивный вызов
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                                verb-phrase
                                (parse-prepositional-phrase)))))
    ;; пытаемся распарсить первое слово из оставшихся и думаем, что это слово - глагол
    ;; затем полученный глагол как параметр
    (maybe-extend (parse-word verbs)))

  (define (parse-word word-list)
    (require (not (null? *unparsed*)))
    (require (memq (car *unparsed*) (cdr word-list)))
    (let ((found-word (car *unparsed*)))
      (set! *unparsed* (cdr *unparsed*))
      (list (car word-list) found-word)))
#+END_SRC

Я думаю, что вариант Хьюго будет работать не совсем
правильно. parse-word вызванный с verbs (списком глаголов) будет пытаться
найти текущее слово в списке глаголов. Если оно там есть, то мы получим
на выходе ('verb какой-то глагол). Один вызов ~parse-word~ = один найденный
(или нет) глагол. В исходном виде ~parse-verb-phrase~ ~parse-word~ будет
вызвана 1 раз и результат ее вызова - найденный глагол - будет передан в
~maybe-extend~ как параметр, соответственно, если в ходе аналища мы
придем к выводу, что распарсенный глагол - это глагол с предлогом и его
надо парсить дальше, мы будем парсить тот же самый глагол, поскольку он
является нашим параметром ~verb-phrase~.

Теперь смотрим, что делает Хьюго. Он обходится без внутренней функции,
если первый вариант, переданный ~amb~ не сработает - результат
~parse-word~ - то мы вызовем
рекурсивно ~parse-verb-phrase~. Что происходит внутри рекурсивного
вызова? Правильно, еще один вызов amb, первым вариантом выбора которого
становится результат вызова ~parse-word~ . Это уже второй вызов, а
значит, мы проанализировали уже следующий нераспарсенный глагол. Таким
образом первый мы так и не распарсили правильно. Более того, мы не сможем
распарсить ни один глагол с препозицией правильно, пока не достигнем дна
от рекурсивного вызова ~parse-verb-phrase~, то есть нам надо, чтоб у нас
как минимум кочились все нераспарсенные слова. А среди нераспарсенных у
нас и предлоги к первому глаголу, которых, естесвенно, не будет в списке
глаголов, то есть весь парсинг провалится.

Если поменять местами выражения в вызове ~amb~, т.е. по умолчанию
считать, что все глаголы с препозициями, а если нет - без них, ситуация
несколько улучшится, но только при условии, что мы парсим глагол с
препозицией. Если нет, то отработка остальных вариантов повлечет за собой
новые рекурсивные вызовы ~parse-verb-phrase~ и дальше мы легко можем
попасть в сценарий, описанный выше, когда не можем распарсить ничего.

К тому же способ Хьюго не учитывает, что у нас может быть не один глагол
или же могут быть больше одной связги глагола с чем-либо. Мы не будем
рекурсивно проходить по этоя глаголольной связке, пока не наткнемся на
существительное.

~To Do! Упражнение 4.48.~
Дополните описанную выше грамматику так, чтобы она могла работать с более
сложными предложениями. Например, можно позволить именным и глагольным
группам включать прилагательные и наречия, или же можно обрабатывать
сложные предложения.

Дополним грамматику прилагательными и наречиями.

- добавляем список прилагательных
- добавляем функцию парсинга словосочетания прилагательное +
  существительное ~parse-adj-phrase~. ~parse-adj-phrase~ пробует
  распарсить первое слово как прилагательное и если за ним больше ничего
  не следует, то так его и вернет. Такое может получиться, если у нас
  предложение звучит как "Sky is blue". Если же этот вариант не подошел,
  ищем дальше. У нас может быть более одного прилагательного, например.

#+BEGIN_SRC scheme
  ; добавлем список прилагательных
  (define adjectives '(adj big small white))

  (set! *unparsed* (cdr *unparsed*))

  (set! *unparsed* '(big small white cat))

  (set! *unparsed* '(lectures sleeps))
  (set! *unparsed* '())
  ;; добавляем функцию парсинга для прилагательного в связке с существительным
  (define (parse-adj-phrase)
    (define (maybe-extend adj-phrase)
      ;; (display adj-phrase)
      ;; (newline)
      (amb adj-phrase
           (maybe-extend (list 'adj-noun-phrase
                                adj-phrase
                                (parse-simple-adj-noun)
                               ))))
    (maybe-extend (parse-word adjectives)))

  ;; усовершенствуем парсинг простой именной группы так, чтоб в связке с существительным
  ;; могло идти прилагательное
  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
          (parse-word articles)
          (parse-adj-phrase)))

  (define (parse-simple-noun-phrase)
    (list 'simple-noun-phrase
          (parse-word articles)
          (parse-simple-adj-noun)))

  ;; парсинг прилагательное + существительное
  (define (parse-simple-adj-noun)
    (list 'simple-adj-noun-phrase
          (parse-word adjectives)
          (parse-word nouns)))

  (define (parse-sentence)
    (list 'sentence
          (parse-noun-phrase)
          (parse-verb-phrase)))


  (define (parse-adj-phrase)
      (list 'adj-noun-phrase
            (parse-simple-adj-noun))

                               (parse-simple-adj-noun)
                               ))))
    (maybe-extend (parse-word adjectives)))
#+END_SRC

Теперь добавляем наречия. Рассчитываем, что наречие может идти либо сразу
после глагола, либо не идет вообще.

То есть "профессор говорит громко" наша система распознает, а "профессор
сказал студенту громко" - уже нет.

К тому же нам надо соединить это с поиском дальнейших связок
- вводим список наречий
- вводим функцию парсинга наречия ~parse-adverb~
Она может распознавать как единичные наречия, так и наречия с дальнейшими
"продолжениями", т. е. "профессор сказал громко студенту....", т.е. после
нахождения наречия возможен поиск предлогов и обстоятельств.
- изменим ~parse-verb-phrase~, чтоб включить в нее ~parse-adverb~, так мы
  будем искать не только обстоятельства, но и наречия в связке с
  глаголами.

#+BEGIN_SRC scheme
  ; добавлем список наречий
  (define adverbs '(adv slowly loudly))


  ;; добавляем функцию наречия (возможно с дальнейшими связками)
  (define (parse-adverb)
    (define (maybe-adverb-with-prep adverb-phrase)
      (amb adverb-phrase
           (maybe-adverb-with-prep
            (list 'adverb-phrase
                  adverb-phrase
                  (parse-prepositional-phrase)))))
    (maybe-adverb-with-prep (parse-word adverbs)))

    (define (maybe-extend adj-phrase)
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                               verb-phrase
                               (parse-word nouns)
                               ))))
    (maybe-extend (parse-word verbs)))

  (define (parse-verb-phrase)
    (define (maybe-extend verb-phrase)
      (amb verb-phrase
           (maybe-extend (list 'verb-phrase
                               verb-phrase
                               (parse-adverb)))))
    (maybe-extend (parse-word verbs)))
#+END_SRC

~Упражнение 4.49.~
Лизу П. Хакер больше интересует не анализ предложений, а их
порождение. Она замечает, что если изменить процедуру ~parse-word~ так,
чтобы она игнорировала «входное предложение», всегда заканчивалась
успехом и порождала подходящее слово, мы сможем использовать те же
программы, которые мы написали для анализа, для порождения
предложений. Реализуйте идею Лизы и покажите первые пять-шесть
порожденных предложений.

Это требует иного подхода, фактически это означает, что мы не анализируем
входное предложение, а предлагаем свои варианты. Подозреваю, что походим
образом работают подсказки при вводе в Т9 или переводчиках, погда
пользователю предлагаются разные слова на выбор после того, как он ввел
текущее слово. ТО есть пока юзер вводит слово "быстро", Т9 уже предлагает
ему варинты "бегать" "прыгать" "ходить".

Соответственно, нам надо сформулировать новые правила
грамматики для такой процедуры.
К примеру:
- предложение всегда начинается с артикля
- после артикля всегда следует существительное
- после существительного всегда следует глагол.

Возьмем этот мини-вариант, который будет наиболее просто реализовать.
Чтоб слова каждый раз выбирались рандомно, а не генерилось постоянно одно
и то же предложение, мы будем обращаться к элементам списков с частями
речи по индексу, а индекс будем псевдорандомно генерить.

Проверено через обычную схему.
~generate-number-interval~ взята из упражнения "Лгуньи".
#+BEGIN_SRC scheme
  (define nouns '(noun student professor girl dog cat class))
  (define verbs '(verb studies lectures eats sleeps))
  (define articles '(article the a an))

  ;; доступ к элементу списка по его индексу
  (define (nth n lst)
    (if (= n 0)
        (car lst)
        (nth (- n 1) (cdr lst))))

  (define prev-n #f)

  ;; создадим функцию, которая генерит случайные числа в заданном интервали
  ;; при этом мы следим, чтоб не выпадало подряд дважды одно и то же число
  (define (generate-number-interval min max)
    (let ((n (random (+ 1 max))))
      (cond ((eq? prev-n n) (if (< n max)
                                (begin (set! prev-n (+ prev-n 1))
                                       (+ n 1))
                                (begin (set! prev-n (- prev-n 1))
                                       (- n 1))))
            ((< n min) (begin (set! prev-n min) min))
            (else (begin (begin (set! prev-n n) n))))))

  (define (parse-word)
    (define (make-phrase phrase)
      (cond ((null? phrase) (make-phrase (list (list 'article
                                                     (nth (generate-number-interval 0 2)
                                                          (cdr articles))))))
            ((eq? (caar (last-pair phrase)) 'article)
             (make-phrase (append phrase (list (list 'noun
                                                     (nth (generate-number-interval 0 5)
                                                                 (cdr nouns)))))))
            ((eq? (caar (last-pair phrase)) 'noun)
             (make-phrase (append phrase
                                  (list (list 'verb
                                              (nth (generate-number-interval 0 4)
                                                   (cdr verbs)))))))
            (else phrase)))
    (make-phrase '()))


  ;; (parse-word)
#+END_SRC

 ~amb-интерпретатор~

Заливаем все из метациклического и анализирующего интерпретаторов + код
ниже +

Некоторые вещи из прошлых интерпретаторов нам не понадобятся или они
переопределяются, но проще залить все, чем выиискивать, что действительно
нужно.

#+BEGIN_SRC scheme
  ;; это выражение для amb-процедуры?
  (define (amb? exp) (tagged-list? exp 'amb))

  ;; список возможных выборов
  (define (amb-choices exp) (cdr exp))

#+END_SRC

#+BEGIN_SRC scheme
  ;; анализирует полученное выражение и применяет получившуюся в результате анализа
  ;; исполнительную процедуру к окружению и двум продолжениям
  (define (ambeval exp env succeed fail)
    ((analyze exp) env succeed fail))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  (define (let? exp)
    (tagged-list? exp 'let))

  (define (let->combination exp)
    (define (get-all-params exp)
      (if (null? exp)
          '()
          (cons (caar exp) (get-all-params (cdr exp)))))
    (define (get-all-exps exp)
      (if (null? exp)
          '()
          (cons (cadar exp) (get-all-exps (cdr exp)))))
    (append (list (make-lambda (get-all-params (cadr exp))
                               (cddr exp)))
            (get-all-exps (cadr exp))))

  (define (distinct? items)
    (cond ((null? items) true)
          ((null? (cdr items)) true)
          ((member (car items) (cdr items)) false)
          (else (distinct? (cdr items)))))

  (define (map fn args-list)
    (define (iter fn args-list result-list)
      (if (null? args-list)
          result-list
          (iter fn (cdr args-list) (append result-list (list (fn (car args-list)))))))
    (iter fn args-list'()))

  (define (require p)
    (if (not p) (amb)))

  (define (analyze-or exp)
    (lambda (env)
      (display "analyze-or")
      (newline)
      (display exp)
      (newline)
      (eval-or exp env)))

  (define (analyze-and exp)
    (lambda (env)
      (eval-and exp env)))

  ;; анализ самовычисляющегося выражения
  ;; передаем успешному продолжению выражение и продолжение неудачи и вычисляем
  ;; продолжения успеха в имеющемся окружении
  (define (analyze-self-evaluating exp)
    (lambda (env succeed fail)
      (succeed exp fail)))

  ;; анализ заковыченного выражения
  ;; аналогично самовычисляющемуся, только мы передаем не само заковыченное выражение, а
  ;; только его "текст"
  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env succeed fail)
        (succeed qval fail))))

  ;; анализ поиска переменной
  ;; передаем в успешное продолжение результат от вызова lookup-variable-value, которая
  ;; должна найти нам переменную. Если не найдет, то получим ошибку и никакие другие варианты
  ;; рассматривать больше не будем - прогер ошибся и использует несуществующую переменную
  (define (analyze-variable exp)
    (lambda (env succeed fail)
      (succeed (lookup-variable-value exp env)
               fail)))

  ;; анализ лямбд
  (define (analyze-lambda exp)
    ;; получаем параметры
    (let ((vars (lambda-parameters exp))
          ;; запускаем анализ тела лямбды
          (bproc (analyze-sequence (lambda-body exp))))
      (lambda (env succeed fail)
        ;; передаем в успешное продолжение созданную процедуру и продолжение неудачи
        (succeed (make-procedure vars bproc env)
                 fail))))

  (define (analyze-if exp)
    ;; анализируем предикат и ветки
    (let ((pproc (analyze (if-predicate exp)))
          (cproc (analyze (if-consequent exp)))
          (aproc (analyze (if-alternative exp))))
      ;; пинимает на вход окружение и 2 продолжения
      (lambda (env succeed fail)
        ;; передаем предикату окружение и новые продолжения
        (pproc env
               ;; новое продолжение успеха
               ;; получает на вход значение предиката и второе продолжение неудачи
               (lambda (pred-value fail2)
                 ;; если предикат true
                 (if (true? pred-value)
                     ;; передаем ветке true изначальное продолжение успеха
                     ;; и новое продолжение неудачи
                     (cproc env succeed fail2)
                     ;; передаем ветке false то же самое
                     (aproc env succeed fail2)))
               ;; продолжение неудачи при вычислении предиката
               fail))))

  ;; анализируем последовательности
  (define (analyze-sequence exps)
    ;; исполняет выражение b, если выражение a исполнилось успешно
    (define (sequentially a b)
      (lambda (env succeed fail)
        (a env
           ;; продолжение успеха при вызове a
           (lambda (a-value fail2)
             (b env succeed fail2))
           ;; продолжение неудачи при вызове a
           fail)))
    ;; цикл анализирования и выражений одного за другим, пока они не кончатся
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
          first-proc
          (loop (sequentially first-proc (car rest-procs))
                (cdr rest-procs))))
    ;; получаем исполнительные процедуры выражений
    (let ((procs (map analyze exps)))
      (if (null? procs)
          (error "Пустая последовательность -- ANALYZE"))
      (loop (car procs) (cdr procs))))

  ;; анализ определения
  (define (analyze-definition exp)
    ;; получаем имя определения
    (let ((var (definition-variable exp))
          ;; получаем исполнительную процедуру выражения
          (vproc (analyze (definition-value exp))))
      (display var)
      (newline)
      (display vproc)
      (newline)
      (lambda (env succeed fail)
        ;; если выполнение присваевомого значения успешно
        (vproc env
               (lambda (val fail2)
                 ;; определяем переменную
                 (define-variable! var val env)
                 (succeed 'ok fail2))
               ;; иначе вызываем продолжеие неудачи
               fail))))

  ;; анализ присваивания
  ;; основная проблема присваивания в данном интерпретаторе - это возможная необходимость
  ;; откатить назад присваивание, присвоив переменной прежнее значение, если общее
  ;; вычисление зашло в тупик или потерпело иную неудачу и нам необходимо вернуться в
  ;; предыдущую точку выбора
  (define (analyze-assignment exp)
    ;; сначала поступаем как при определении
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      ;; принимает окружение и 2 продолжения
      (lambda (env succeed fail)
        (display "succeed")
        (display succeed)
        (newline)
        (display "fail")
        (display fail)
        (newline)
        ;; если присваевымое выражение исполнилось успешно
        (vproc env
               ;; вызываем продолжение успеха
               (lambda (val fail2)
                 ;; сохраняем прежнее значение переменной
                 (let ((old-value
                        (lookup-variable-value var env)))
                   ;; присваеваем ей новое значение
                   (set-variable-value! var val env)
                   ;; если все успех распространился дальше, возвращаем 'ok
                   (succeed 'ok
                             ;; если где-то потерпели неудачу
                             (lambda ()
                               ;; присваиваем переменной старое значение
                               (set-variable-value! var
                                                    old-value
                                                    env)
                               ;; вызываем продолжение неудачи
                               (fail2)))))
               fail))))
  ;; анализ вызова процедур
  (define (analyze-application exp)
    ;; получаем исполнительную процедуру операнда
    (let ((fproc (analyze (operator exp)))
          ;; получаем исполнительные процедуры операндов
          (aprocs (map analyze (operands exp))))
      (lambda (env succeed fail)
        ;; если операнд вычислился успешно
        (fproc env
               ;; исполняем продолжение успеха
               (lambda (proc fail2)
                 ;; получаем список аргументов для оператора
                 (get-args aprocs
                           env
                           ;; если список успешно получен
                           (lambda (args fail3)
                             ;; применяем оператор к аргументам
                             (execute-application
                              proc args succeed fail3))
                           ;; иначе исполняем продолжение неудачи
                           fail2))
               fail))))

  ;; исполняет исполнительные процедуры аргументов вызываемой процедры и возвращает
  ;; список их значений
  (define (get-args aprocs env succeed fail)
    (if (null? aprocs)
        (succeed '() fail)
        ;; если первая исполнительная процедура выполнилась успешно
        ((car aprocs) env
         ;; продолжение успеха для этой aproc
         (lambda (arg fail2)
           ;; продолжаем исполнять остальные процедуры аргументов
           (get-args (cdr aprocs)
                     env
                     ;; и если все исполнительные процедуры были вычислены
                     ;; продолжение успеха для
                     ;; рекурсивного вызова get-args
                     (lambda (args fail3)
                       ;; соединяем их значения в список
                       (succeed (cons arg args)
                                fail3))
                     fail2))
         fail)))

  ;; исполнение вызова процедуры
  (define (execute-application proc args succeed fail)
    ;; если процедцура примитивная
    (cond ((primitive-procedure? proc)
           ;; то передаем успешному продолжению значение ее вызова и продолжение неудачи
           (succeed (apply-primitive-procedure proc args)
                    fail))
          ;; если процедура непримитив
          ((compound-procedure? proc)
           ;; получаем тело процедуры
           ;; и передаем ему (?)
           ((procedure-body proc)
            ;; новый кадр окружения
            (extend-environment (procedure-parameters proc)
                                args
                                (procedure-environment proc))
            ;; продолжения успеха и неудачи
            succeed
            fail))
          (else
           (error
            "Неизвестный тип процедуры -- EXECUTE-APPLICATION"
            proc))))

  ;; анализируем выражение amb
  (define (analyze-amb exp)
    ;; получаем исполнительные процедуры выборов amb
    (let ((cprocs (map analyze (amb-choices exp))))
      (lambda (env succeed fail)
        (define (try-next choices)
          ;; если выборы кончились - неудача
          (if (null? choices)
              (fail)
              ;; иначе первому выбору передаем окружение, продолжение успеха и неудачи
              ((car choices) env
               succeed
               ;; продолжение неудачи - это перебор остальных вариантов
               (lambda ()
                 (try-next (cdr choices))))))
        (try-next cprocs))))
#+END_SRC


управляющий цикл:
#+BEGIN_SRC scheme
  (define input-prompt ";;; Ввод Amb-Eval:")

  (define output-prompt ";;; Значение Amb-Eval:")

  (define (announce-output string)
    (newline) (display string) (newline))

  (define (user-print object)
    (if (compound-procedure? object)
        (display (list 'compound-procedure
                       (procedure-parameters object)
                       (procedure-body object)
                       '<procedure-env>))
        (display object)))

  (define (setup-environment)
    (let ((initial-env
           (extend-environment (primitive-procedure-names)
                               (primitive-procedure-objects)
                               the-empty-environment)))
      (define-variable! 'true true initial-env)
      (define-variable! 'false false initial-env)
      initial-env))

  (define the-global-environment (setup-environment))

  (define the-empty-environment '())

  (define primitive-procedures
    (list (list 'car car)
          (list 'cdr cdr)
          (list 'cons cons)
          (list 'null? null?)
          (list 'list list)
          (list '= =)
          (list '/ /)
          (list '* *)
          (list 'display display)
          (list '+ +)
          (list '- -)

          ))

  (define (driver-loop)
    (define (internal-loop try-again)
      ;; печатаем приглашение к вводу
      (prompt-for-input input-prompt)
      ;; считываем ввод
      (let ((input (read)))
        ;; если пользователь хочет попробовать вычислить данное выражение еще раз
        ;; (перебрать другие варианты), пробуем вычислить еще раз
        (if (eq? input 'try-again)
            (try-again)
            ;; иначе
            (begin
              ;; считаем, что у юзера новая задача
              (newline)
              (display ";;; Начало новой задачи ")
              ;; передадим введенному выражению глобальное окружение и 2 продолжения
              (ambeval input
                       the-global-environment
                       ;; успех ambeval
                       (lambda (val next-alternative)
                         ;; печатаем уведомление о значении
                         (announce-output output-prompt)
                         ;; печатаем само значение
                         (user-print val)
                         ;; вычисляем следующую альтернативу
                         (internal-loop next-alternative))
                       ;; неудача ambeval
                       (lambda ()
                         (announce-output
                          ";;; Нет больше значений")
                         (user-print input)
                         (driver-loop)))))))
    (internal-loop
     ;; печать ошибки, если пользователь пытается вычислить альтернативы, не
     ;; поставив задачу
     (lambda ()
       (newline)
       (display ";;; Задача не задана")
       (driver-loop))))
#+END_SRC
~Упражнение 4.50.~
Реализуйте новую особую форму ramb, которая подобна amb, однако
перебирает варианты не слева направо, а в случайном порядке.
Покажите, как такая форма может пригодиться в Лизиной задаче из упражнения 4.49

Итак, для случайного выбора выражений мы воспользуемся ранее
определенными процедурами:

#+BEGIN_SRC scheme
  (define prev-n #f)

  ;; создадим функцию, которая генерит случайные числа в заданном интервали
  ;; при этом мы следим, чтоб не выпадало подряд дважды одно и то же число
  (define (generate-number-interval min max)
    (let ((n (random (+ 1 max))))
      (cond ((eq? prev-n n) (if (< n max)
                                (begin (set! prev-n (+ prev-n 1))
                                       (+ n 1))
                                (begin (set! prev-n (- prev-n 1))
                                       (- n 1))))
            ((< n min) (begin (set! prev-n min) min))
            (else (begin (begin (set! prev-n n) n))))))
#+END_SRC

Мы будем случайным образом генерировать индекс выражения в списке и
выбирать его.

Теперьнапишем процедуру ramb.
#+BEGIN_SRC scheme

  ;; принимает индекс и список выражений
  ;; поднимает выражение с заданным индексом в car списка
  ;; возвращает новый список
  (define (bubble-exp indx exps-list)
    (define (iter indx exps-list new-exps-list)
      (if (= indx 0)
          (append (list (car exps-list))
                  (append new-exps-list (cdr exps-list)))
          (iter (- indx 1) (cdr exps-list) (append new-exps-list
                (list (car exps-list))))))
    (if (>= indx (length exps-list))
        #f
        (iter indx exps-list '())))

  (define (ramb? exp)
    (tagged-list? exp 'ramb))

  (define (ramb-choices exp)
    (cdr exp))

  (define (analyze-ramb exp)
    ;; получаем исполнительные процедуры выборов amb
    (let ((cprocs (map analyze (ramb-choices exp))))
      (lambda (env succeed fail)
        (define (try-next choices)
          ;; если выборы кончились - неудача
          (if (null? choices)
              (fail)
              ;; иначе рандомно генерируем индекс и "поднимаем" выражение с таким индексом
              ;; в car списка
              (let* ((choices-length (length choices))
                     (bubbled-choices
                      (if (= choices-length 1)
                          (list (car choices))
                          (bubble-exp (generate-number-interval 0 (- (length choices) 1))
                                      choices))))

                (set! choices bubbled-choices)
                ;; (display choices)
                ;; (display newline)
                ((car choices) env succeed
                 ;; продолжение неудачи - это перебор остальных вариантов
                 (lambda ()
                   (try-next (cdr choices)))))))
          (try-next cprocs))))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((require? exp) (analyze-require exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((if-fail? exp) (analyze-if-fail exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ((amb? exp) (analyze-amb exp))
          ((ramb? exp) (analyze-ramb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  ;;(list (ramb 1 2 3 4) (ramb 1 2 3 4))
#+END_SRC

#+BEGIN_SRC scheme
  (define (parse-word)
    (define (make-phrase phrase)
      (cond ((null? phrase) (make-phrase (list (list 'article
                                                     (ramb 'the 'a 'an)))))
            ((eq? (caar (last-pair phrase)) 'article)
             (make-phrase (append phrase (list (list 'noun (ramb 'student 'professor
                                                                 'girl 'dog
                                                                 'cat 'class))))))
            ((eq? (caar (last-pair phrase)) 'noun)
             (make-phrase (append phrase
                                  (list (list 'verb (ramb 'studies 'lectures
                                                          'eats 'sleeps))))))
            (else phrase)))
    (make-phrase '()))


  ;; (parse-word)
#+END_SRC


~Упражнение 4.51.~
Реализуйте новую разновидность присваивания permanent-set! —
присваивание, которое не отменяется при неудачах. Например, можно выбрать
два различных элемента в списке и посчитать, сколько для этого
потребовалось попыток,
следующим образом:

#+BEGIN_SRC scheme
  (define count 0)

  (define (an-element-of items)
    (require (not (null? items)))
    (amb (car items) (an-element-of (cdr items))))

  (let ((x (an-element-of '(a b c)))
        (y (an-element-of '(a b c))))
    (permanent-set! count (+ count 1))
    (require (not (eq? x y)))
    (list x y count))

  ;;; Начало новой задачи
  ;;; Значение Amb-Eval:
  (a b 2)
  ;;; Ввод Amb-Eval:
  try-again
  ;;; Значение Amb-Eval:
  (a c 3)
#+END_SRC

Какие значения были бы напечатаны, если бы мы вместо ~permanent-set!~
использовали здесь обычный ~set!~?

Итак, у нас есть ~analyse-assigment~, которая анализирует присваивания.
Она возвращает исполнительную процедуру присваивания, которое можно
откатить назад. Значит, нам просто нужно убрать этот "откат", т.е. не
сохранять прежнее значение переменной и при неудаче не откатывать ее
назад.

заливаем в обычную схему и тестим с выражением выше:
#+BEGIN_SRC scheme
  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

  (define (permanent-assignment? exp)
    (tagged-list? exp 'permanent-set!))

  (define (analyze-permanent-assignment exp)
    ;; сначала поступаем как при определении
    (let ((var (assignment-variable exp))
          (vproc (analyze (assignment-value exp))))
      ;; принимает окружение и 2 продолжения
      (lambda (env succeed fail)
        ;; если присваевымое выражение исполнилось успешно
        (vproc env
               ;; вызываем продолжение успеха
               (lambda (val fail2)
                   ;; присваеваем новое значение
                   (set-variable-value! var val env)
                   ;; если все успех распространился дальше, возвращаем 'ok
                   (succeed 'ok (lambda () (fail2))))
               fail))))

#+END_SRC


Если мы будем испольновать set! в указанном выше выражении, то count = 1,
поскольку если попытка неудачная, она как бы "не считается", при откате
назад мы будем откатывать и значение переменной, следовательно, зачтется
только удачная попытка.

~Упражнение 4.52.~
Реализуйте новую конструкцию if-fail, которая позволяет пользователю
перехватить неудачу при выполнении выражения.
If-fail принимает два выражения. Первое она выполняет как
обычно и, если вычисление успешно, возвращает его результат. Однако если
вычисление неудачно, то возвращается значение второго выражения,
как в следующем примере:

#+BEGIN_SRC scheme
  ;;; Ввод Amb-Eval:
  (if-fail (let ((x (an-element-of '(1 3 5))))
             (require (even? x))
             x)
           'all-odd)

  ;;; Начало новой задачи
  ;;; Значение Amb-Eval:
  all-odd
  ;;; Ввод Amb-Eval:

  (if-fail (let ((x (an-element-of '(1 3 5 8))))
             (require (even? x))
             x)
           'all-odd)
  ;;; Начало новой задачи
  ;;; Значение Amb-Eval:
  8
#+END_SRC

Фактически это аналог обычного ~if~, только этот ~if~ оперирует
выражениями и продолжениями.

Принимает 2 выражения. При этом второе будет являться продолжением
неудачи. А продолжение успеха - это значение первого выражения.
#+BEGIN_SRC scheme
  (define (if-fail? exp)
    (tagged-list? exp 'if-fail))

  (define (if-fail-exp exp)
    (cadr exp))

  (define (if-fail-case-false exp)
    (caddr exp))

  (define (analyze-if-fail exp)
    (let ((vproc-exp (analyze (if-fail-exp exp)))
          (vproc-false (analyze (if-fail-case-false exp))))
      (display vproc-exp)
      (newline)
      (display vproc-false)
      (newline)
      (lambda (env succeed fail)
        (vproc-exp env
                   (lambda (val fail2)
                     (succeed val (lambda ()
                                    (fail2))))
                   (lambda ()
                     (vproc-false env succeed fail))))))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((if-fail? exp) (analyze-if-fail exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))

#+END_SRC

~Упражнение 4.53.~
Если у нас есть permanent-set!, описанное в упражнении 4.51, и if-fail из
упражнения 4.52, то каков будет результат вычисления

#+BEGIN_SRC scheme

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (prime? n)
    (= n (smallest-divisor n)))

  (define (square x)
    (* x x))

  (define (an-element-of items)
    (require (not (null? items)))
    (amb (car items) (an-element-of (cdr items))))

  (define (prime-sum-pair list1 list2)
    (let ((a (an-element-of list1))
          (b (an-element-of list2)))
      (require (prime? (+ a b)))
      (list a b)))

  (let ((pairs '()))
    (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
               (permanent-set! pairs (cons p pairs))
               (amb))
             pairs))
#+END_SRC

Вывод: ~((8 35) (3 110) (3 20))~

~Упражнение 4.54.~
Если бы мы не догадались, что конструкцию require можно реализовать как
обычную процедуру с помощью amb, так что пользователь сам может
определить ее в своей недетерминистской программе, то нам пришлось бы
задать эту конструкцию в виде особой формы. Допишите следующие процедуры:

#+BEGIN_SRC scheme
  (define (require? exp) (tagged-list? exp 'require))

  (define (require-predicate exp) (cadr exp))

  (define (analyze-require exp)
    (let ((pproc (analyze (require-predicate exp))))
      (lambda (env succeed fail)
        (pproc env
               (lambda (pred-value fail2)
                 (if (not (true? pred-value))
                     (fail2)
                     (succeed 'ok fail2)))
               fail))))

  (define (analyze exp)
    (cond ((self-evaluating? exp)
           (analyze-self-evaluating exp))
          ((require? exp) (analyze-require exp))
          ((quoted? exp) (analyze-quoted exp))
          ((variable? exp) (analyze-variable exp))
          ((assignment? exp) (analyze-assignment exp))
          ((permanent-assignment? exp) (analyze-permanent-assignment exp))
          ((definition? exp) (analyze-definition exp))
          ((let? exp) (analyze (let->combination exp)))
          ((if? exp) (analyze-if exp))
          ((if-fail? exp) (analyze-if-fail exp))
          ((lambda? exp) (analyze-lambda exp))
          ((begin? exp) (analyze-sequence (begin-actions exp)))
          ((cond? exp) (analyze (cond->if exp)))
          ;; добавляем анализ для amb
          ((amb? exp) (analyze-amb exp))
          ((application? exp) (analyze-application exp))
          (else
           (error "Неизвестный тип выражения -- ANALYZE" exp))))


  (require (< (+ 3 4) (+ 1 2)))
  (require (+ (+ 3 4) (+ 1 2)))
#+END_SRC

*** Логическое программирование

~реализация запросной системы~

#+BEGIN_SRC scheme
  (define (insert! key value table)
    (let ((record (assoc key (cdr table))))
      (if record
          (set-cdr! record value)
          (set-cdr! table
                    (cons (cons key value) (cdr table)))))
    'ok)

  (define (make-table)
    (list '*table*))
#+END_SRC


#+BEGIN_SRC scheme
   (define input-prompt ";;; Ввод запроса:")
  (define output-prompt ";;; Результаты запроса:")

  (define (query-driver-loop)
    (prompt-for-input input-prompt)
    (let ((q (query-syntax-process (read))))
      (cond ((assertion-to-be-added? q)
             (add-rule-or-assertion! (add-assertion-body q))
             (newline)
             (display "Утверждение добавлено в базу данных.")
             (query-driver-loop))
            (else
             (newline)
             (display output-prompt)
             (display-stream
              (stream-map
               (lambda (frame)
                 (instantiate q
                              frame
                              (lambda (v f)
                                (contract-question-mark v))))
               (qeval q (singleton-stream '()))))
             (query-driver-loop)))))

  (define (instantiate exp frame unbound-var-handler)
    (define (copy exp)
      (cond ((var? exp)
             (let ((binding (binding-in-frame exp frame)))
               (if binding
                   (copy (binding-value binding))
                   (unbound-var-handler exp frame))))
            ((pair? exp)
             (cons (copy (car exp)) (copy (cdr exp))))
            (else exp)))
    (copy exp))

  (define (qeval query frame-stream)
    (let ((qproc (get (type query) 'qeval)))
      (if qproc
          (qproc (contents query) frame-stream)
          (simple-query query frame-stream))))

  (define (simple-query query-pattern frame-stream)
    (stream-flatmap
     (lambda (frame)
       (stream-append-delayed
        (find-assertions query-pattern frame)
        (delay (apply-rules query-pattern frame))))
     frame-stream))

  (define (conjoin conjuncts frame-stream)
    (if (empty-conjunction? conjuncts)
        frame-stream
        (conjoin (rest-conjuncts conjuncts)
                 (qeval (first-conjunct conjuncts)
                        frame-stream))))

  (define (disjoin disjuncts frame-stream)
    (if (empty-disjunction? disjuncts)
        the-empty-stream
        (interleave-delayed
         (qeval (first-disjunct disjuncts) frame-stream)
         (delay (disjoin (rest-disjuncts disjuncts)
                         frame-stream)))))

  ;; (put 'and 'qeval conjoin)
  ;; (put 'or 'qeval disjoin)

  (define (negate operands frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (stream-null? (qeval (negated-query operands)
                                (singleton-stream frame)))
           (singleton-stream frame)
           the-empty-stream))
     frame-stream))

  ;;(put 'not 'qeval negate)

  (define (lisp-value call frame-stream)
    (stream-flatmap
     (lambda (frame)
       (if (execute
            (instantiate
             call
             frame
             (lambda (v f)
               (error "Неизвестная переменная -- LISP-VALUE" v))))
           (singleton-stream frame)
           the-empty-stream))
     frame-stream))

  ;;(put 'lisp-value 'qeval lisp-value)

  (define (execute exp)
    (apply (eval (predicate exp) user-initial-environment)
           (args exp)))

  ;; (define (always-true ignore frame-stream) frame-stream)
  ;; (put 'always-true 'qeval always-true)

  (define (find-assertions pattern frame)
    (stream-flatmap (lambda (datum)
                      (check-an-assertion datum pattern frame))
                    (fetch-assertions pattern frame)))

  (define (check-an-assertion assertion query-pat query-frame)
    (let ((match-result
           (pattern-match query-pat assertion query-frame)))
      (if (eq? match-result 'failed)
          the-empty-stream
          (singleton-stream match-result))))

  (define (pattern-match pat dat frame)
    (cond ((eq? frame 'failed) 'failed)
          ((equal? pat dat) frame)
          ((var? pat) (extend-if-consistent pat dat frame))
          ((and (pair? pat) (pair? dat))
           (pattern-match (cdr pat)
                          (cdr dat)
                          (pattern-match (car pat)
                                         (car dat)
                                         frame)))
          (else 'failed)))

  (define (extend-if-consistent var dat frame)
    (let ((binding (binding-in-frame var frame)))
      (if binding
          (pattern-match (binding-value binding) dat frame)
          (extend var dat frame))))

  (define (apply-rules pattern frame)
    (stream-flatmap (lambda (rule)
                      (apply-a-rule rule pattern frame))
                    (fetch-rules pattern frame)))

  (define (apply-a-rule rule query-pattern query-frame)
    (let ((clean-rule (rename-variables-in rule)))
      (let ((unify-result
             (unify-match query-pattern
                          (conclusion clean-rule)
                          query-frame)))
        (if (eq? unify-result 'failed)
            the-empty-stream
            (qeval (rule-body clean-rule)
                   (singleton-stream unify-result))))))

  (define (rename-variables-in rule)
    (let ((rule-application-id (new-rule-application-id)))
      (define (tree-walk exp)
        (cond ((var? exp)
               (make-new-variable exp rule-application-id))
              ((pair? exp)
               (cons (tree-walk (car exp))
                     (tree-walk (cdr exp))))
              (else exp)))
      (tree-walk rule)))

  (define (unify-match p1 p2 frame)
    (cond ((eq? frame 'failed) 'failed)
          ((equal? p1 p2) frame)
          ((var? p1) (extend-if-possible p1 p2 frame))
          ((var? p2) (extend-if-possible p2 p1 frame))
          ((and (pair? p1) (pair? p2))
           (unify-match (cdr p1)
                        (cdr p2)
                        (unify-match (car p1)
                                     (car p2)
                                     frame)))
          (else 'failed)))

  (define (extend-if-possible var val frame)
    (let ((binding (binding-in-frame var frame)))
      (cond (binding
             (unify-match
              (binding-value binding) val frame))
            ((var? val)
                                          ; ***
             (let ((binding (binding-in-frame val frame)))
               (if binding
                   (unify-match
                    var (binding-value binding) frame)
                   (extend var val frame))))
            ((depends-on? val var frame)
                                          ; ***
             'failed)
            (else (extend var val frame)))))

  (define (depends-on? exp var frame)
    (define (tree-walk e)
      (cond ((var? e)
             (if (equal? var e)
                 true
                 (let ((b (binding-in-frame e frame)))
                   (if b
                       (tree-walk (binding-value b))
                       false))))
            ((pair? e)
             (or (tree-walk (car e))
                 (tree-walk (cdr e))))
            (else false)))
    (tree-walk exp))

  (define THE-ASSERTIONS the-empty-stream)

  (define (fetch-assertions pattern frame)
    (if (use-index? pattern)
        (get-indexed-assertions pattern)
        (get-all-assertions)))

  (define (get-all-assertions) THE-ASSERTIONS)

  (define (get-indexed-assertions pattern)
    (get-stream (index-key-of pattern) 'assertion-stream))

  (define (get-stream key1 key2)
    (let ((s (get key1 key2)))
      (if s s the-empty-stream)))

  (define THE-RULES the-empty-stream)

  (define (fetch-rules pattern frame)
    (if (use-index? pattern)
        (get-indexed-rules pattern)
        (get-all-rules)))

  (define (get-all-rules) THE-RULES)

  (define (get-indexed-rules pattern)
    (stream-append
     (get-stream (index-key-of pattern) 'rule-stream)
     (get-stream '? 'rule-stream)))

  (define (add-rule-or-assertion! assertion)
    (if (rule? assertion)
        (add-rule! assertion)
        (add-assertion! assertion)))

  (define (add-assertion! assertion)
    (store-assertion-in-index assertion)
    (let ((old-assertions THE-ASSERTIONS))
      (set! THE-ASSERTIONS
            (cons-stream assertion old-assertions))
      'ok))

  (define (add-rule! rule)
    (store-rule-in-index rule)
    (let ((old-rules THE-RULES))
      (set! THE-RULES (cons-stream rule old-rules))
      'ok))

  (define (store-assertion-in-index assertion)
    (if (indexable? assertion)
        (let ((key (index-key-of assertion)))
          (let ((current-assertion-stream
                 (get-stream key 'assertion-stream)))
            (put key
                 'assertion-stream
                  (cons-stream assertion
                               current-assertion-stream))))))

  (define (store-rule-in-index rule)
    (let ((pattern (conclusion rule)))
      (if (indexable? pattern)
          (let ((key (index-key-of pattern)))
            (let ((current-rule-stream
                   (get-stream key 'rule-stream)))
              (put key
                   'rule-stream
                    (cons-stream rule
                                 current-rule-stream)))))))

  (define (indexable? pat)
    (or (constant-symbol? (car pat))
        (var? (car pat))))

  (define (index-key-of pat)
    (let ((key (car pat)))
      (if (var? key) '? key)))

  (define (use-index? pat)
    (constant-symbol? (car pat)))

  (define (stream-append-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
         (stream-car s1)
         (stream-append-delayed (stream-cdr s1) delayed-s2))))

  (define (interleave-delayed s1 delayed-s2)
    (if (stream-null? s1)
        (force delayed-s2)
        (cons-stream
         (stream-car s1)
         (interleave-delayed (force delayed-s2)
                             (delay (stream-cdr s1))))))

  (define (stream-flatmap proc s)
    (flatten-stream (stream-map proc s)))

  (define (flatten-stream stream)
    (if (stream-null? stream)
        the-empty-stream
        (interleave-delayed
         (stream-car stream)
         (delay (flatten-stream (stream-cdr stream))))))

  (define (singleton-stream x)
    (cons-stream x the-empty-stream))

  (define (type exp)
    (if (pair? exp)
        (car exp)
        (error "Неизвестное выражение TYPE" exp)))

  (define (contents exp)
    (if (pair? exp)
        (cdr exp)
        (error "Неизвестное выражение CONTENTS" exp)))

  (define (assertion-to-be-added? exp)
    (eq? (type exp) 'assert!))

  (define (add-assertion-body exp)
    (car (contents exp)))

  (define (empty-conjunction? exps) (null? exps))

  (define (first-conjunct exps) (car exps))

  (define (rest-conjuncts exps) (cdr exps))

  (define (empty-disjunction? exps) (null? exps))

  (define (first-disjunct exps) (car exps))

  (define (rest-disjuncts exps) (cdr exps))

  (define (negated-query exps) (car exps))

  (define (predicate exps) (car exps))

  (define (args exps) (cdr exps))

  (define (rule? statement)
    (tagged-list? statement 'rule))

  (define (conclusion rule) (cadr rule))

  (define (rule-body rule)
    (if (null? (cddr rule))
        '(always-true)
        (caddr rule)))

  (define (query-syntax-process exp)
    (map-over-symbols expand-question-mark exp))

  (define (map-over-symbols proc exp)
    (cond ((pair? exp)
           (cons (map-over-symbols proc (car exp))
                 (map-over-symbols proc (cdr exp))))
          ((symbol? exp) (proc exp))
          (else exp)))

  (define (expand-question-mark symbol)
    (let ((chars (symbol->string symbol)))
      (if (string=? (substring chars 0 1) "?")
          (list '?
                 (string->symbol
                  (substring chars 1 (string-length chars))))
          symbol)))

  (define (var? exp)
    (tagged-list? exp '?))

  (define (constant-symbol? exp) (symbol? exp))

  (define (new-rule-application-id)
    (set! rule-counter (+ 1 rule-counter))
    rule-counter)

  (define (make-new-variable var rule-application-id)
    (cons '? (cons rule-application-id (cdr var))))

  (define (contract-question-mark variable)
    (string->symbol
     (string-append "?"
                    (if (number? (cadr variable))
                        (string-append (symbol->string (caddr variable))
                                       "-"
                                       (number->string (cadr variable)))
                        (symbol->string (cadr variable))))))

  (define (make-binding variable value)
    (cons variable value))

  (define (binding-variable binding)
    (car binding))

  (define (binding-value binding)
    (cdr binding))

  (define (binding-in-frame variable frame)
    (assoc variable frame))

  (define (extend variable value frame)
    (cons (make-binding variable value) frame))
#+END_SRC

Следующие ниже упражнения делались без проверки через систему запросов
(она описана в мане ниже и на данный момент я не знаю, как заполнять БД)

~Упражнение 4.55.~
Постройте простые запросы, которые извлекают из базы данных следующую
информацию:
а. Все сотрудники, начальником которых является Бен Битобор.
б. Имена и должности всех работников бухгалтерии.
в. Имена и адреса всех сотрудников, живущих в Сламервилле.

#+BEGIN_SRC scheme
  ;; а
  (начальник ?x (Бен Битобор))

  ;; б
  (должность ?x (бухгалтерия . ?type))

  ;; в

  (адрес ?x (Сламервилл . ?type))
#+END_SRC

~Упражнение 4.56.~
Сформулируйте составные запросы для получения следующей информации:

а. имена всех сотрудников, у которых начальником Бен Битобор, и их
адреса;
б. все сотрудники, чья зарплата ниже, чем у Бена Битобора, вместе с их
зарплатой и зарплатой
Бена;
в. все сотрудники, у которых начальник не относится к компьютерному
отделу, вместе с именем
и должностью их начальника.

#+BEGIN_SRC scheme
  ;; а
  (and (начальник ?x (Бен Битобор))
       (адрес ?x))

  ;; б
  (and (зарплата Бен Битобор ?x)
       (lisp-value > (зарплата Бен Битобор ?x) (зарплата ?y ?x))
       (зарплата ?y ?x))

  ;; в

  (and (начальник ?x (not (должность ?person (компьютеры . ?type))))
       (начальник ?x) (должность (начальник ?x)))

#+END_SRC

~Упражнение 4.57.~

Определите правило, которое говорит, что служащий 1 может заменить
служащего 2, если либо служащий 1 имеет ту же должность, что и служащий
2, либо человек с должностью служащего 1 может выполнять работу служащего
2, и при этом служащие 1 и 2 — разные люди.
Используя это правило, составьте запросы, которые находят следующую информацию:
а. все служащие, которые могут заменить П.Э. Фекта.
б. все служащие, которые могут заменить кого-то, кто получает больше их
самих, с указанием
двух зарплат.

#+BEGIN_SRC scheme
  ;; сотрудник 1 замещает сотрудника 2, если:
  (rule (может-замещать ?person1 ?person2)
        ;; это не один и тот же сотрудник
        (and (not same ?person1 ?person2)
             ;; у них либо одна должность
             (or (same (должность ?person1)
                       (должность ?person2))
                 ;; либо ложность первого может замещать должность второго
                 ;; (сеньеор может легко заменить мидла)
                 (может-замещать (должность ?person1)
                                 (должность ?person2)))))

  ;; кто может замещать Фекта
  (может-замещать ?person1 П.Э. Фект)

  ;; сотрудник 1 может замещать сотрудника 2
  (and (может-замещать ?person1 ?person2)
       ;; выводим из зп
       (зарплата ?person1)
       (зарплата ?person2)
       ;; при этом зп сотрудника 1 больше зп сотрудника 2
       (lisp-value > (зарплата ?person1)
                     (зарплата ?person2)))
#+END_SRC

~Упражнение 4.58.~
Определите правило, которое говорит, что человек «независим» в своем
отделе, если он работает в этом отделе, но у него нет начальника,
который работает в том же отделе.

В переводе на русский язык нужно создать правило "работник независим,
если он и его начальники работают в разных отделах"

#+BEGIN_SRC scheme
  (rule (независим ?person1 ?office)
        (and (not same ((начальник ?person1) ?office)
                  (?person1 ?office))))
#+END_SRC

~Упражнение 4.59.~

Бен Битобор пропускает слишком много совещаний. Опасаясь потерять из-за
этой глупой привычки работу, он решает, что с ней надо что-то делать.
Он добавляет данные обо всех еженедельных совещаниях в базу данных
«Микрошафт» в виде следующих утверждений:

(совещание бухгалтерия (понедельник 9))
(совещание администрация (понедельник 10))
(совещание компьютеры (среда 15))
(совещание администрация (пятница 13))

Все эти утверждения сообщают о совещаниях отделов. Кроме того, Бен вводит
утверждение о совещании всей компании, которое относится ко всем отделам. Все
сотрудники компании должны ходить на это совещание.

(совещание вся-компания (среда 16))

a. В пятницу утром Бен хочет спросить у базы данных, какие совещания
происходят в этот день. Как ему надо составить запрос?

ответ: (совещание ?office (пятница))

б. Лиза П. Хакер недовольна. Она считает, что намного полезнее было бы,
если бы можно было спрашивать о совещаниях, указывая свое имя.
Она пишет правило, гласящее, что совещания, куда служащему надо ходить,
это совещания всей компании и совещания отдела, где он работает.
Допишите тело Лизиного правила.

#+BEGIN_SRC scheme
  (rule (время-совещания ?person ?day-and-time)
        (and (совещание вся-компания ?day-and-time)
             (совещание (?person ?office) ?day-and-time)))
#+END_SRC

в. Лиза приходит на работу в среду и хочет узнать, на какие совещания ей
нужно идти в этот день. Если имеется правило время-совещания, то какой
запрос ей надо подать?

ответ:
(время-совещания (Лиза. П. Хакер) (среда))

~Упражнение 4.60.~
Подав запрос ~(живет-около ?person (Хакер Лиза П))~
Лиза П. Хакер может найти людей, которые живут с ней рядом, и с которыми
она вместе может ездить на работу. С другой стороны, когда она пытается
найти все пары людей, живущих друг около друга, при помощи запроса

~(живет-около ?person-1 ?person-2)~

она видит, что каждая подходящая пара людей попадается в выводе дважды,
например

~(живет-около (Хакер Лиза П) (Фект Пабло Э))~
~(живет-около (Фект Пабло Э) (Хакер Лиза П))~

Почему так происходит? Можно ли получить список людей, живущих рядом друг
с другом, в котором каждая пара появлялась бы по одному разу? Ответ объясните.

Так происходит, потому что система сама делает некоторые логические
выводы. В данном случае система сделала вывод, что если Лиза живет рядом
с Пабло, то и Пабло живет рядом с Лизой. А система выдает все варианты,
при которых утверждение будет правильным.

Формально, можно было бы дополнить правило, создав уточнение, что выводы
"ЛИза живет рядом с Пабло" и "Пабло живет рядом с Лизой" - это 2 вида
одного и того же утверждения, соответственно, если мы вывели один
вариант, то второй показывать не нужно.

~Упражнение 4.61.~
Следующие правила определяют отношение next-to, которое находит в списке
соседние элементы:

~(rule (?x next-to ?y in (?x ?y . ?u)))~
~(rule (?x next-to ?y in (?v . ?z))~
~(?x next-to ?y in ?z))~

Каков будет ответ на следующие запросы?
~(?x next-to ?y in (1 (2 3) 4))~
~(?x next-to 1 in (2 1 3 1))~

Сначала расшифруем, как сформулировано правило.
Мы последовательно проходимся по выражению и спрашиваем, стоит ли искомый
элемент рядом с другим элементом в данном выражении. И так мы проходим до
конца выражения.

В первом запросе оба элемента не указаны. Соответственно, мы должны найти
все соседние элементы:
- 1 (2 3)
- (2 3) 4

Во втором запросе один из элементов конкретизирован. Соответственно, надо
найти элементы, соседние с 1.
- 2 1
- 3 1

~Упражнение 4.62.~
Определите правила, которые реализуют операцию last-pair из упражнения
2.17, которая возвращает последнюю пару непустого списка.

Проверьте Ваши правила на таких запросах, как
(last-pair (3) ?x), (last-pair (1 2 3) ?x) и (last-pair (2 ?x)
(3)). Правильно ли Ваши правила работают с запросами вида (last-pair ?x (3))?

Итак, нам нужен проход по списку и перед тем, как он кончится, мы должны
вернуть последний элемент.

#+BEGIN_SRC scheme
  ;; заключение: последняя пара от (?x) - это (?x)
  (rule (last-pair (?x) (?x)))

  ;; ?x -  последняя пара (?y . ?v)
  (rule (last-pair (?y . ?v) ?x)
        ;; если ?x - последняя пара (?v)
        (last-pair (?v) ?x))
#+END_SRC

~Упражнение 4.63~.
Следующая база данных (см. книгу Бытия, 4) содержит генеалогию сыновей
Ады вплоть до Адама, через Каина:
(сын Адам Каин)
(сын Каин Енох)
(сын Енох Ирад)
(сын Ирад Мехиаель)
(сын Мехиаель Мафусал)
(сын Мафусал Ламех)
(жена Ламех Ада)
(сын Ада Иавал)
(сын Ада Иувал)

Сформулируйте правила, такие как «Если S сын F , а F сын G, то S внук G»
и «Если W жена M , а S сын W , то S также сын M » (предполагается, что в библейские
времена это в большей степени соответствовало истине, чем теперь).
Эти правила должны позволить системе найти внука Каина; сыновей Ламеха;
внуков Мафусала. (В упражнении 4.69 можно найти правила, с помощью
которых выводятся более сложные родственные связи.)

#+BEGIN_SRC scheme
  ;; S - сын G
  (rule (внук ?s ?g)
        ;; если S - сын F
        (and (сын ?s ?f)
             ;; если F - cын G
             (сын ?f ?g)))
  ;; s - сын m
  (rule (сын ?s ?m)
        ;; если S - сын w
        (and (сын ?s ?w)
             ;; если w - жена m
             (жена ?w ?m)))
#+END_SRC
