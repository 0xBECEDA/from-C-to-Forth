#+STARTUP: showall indent hidestars

* Chapter 1
:PROPERTIES:
:ORDERED:  t
:END:

Ниже приведена последовательность выражений. Какой результат
напечатает интерпретатор в ответ на каждое из них?
Предполагается, что выражения вводятся в том же порядке, в каком они написаны.

~Упражнение 1.1~

#+BEGIN_SRC scheme
  (+ 5 3 4)
  ;; => 12

  (- 9 1)
  ;; => 8

  (/ 6 2)
  ;; => 3

  (+ (* 2 4) (- 4 6))
  ;; => 6

  (define a 3)
  ;; => 3

  (define b (+ a 1))
  ;; => 4

  (+ a b (* a b))
  ;; => 19

  (= a b)
  ;; => 4

  (if (and (> b a) (< b (* a b)))
      b
      a)
  ;; => a (т.е. 4)

  (cond ((= a 4) 6)
        ((= b 4) (+ 6 7 a))
        (else 25))
  ;; => 6

  (+ 2
     (if (> b a)
         b
         a))
  ;; => 6

  (* (cond ((> a b) a)
           ((< a b) b)
           (else -1))
     (+ a 1))

  ;; => -5 (поскольку a = b, то сработает выражение else)

#+END_SRC

~Упражение 1.2~

Переведите выражение в префиксную форму:

5 + 4 + (2 − (3 − (6 + 4/5)))
____________________________
     3(6 − 2)(2 − 7)

(4/5 в данном контексте означает дробь "четыре пятых")

#+BEGIN_SRC scheme

    (/ (+ 4 5 (- 2 (- 3 (+ 6 (/ 4 5)))))
       (* 3 (- 6 2) (- 2 7)))

#+END_SRC

~Упражнения 1.3~

Определите процедуру, которая принимает в качестве аргументов три числа
и возвращает сумму квадратов двух бо́льших из них.
#+BEGIN_SRC scheme

  (define (sum-of-biggest-squares a b c)
    (cond ((and (> a b) (> b c)) (+ (* a a) (* b b)))
          ((and (> b a) (> c b)) (+ (* b b) (* c c)))
          ((and (> c a) (> a b)) (+ (* a a) (* c c)))
          ((and (> a c) (> b a)) (+ (* a a) (* b b)))
          ((and (> b c) (= a b)) (+ (* b b) (* c c)))
          ((and (> a b) (= c b)) (+ (* a a) (* b b)))
          (else (a b c))))

#+END_SRC

~Упражнение 1.4~

Заметим, что наша модель вычислений разрешает существование комбинаций, операторы кото-
рых — составные выражения. С помощью этого наблюдения опишите, как работает следующая
процедура:

#+BEGIN_SRC scheme

  (define (a-plus-abs-b a b)
    ((if (> b 0)
         +
         -)
     a b))

#+END_SRC

Ответ: в зависимости от того, больше b нуля или нет, форма if вернет предикат
"+" или "-", а возвращенный предикат будет применен к числам a и b.

~Упражнений 1.5~

Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком
вычислений он
работает, аппликативным или нормальным. Бен определяет такие две процедуры:

#+BEGIN_SRC scheme
  (define (p) (p))
  (define (test x y)
    (if (= x 0)
        0
        y))

  ;; Затем он вычисляет выражение

  (test 0 (p))
#+END_SRC

Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок
вычислений? Какое поведение он увидит, если интерпретатор использует нормальный
порядок?
Объясните Ваш ответ. (Предполагается, что правило вычисления особой формы if одинаково
независимо от того, какой порядок вычислений используется.
Сначала вычисляется выражение-предикат, и результат определяет,
нужно ли вычислять выражение-следствие или альтернативу.)

Ответ: мой интерпритатор использует нормальный порядок.

При аппликативном порядке интерпритор сначала подстатавит все значения в параметры
процедуры и только потом вычислит.

Процедура P - это рекурсивный выозов самой себя без конца.
аппликативный порядок даже не запустит процедуру.

Нормальный же порядок сначала вычисляет то, что вычислить можно сразу, затем выполняет
подстановку значений, если в этом есть необходимость и вычисляет новое выражение. И так
до тех пор, пока выражение не будет вычислено полностью.

Таким образом мы зациклимся навечно.

~Упражнение 1.6~

Лиза П. Хакер не понимает, почему if должна быть особой формой. «Почему нельзя просто
определить ее как обычную процедуру с помощью cond?» — спрашивает она. Лизина подруга
Ева Лу Атор утверждает, что, разумеется, можно, и определяет новую версию if:
#+BEGIN_SRC scheme

  (define (new-if predicate then-clause else-clause)
    (cond (predicate then-clause)
          (else else-clause)))

#+END_SRC

Обрадованная Лиза переписывает через new-if программу вычисления квадратного корня.
Что получится, когда Лиза попытается использовать эту процедуру для вычисления
квадратных корней? Объясните.
#+BEGIN_SRC scheme

  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (define (square x) (* x x))

  (define (average x y)
    (/ (+ x y) 2))

  (define (improve guess x)
    (average guess (/ x guess)))

  (define (good-enough? guess x)
    ;; возводим предполагаемый корень числа в квадрат,
    ;; вычитаем его из заданного числа
    ;; молучаем модуль разости
    ;; проверям, меньше ли он 0.001
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (square guess) x)) 0.001))

  ;; поиск корня с допустимой погрешностью
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (new-if (good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))

  ;; считаем, что корень любого числа = 1
  (define (sqrt x)
    ;; вызываем основную процедуру
    (sqrt-iter 1.0 x))
#+END_SRC

Ответ: при запуске процедуры с new-if я получила ошибку о переполнении стека.
Проблема в том, что срабатывают оба ветвления cond, это означает, возвращаемое
значение предиката (вызов good-enogh? в нашем случае) не интерпритируется
как "истина".


~Упражнение 1.7~
Проверка good-enough?, которую мы использовали для вычисления квадратных корней, будет
довольно неэффективна для поиска квадратных корней от очень маленьких чисел. Кроме
того, в настоящих компьютерах арифметические операции почти всегда вычисляются
с ограниченной точностью. Поэтому наш тест оказывается неадекватным и для очень больших
чисел. Альтернативный подход к реализации good-enough? состоит в том, чтобы следить,
как от одной итерации к другой изменяется guess, и остановиться, когда изменение
оказывается небольшой долей значения приближения.
Разработайте процедуру вычисления квадратного корня, которая использует такой
вариант проверки на завершение. Верно ли, что на больших и маленьких числах она
работает лучше?

Ответ: неверно, поскольку процедура вынуждена вызывать саму себя одинаковое кол-во
раз для good-enough? и my-good-enough?
#+BEGIN_SRC scheme
  (define (my-good-enough? guess x)
    (display "iteration\n")
    (< (abs (- (square (improve guess x)) (square guess))) 0.001))

  ;; вызов с определенной в мане процедурой
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))

  ;; вызов с моей процедурой
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (my-good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (improve guess x)
                   x)))
#+END_SRC

~Упражнение 1.8~

Метод Ньютона для кубических корней основан на том, что если Y является приближением к
кубическому корню из X, то мы можем получить лучшее приближение по формуле:

x/(y * y) + 2y
______________
      3

С помощью этой формулы напишите процедуру вычисления кубического корня, подобную проце-
дуре для квадратного корня.

Чтоб узнать кубический корень из X, нужно разделить X на Y в квадрате, прибавить к
получившемуся значению Y, умноженный на 2, и все это поделить на 3.

Как найти Y?

Предположим, что Y = 1.0

#+BEGIN_SRC scheme
  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (define (square x) (* x x))

  (define (cube x) (* x x x))

  ;; (define (my-average x y)
  ;;   (/ (+ x y) 3))

  (define (formula-realization guess x)
    ( / (+ (/ x (square guess )) (* 2 guess ))
        3))

  ;; (define (improve guess x)
  ;;   (average guess (/ x guess)))

  (define (good-enough? guess x)
    ;; возводим предполагаемый корень числа в квадрат,
    ;; вычитаем его из заданного числа
    ;; молучаем модуль разости
    ;; проверям, меньше ли он 0.001
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (cube (formula-realization guess x)) x))
       0.001))

  (define (my-good-enough? guess x)
    (display "iteration\n")
    (display "guess is:")
    (display guess)
    (display "\n")
    (< (abs (- (cube (formula-realization guess x)) (cube guess))) 0.001))

  ;; поиск корня с допустимой погрешностью
  (define (sqrt-iter guess x)
    ;; корень нашли?
    (if (my-good-enough? guess x)
        ;; да, вернуть корень
        guess
        ;; иначе считаем дальше
        (sqrt-iter (formula-realization guess x) x)))

  ;; считаем, что корень любого числа = 1
  (define (sqrt x)
    ;; вызываем основную процедуру
    (sqrt-iter 1.0 x))

#+END_SRC

~Упражнение 1.9~

Каждая из следующих двух процедур определяет способ сложения двух положительных целых
чисел с помощью процедур inc, которая добавляет к своему аргументу 1, и dec, которая
отнимает от своего аргумента 1.

Используя подстановочную модель, проиллюстрируйте процесс, порождаемый каждой из этих
процедур, вычислив (+ 4 5). Являются ли эти процессы итеративными или рекурсивными?

#+BEGIN_SRC scheme
  (define (+ a b)
    (if (= a 0)
        b
        (inc (+ (dec a) b))))

  (define (+ a b)
    (if (= a 0)
        b
        (+ (dec a) (inc b))))
#+END_SRC

Ответ: первая процедура - это линейный рекурсивный процесс. Вторая - итеративный
линейный процесс, он же хвостовая рекурсия.

~Упражнение 1.10~

Следующая процедура вычисляет математическую функцию, называемую функцией Аккермана.

Каковы значения следующих выражений?
(A 1 10) => 1024
(A 2 4)  => 65536
(A 3 3)  => 65536
#+BEGIN_SRC scheme
  (define (A x y)
    (display "----\n")
    (display "x:")
    (display x)
    (display "\n")
    (display "y:")
    (display y)
    (display "\n")
    (cond ((= y 0) 0)
          ((= x 0) (* 2 y))
          ((= y 1) 2)
          (else (A (- x 1)
                   (A x (- y 1))))))
#+END_SRC


Рассмотрим следующие процедуры, где A — процедура, определенная выше:
(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))

Дайте краткие математические определения функций, вычисляемых процедурами f, g и h для
положительных целых значений n.

~Шпаргалка по fib~
#+BEGIN_SRC scheme
  (define (fib n sp)
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (cond ((= n 0) (let ((answer 0))
                     (space sp)
                     (display "first\n")
                     0))
          ((= n 1) (let ((answer 1))
                     (space sp)
                     (display "second\n")
                     1))
          (else (let ((answer 10))
                  (space sp)
                  (display "else\n")
                  (+ (fib (- n 1) (+ 1 sp))
                     (fib (- n 2) (+ 1 sp)))))))

  (define (fib n sp)
    (fib-iter 1 0 n sp))

  (define (fib-iter a b count sp)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1) (+ sp 1))))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))
#+END_SRC

~Упражнение 1.11~

Функция f определяется правилом:
f (n) = n, если n < 3, и f (n) = f (n − 1) + f (n − 2) + f (n − 3), если n ≥ 3.
Напишите процедуру, вычисляющую f с помощью рекурсивного процесса.
Напишите процедуру, вычисляющую f с помощью итеративного процесса.

#+BEGIN_SRC scheme
  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (f n sp)
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (if (< n 3)
        n
        (+ (f (- n 1) (+ sp 1)) (f (- n 2) (+ sp 1)) (f (- n 3) (+ sp 1)))))

  (define (iter-f a b c count sp)
    (space sp)
    (display "A:")
    (display a )
    (display "\n")
    (space sp)
    (display "B:")
    (display b )
    (display "\n")
    (space sp)
    (display "C:")
    (display c )
    (display "\n")
    (space sp)
    (display "count:")
    (display count )
    (display "\n")
    (if (= count 0)
        c
        (iter-f (+ a b c) a b (- count 1) (+ sp 1))))

  (define (f n sp)
    (iter-f 2 1 0 n sp))
#+END_SRC

~Упражнение 1.12~

Дан треугольник Паскаля (см. стр. 57)

Все числа по краям треугольника равны 1, а каждое число внутри треугольника равно сумме
двух чисел над ним. Напишите процедуру, вычисляющую элементы треугольника Паскаля с
помощью рекурсивного процесса.

PS скорее всего имеется в виду вычисление суммы коэфициентов. Т.е. надо опираться на
следующее:
сумма биномиальных коэффициентов равна числу 2, возведенному в степень, равную
показателю степени бинома Ньютона. Т.е. сумма коэфициэнтов третьей строчки треугольника
Паскаля будет равна 8, поскольку 2 в третьей степени = 8.

 #+BEGIN_SRC scheme
   ;; n = строка треугольника Паскаля. Нумерция строк наинчается от нуля.
   ;; k = кол-во элементов в строке. Всегда равно номеру строки + 1
   (define (paskal n)
     (p n (+ n 1)))

   (define (p n k)
     (if (or (= n 0) (= n k))
         1
         (+ (p (- n 1) (- k 1))
            (p (- n 1) k))))
#+END_SRC

~Упражнение 1.13~
Докажите, что Fib(n) есть целое число, ближайшее к φ в степени n / √5,
где φ = (1 + √5)/2. Указание: пусть ψ = (1 − √5)/2.
С помощью  определения чисел Фибоначчи (см. раздел 1.2.2) и индукции докажите,
что Fib(n) = (φ в степени n − ψ в степени n )/ √5.

Определение числел Фибоначчи: каждое последующее число = сумме предыдущих двух:
F(n) = 0, если n = 0
F(n) = 1, если n = 1
F(n) = F(n - 1) + F (n - 2) во всех остальных случаях

φ = (1 + √5)/2 - это формула золотого сечения

Полагаю, что под индукцией понимается математическая индукция, т.е. если базис индукции
верен (будем считать его 1 или же P1), то верно и Pn, а значит справедливо будет
сказать, что верно Pn + 1. Иллюстрация этого утверждения - принцип домино: если упала
первая косточка домино, то упадут и все последующие.

Значит, нам нужно доказать, что
Fib(1) есть целое число, ближайшее к φ в степени 1 /√5, где φ = (1 + √5)/2  -  это
будет базис нашей индукции.

Воспользуемся определенными в ~упражнениеи 1.7~ функциями, чтоб извлекать квадратные
корни.
 #+BEGIN_SRC scheme
   (define (abs x)
     (cond ((> x 0) x)
           ((= x 0) 0)
           ((< x 0) (- x))))

   (define (square x) (* x x))

   (define (average x y)
     (/ (+ x y) 2))

   (define (improve guess x)
     (average guess (/ x guess)))

   (define (good-enough? guess x)
     ;; возводим предполагаемый корень числа в квадрат,
     ;; вычитаем его из заданного числа
     ;; молучаем модуль разости
     ;; проверям, меньше ли он 0.001
     (< (abs (- (square guess) x)) 0.001))

   ;; поиск корня с допустимой погрешностью
   (define (sqrt-iter guess x)
     ;; корень нашли?
     (if (good-enough? guess x)
         ;; да, вернуть корень
         guess
         ;; иначе считаем дальше
         (sqrt-iter (improve guess x)
                    x)))

   ;; считаем, что корень любого числа = 1
   (define (sqrt x)
     ;; вызываем основную процедуру
     (sqrt-iter 1.0 x))
#+END_SRC

#+BEGIN_SRC scheme
  (define (fib n)
    (fib-iter 1 0 n))

  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))

  ;; вычисление фи
  (define (fi)
    ( / (+ 1 (sqrt 5)) 2))

  ;; вычисление пси
  (define (psi)
    ( / (- 1 (sqrt 5)) 2))

  ;; возведение числа в степень (написано криво, я знаю)
  (define (extent x pr-x n)
    (cond ((= n 0) 1)
          ((= n 1) x)
          (else (extent (* x pr-x) pr-x (- n 1)))))

  ;; если базис индукции верен, вычисляем условие с n
  ;; внимаение, наблюдается погрешность приблиительно на 0.001, которая становится выше
  ;; на больших числах
  ;; P.S. формально вычисление условия с n не требуется, т.к. если базис индукции
  ;; верен, то и условие с n верно
  (define (proof n)
    (if (= (fib 1) ( / (- (extent (fi) (fi) 1) (extent (psi) (psi) 1)) (sqrt 5)))
        (if (or (> (- (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
                   0.1)
                (< (- (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
                   0.1)
                (= (fib n) ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5))))

            #t
            (let ((f #f))
              (display (fib n))
              (display "\n")
              (display ( / (- (extent (fi) (fi) n) (extent (psi) (psi) n)) (sqrt 5)))
              (display "\n")
              f))))

#+END_SRC


~Шпаргалка по размену монет~

#+BEGIN_SRC scheme

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (cc amount kinds-of-coins sp)
    (space sp)
    (display "amount:")
    (display amount)
    (display "\n")
    (space sp)
    (display "kinds-of-coins:")
    (display kinds-of-coins)
    (display "\n")
    (cond ((= amount 0) 1)
          ((or (< amount 0) (= kinds-of-coins 0)) 0)
          (else (+ (cc amount
                       (- kinds-of-coins 1) (+ sp 1))
                   (cc (- amount
                          (first-denomination kinds-of-coins))
                       kinds-of-coins (+ sp 1))))))

  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))

  (define (count-change amount)
    (cc amount 5 0))
#+END_SRC

~Упражнение 1.15~

Синус угла (заданного в радианах) можно вычислить, если воспользоваться приближением
sin x ≈ x при малых x и употребить тригонометрическое тождество (см. стр 59)
для уменьшения значения аргумента sin. (В этом упражнении мы будем считать, что угол
«достаточно мал», если он не больше 0.1 радиана.) Эта идея используется в следующих
процедурах:

#+BEGIN_SRC scheme
  (define (cube x) (* x x x))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (p x count sp)
    (space sp)
    (display "count:")
    (display count)
    (display "\n")
    (- (* 3 x) (* 4 (cube x))))

  (define (sine angle count)
    (if (not (> (abs angle) 0.1))
        angle
        (p (sine (/ angle 3.0) (+ 1 count)) (+ count 1) (+ sp 1))))
#+END_SRC

а. Сколько раз вызывается процедура p при вычислении (sine 12.15)?
б. Каковы порядки роста в терминах количества шагов и используемой памяти
(как функция a) для процесса,
порождаемого процедурой sine при вычислении (sine a)?

Ответ: p выполнится 5 раз.

?

~Упражнение 1.16~

Напишите процедуру, которая развивается в виде итеративного процесса и реализует
возведение в степень за логарифмическое число шагов, как fast-expt.
(Указание: используя наблюдение, что (b^n/2 )^2 = (b^2 )^n/2 ,
храните, помимо значения степени n и основания b, дополнительную переменную состояния
a, и определите переход между состояниями так, чтобы произведение ab^n от
шага к шагу не менялось. Вначале значение a берется равным 1, а ответ получается
как значение a в момент окончания процесса.
В общем случае метод определения инварианта (invariant quantity), который не изменяется
при переходе между шагами, является мощным способом размышления о построении
итеративных алгоритмов.)

Первоначальный вариант fast-expt:
o
#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b (fast-expt b (- n 1))))))
#+END_SRC

Первод задания на русский язык:
- функция должна реализовывать хвостовую рекурсию вместо линейной
- функция должна работать по тому же принципу, что и fast-expt: т.е. использовть
логарифмическое кол-во шагов, а не линейное
- функция должна использовать 3 переменные: n - значение степени,
 b - основание, а - переменная состояния
- переменная состояния - это, видимо, аккумулятор. Т.е. в нем будет накапливаться
значение, которое вернет функция. Изначально его значение = 1.
- дана подсказка: можно сначала разделить степень на два, возвести число в степень и
затем возвести результат в квадрат или сначала возвести число в квадрат, а затем
в разделенную на два степень.
- переход между состояниями, т.е. между итерациями/вызовами функции должен быть
  определен так, чтоб произведение от а*b^n не менялось (что имеется в виду?)
Возможный вариант:
- n делится на 2 на каждой итерации
- a = a * b на каждой итерации (здесь была ошибка: не на каждой итерации, а только
на последней. Т.е. акум все равно b, и только на последней итерации, когда
n = 1, мы перемножаем a и b, т.е. умножаем b на единицу, поскольку любой число
в степени 1 = то же самое число)

#+BEGIN_SRC scheme
  (define (even? n)
    (= (remainder n 2) 0))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (fast-expt b n)
    (my-fast-expt b n 1 0))

  (define (my-fast-expt b n a sp)
    (space sp)
    (display "a:")
    (display a)
    (display "\n")
    (space sp)
    (display "n:")
    (display n)
    (display "\n")
    (space sp)
    (display "b:")
    (display b)
    (display "\n")
    (cond ((= n 0) a)
          ((even? n) (my-fast-expt (* b b) (/ n 2) a (+ 1 sp)))
          (else (my-fast-expt b (- n 1) (* a b) (+ 1 sp)))))

#+END_SRC
~Упражнение 1.17~

Алгоритмы возведения в степень из этого раздела основаны на повторяющемся
умножении. Подобным же образом можно производить умножение с помощью повторяющегося
сложения.
Следующая процедура умножения (в которой предполагается,
что наш язык способен только складывать, но не умножать) аналогична процедуре expt:

#+BEGIN_SRC scheme

  (define (* a b)
    (if (= b 0)
        0
        (+ a (* a (- b 1)))))

#+END_SRC

Этот алгоритм затрачивает количество шагов, линейно пропорциональное b.
Предположим теперь, что, наряду со сложением, у нас есть операции double,
которая удваивает целое число, и halve, которая делит (четное) число на 2.
Используя их, напишите процедуру, аналогичную fast-expt,
которая затрачивает логарифмическое число шагов.

Итак, нам фактически нужно реализовать процедуру умножения, не используя само
умножение и затратить на это логарифмическое кол-во шагов.
Если "b" четное, то мы делим b на 2, затем складываем "a" с самим собой до тех пор,
пока b не станет 0 (1?).

#+BEGIN_SRC scheme

  (define (double a)
    (+ a a))

  (define (halve a)
    (/ a 2))

  (define (even? n)
    (= (remainder n 2) 0))

  (define (multiple a b)
    (cond ((or (= b 0) (= a 0)) 0)
          ((= b 1) a)
          ((= a 1) b)
          ((even? b) (multiple (double a) (halve b)))
          (else (+ a (multiple a (- b 1))))))

#+END_SRC

~Упражнение 1.18~

Используя результаты упражнений 1.16 и 1.17, разработайте процедуру, которая порождает
итеративный процесс для умножения двух чисел с помощью сложения, удвоения и деления пополам,
и затрачивает логарифмическое число шагов.

Дана подсказка: данный алгоритм называется "метод русского крестьянина" или
"египетский" метод.

#+BEGIN_SRC scheme
  (define (double a)
    (+ a a))

  (define (halve a)
    (/ a 2))

  (define (even? n)
    (= (remainder n 2) 0))

  (define (new-multiple a b accum)
    (cond ((or (= b 0) (= a 0)) accum)
          ((= b 1) (+ a accum))
          ((= a 1) b)
          ((even? b) (new-multiple (double a) (halve b) accum))
          (else (new-multiple a (- b 1) (+ a accum)))))

  (define (multiple a b)
    (new-multiple a b 0))
#+END_SRC

~Упражнение 1.19~

уществует хитрый алгоритм получения чисел Фибоначчи за логарифмическое число шагов.
Вспомните трансформацию переменных состояния a и b процесса fib-iter из раздела 1.2.2

a ← a + b и b ← a. Назовем эту трансформацию T и заметим, что n-кратное применение T ,
начиная с 1 и 0, дает нам пару Fib(n + 1) и Fib(n). Другими словами, числа Фибоначчи
получаются путем применения T^n , n-ой степени трансформации T , к паре (1,0).
Теперь рассмотрим T как частный случай p = 0, q = 1 в семействе трансформаций T pq ,
где Tpq преобразует пару (a, b) по правилу a ← bq + aq + ap, b ← bp + aq.
Покажите, что двукратное применение трансформации Tpq равносильно однократному
применению трансформации Tp ′q ′ того же типа, и вычислите p ′ и q ′ через p и q.
Это дает нам прямой способ возводить такие трансформации в квадрат, и
таким образом, мы можем вычислить T n с помощью последовательного возведения в квадрат, как в
процедуре fast-expt. Используя все эти идеи, завершите следующую процедуру, которая
дает результат за логарифмическое число шагов.

Перевод на русский язык:
есть некая трансформация, которая называется Т. Она работает так:  a ← a + b и b ← a
Му говорим что применение этой трансформации какое-то кол-во раз к числам 1 0 дает
нам в конечном итоге формулу Фибоначи, а вернее, пару Fib(n + 1) и Fib(n). Иными
словами можно сказать, что числа Фибоначчи получаются, если применить трансформацию Т
заданное кол-во раз, т.е. Т^n к паре 1 и 0.

Теперь скажем, что это частный случай в целом семестве трансформаций Tpq, где
p = 0, q = 1.
Семейство этих трансформаций работает по правилу: a ← bq + aq + ap, b ← bp + aq,
преобразовывая таким образом а и b.

Задание: у нас есть семейство трансформаций Tpq и какая-то конкретная трансформация
этого семейства Tp ′q ′, т.е. за p ′q` скрыты реальные числа.
Нам нужно вычислить их через p и q, зная, что однократное применение Tp ′q ′
будет равносильно двукратному применению Tpq, т.е. p ′и q ′ - в 2 раза больше, чем p и
q.

#+BEGIN_SRC scheme
  (define (fib n)
    (fib-iter 1 0 0 1 n 0))

  (define (space n)
    (if (< n 1)
        0
        (let ((sos 1))
          (display " ")
          (space (- n 1)))))

  (define (fib-iter a b p q count sp)
    (space sp)
    (display "a:")
    (display a)
    (display "\n")
    (space sp)
    (display "b:")
    (display b)
    (display "\n")
    (space sp)
    (display "p:")
    (display p)
    (display "\n")
    (display "q:")
    (display q)
    (display "\n")
    (space sp)
    (display "count:")
    (display count)
    (display "\n")
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (* p p) (* q q))
                     (+ (* 2 p q) (* q q))
                     (/ count 2) (+ sp 1)))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1) (+ sp 1)))))
#+END_SRC

~Упражнение 1.20~

Процесс, порождаемый процедурой, разумеется, зависит от того, по каким правилам
работает интерпретатор. В качестве примера рассмотрим итеративную процедуру gcd,
приведенную выше. Предположим, что мы вычисляем эту процедуру с помощью нормального
порядка, описанного в разделе 1.1.5.
(Правило нормального порядка вычислений для if описано в упражнении 1.5.)
Используя подстановочную модель для нормального порядка, проиллюстрируйте процесс,
порождаемый при вычислении (gcd 206 40) и укажите, какие операции вычисления остатка
действительно выполняются. Сколько операций remainder выполняется на самом деле при вычислении
(gcd 206 40) в нормальном порядке? При вычислении в аппликативном порядке?

#+BEGIN_SRC scheme

(define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

#+END_SRC

Итак, нормальный порядок вычислений будет сначала подставит все аргументы и только
потом запустит процедуру "«полная подстановка, затем редукция".If будет работать
одинаково и при аппликативном, и при нормальном порядке.

Апликативный порядок будет осуществляться:

Даны аргументы 206 и 40. Их можно сразу подставить и запустить процедуру gcd.
Сработает ветка if-a false, т.к. 40 != 0. Процедура remainder получит аргументы
206 и 40,вернет остаток от деления, запустится рекурсивный вызов gcd и так будет до тех пор, пока
b не окажется = 0. Иными словами, мы будем сначала вычислять аргументы, а затем
запускать процедуру.

При нормальном порядке аргументы remainder не будут вычислены.
Проще показать это через код:
#+BEGIN_SRC scheme
;; доделать!
  ;; первый вызов
  (gcd 206 40 ) ->

  (if (= 40 0)
      206
      (gcd 40 (remainder 206 40))) ->

  ;; рекурсивый вызов 1
  (gcd 40 (remainder 206 40)) ->

  (if (= (remainder 206 40) 0)
      40
      (gcd (remainder 206 40) (remainder 40
                                         (remainder 206 40)))) ->
  ;; рекурсивный вызов 2
  (gcd (remainder 206 40) (remainder 40
                                     (remainder 206 40))) ->

  (if (= (remainder 40
                    (remainder 206 40)) 0)

      (remainder 206 40)
      (gcd (remainder 40
                      (remainder 206 40))
           (remainder (remainder 206 40)
                      (remainder 40
                                 (remainder 206 40))))) ->




#+END_SRC



~Шпаргалка по тесту Ферма~

#+BEGIN_SRC scheme

  ;; принимает основание, степень и модуль
  (define (expmod base exp m)
    ;; если степень = 0, вернуть 1
    (cond ((= exp 0) 1)
          ;; если степень четная,
          ((even? exp)
           ;; рекурсивно вызываем с процедуру с степенью поделенной на 2,
           ;; когда достигнем дна рекурсии, отктимся назад, получим число, возведенное
           ;; в степень, деленную на 2 и возведем его в квадрат (см алгоритм fast-expt)
           ;; затем передадим результат и модуль в процедуру reminder,
           ;; которая вернет нам остаток от деления данного числа на модуль
           (remainder (square (expmod base (/ exp 2) m))
                      m))
          ;; если степень не четная, отнимаем от степени 1, рекурсивно вызываем процедуру,
          ;; достигаем дна рекурсии, откатываем назад, умножаем полученный результат
          ;; основание и передаем все в remainder, чтоб, опять же, получить остаток
          (else
           (remainder (* base (expmod base (- exp 1) m))
                      m))))

  ;; вызов exmod  с рандомным числом от "a" до n-1
  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

  ;; если тест Ферма прошел заданное кол-во раз, мы считаем, что число n простое
  (define (fast-prime? n times)
    (cond ((= times 0) #t)
          ((fermat-test n) (fast-prime? n (- times 1)))
          (else #f)))
#+END_SRC


~Упражнение 1.21~

С помощью процедуры smallest-divisor найдите наименьший делитель следующих чисел:
199, 1999, 19999.

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))
#+END_SRC

Для числа 199 - наименьший делитель само число, т.к. это простое число, для 1999 - само
число по аналогичной причине (вообще-то наименьший делитель для них должен быть 1)

Для числа 19999 ответ 7, т.к. это непростое число.


~Упражнение 1.22~
Бо́льшая часть реализаций Лиспа содержат элементарную процедуру runtime, которая
возвращает целое число, показывающее, как долго работала система (например, в
миллисекундах).

Следующая процедура timed-prime-test, будучи вызвана с целым числом n, печатает n и
проверяет, простое ли оно. Если n простое, процедура печатает три звездочки и количество
времени, затраченное на проверку.

Используя эту процедуру, напишите процедуру search-for-primes, которая проверяет на
простоту все нечетные числа в заданном диапазоне. С помощью этой процедуры найдите
наименьшие три простых числа после 1000; после 10 000; после 100 000; после 1 000 000.
Посмотрите, сколько времени затрачивается на каждое простое число.
Поскольку алгоритм проверки имеет порядок роста Θ(√n), Вам следовало бы ожидать,
что проверка на простоту чисел, близких к 10 000, занимает в 10 раз больше времени, чем
для чисел, близких к 1000. Подтверждают ли это Ваши замеры времени?
Хорошо ли поддерживают предсказание √n данные для 100 000 и 1 000 000?
Совместим ли Ваш результат с предположением, что программы на Вашей машине затрачивают
на выполнение задач время, пропорциональное числу шагов?


#+BEGIN_SRC scheme
  (define (report-prime start-time end-time)
    (display " *** ")
    (display (- (cdr end-time) (cdr start-time)))
    (display "\n")
    #t)

  (define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime start-time (gettimeofday))
        #f))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (gettimeofday)))

#+END_SRC

Отсутствует процедура runtime, пришлось заменить на такой "кустарный" таймер.
gettimeofday пару значений: секунды и микросекунды с 1.1.1970.

Добавила возвращаемые значение #t, если число простое, и #f - если нет, так легче
написать search-for-primes.

Процедура принимает диапазон, в котором должна найти простые числа, и кол-во этих
простых чисел.
#+BEGIN_SRC scheme
  (define (search-for-primes start-num end-num count)
    (cond ((= (remainder start-num 2) 0) (search-for-primes (+ 1 start-num) end-num count))
          ((or (= count 0) (= start-num end-num)) (display "finished\n"))
          ((timed-prime-test start-num)
           (search-for-primes (+ 2 start-num) end-num (- count 1)))
          (else (search-for-primes (+ 2 start-num) end-num count))))

#+END_SRC

Форматный вывод:
1009 *** 11
1013 *** 14
1019 *** 10

10007 *** 65
10009 *** 72
10037 *** 67

100003 *** 168
100019 *** 167
100043 *** 119

1000003 *** 546
1000033 *** 546
1000037 *** 679

Итак, если верить полученному выводу, то на поиск простых чисел, ближайших к
10 000, уходит не в 10 раз больше времени, чем для поиска простых чисел, ближайших к
1000. Возможно, дело во внутренней оптимизации.

Если я правильно понимаю обозначение Θ(√n), то число шагов будет расти как "квабратный
корень от n", т.е. кол-во шагов при n = 1000 приблизительно равно 32, при n = 10 000
кол-во шагов приблизительно равно 100, при n = 100 000 число шагов приблизительно 320,
при n = 1 000 000 приблизительно 1000. Т.е. чтоб найти три простых числа рядом
с 100 00 нужно в 10 раз меньше шагов чем для 1 000 000, и в 10 раз меньше шагов
нужно, чтоб найти три простых числа рядом с 1000, чем рядом 100 000.

Смотрим на вермя: для 1 000 000 понадобилось приблизительно в 10 раз больше времени,
чем для 10 000, для 100 000 понадобилось приблизительно в 10 раз больше времени, чем
для 1000.

Ответ: да, кол-во времени пропорционально кол-ву затрачиваемых шагов.

~Упражнение 1.23~
Процедура smallest-divisor в начале этого раздела проводит множество лишних проверок:
после того, как она проверяет, делится ли число на 2, нет никакого смысла проверять
делимость на другие четные числа. Таким образом, вместо последовательности
2, 3, 4, 5, 6 . . . , используемой для test-divisor, было бы лучше использовать
2, 3, 5, 7, 9 . . . .

Чтобы реализовать такое улучшение, напишите процедуру next,
которая имеет результатом 3, если получает 2 как аргумент, а иначе возвращает свой
аргумент плюс 2.
Используйте (next test-divisor) вместо (+ test-divisor 1) в
smallest-divisor.

Используя процедуру timed-prime-test с модифицированной версией smallest-divisor,
запустите тест для каждого из 12 простых чисел, найденных в упражнении 1.22.
Поскольку эта модификация снижает количество шагов проверки вдвое, Вы должны ожидать
двукратного ускорения проверки. Подтверждаются ли эти ожидания?
Если нет, то каково наблюдаемое соотношение скоростей двух алгоритмов, и как Вы
объясните то, что оно отличается от 2?

#+BEGIN_SRC scheme
  (define (square x) (* x x))

  (define (divides? a b)
    (= (remainder b a) 0))

  (define (next test-divisor)
    (if (= test-divisor 2)
        3
        (+ test-divisor 2)))

  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (next test-divisor)))))

  (define (smallest-divisor n)
    (find-divisor n 2))

  (define (prime? n)
    (= n (smallest-divisor n)))

#+END_SRC

Судя по форматному выводу, для первой тройки чисел отклонение составляет 2-3
милисекунды, со второй тройкой чисел тоже почти не изменилась, как и с третьей.
Больше всего изменения коснулись последней тройки:

было:  1000003 *** 546     стало:  1000003 *** 389
       1000033 *** 546             1000033 *** 389
       1000037 *** 679             1000037 *** 342

В принципе, мы можем сказать, что получили двухкратный прирост производительности, т.к.
я думаю, что остальные результаты мало изменились по причине хорошой оптимизации кода
внутри интерпритатора и при неоптимальной версии smallest-divisor. На более больших
числах внутренняя оптимизация работала хуже.

P.S. Проверено на более больших числах. Гипотеза не подтвердилась, процедура с
первоначальной  версией smallest-divisor работает даже быстрее, чем с
оптимальной. Возможно, это все шутки интерпритатора, т.к. процедуры сравнительно
небольшие.

~Упражнение 1.24~
Модифицируйте процедуру timed-prime-test из упражнения 1.22 так, чтобы она использовала
fast-prime? (метод Ферма) и проверьте каждое из 12 простых чисел, найденных в этом
упражнении.
Исходя из того, что у теста Ферма порядок роста Θ(log n), то какого соотношения
времени Вы бы ожидали между проверкой на простоту поблизости от 1 000 000 и
поблизости от 1000?
Подтверждают ли это Ваши данные? Можете ли Вы объяснить наблюдаемое несоответствие,
если оно есть?

#+BEGIN_SRC scheme
  (define (report-prime start-time end-time)
    (display " *** ")
    (display (- (cdr end-time) (cdr start-time)))
    (display "\n")
    #t)

  (define (start-prime-test n start-time)
    (if (fast-prime? n 5)
        (report-prime start-time (gettimeofday))
        #f))

  (define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (gettimeofday)))

#+END_SRC

Итак, если алгоритм растет как Θ(log n), то он растет медленнее, чем Θ(√n), т.к.
если n = 9, то логарифм от по основанию 3 равен 2 от 9. А вот квадратный корень из 9
= 3. 2 < 3, поэтому я думаю, что Θ(log n) растет медленнее.

Исходя из этого предположения можно сказать, что timed-prime-test, использующий метод
Ферма, должен работать быстрее, чем прежняя версия.

предыдущий результат:
1000003 *** 389
1000033 *** 389
1000037 *** 342

новый результат, если ставить проверку 5 раз:
1000003 *** 163
1000033 *** 285
1000037 *** 198


Мы видим, что новая версия работает в полтора-два раза быстрее. Схожесть на более
маленьких числах я объясняю оптимизацией интерпритатора.

~Вопросы:~
Как рассчитать время при проверке чисел для 1000 и для 1 000 000, не загружая в
интерпритатор? Понятно, что для 1000 будет меньше, но как рассчитать точно?

Метод Ферма вероятностный. Т.е. он должен отработать несколько раз, чтоб мы могли
считать его результат достаточно достоверным, в то время как prime? отрабатывает только
1 раз. Я могу запустить метод Ферма 10 000 раз, получить результат как от prime?, но
только метод Ферма в будет работать сильно дольше, хотя логарифмический рост медленнее
чем O(квадратный корень от n). И как быть тогда?


~Упражнение 1.25~
Лиза П. Хакер жалуется, что при написании expmod мы делаем много лишней работы. В конце
концов, говорит она, раз мы уже знаем, как вычислять степени, можно просто написать.

#+BEGIN_SRC scheme
  (define (expmod base exp m)
    (remainder (fast-expt base exp) m))
#+END_SRC

Права ли она? Стала бы эта процедура столь же хорошо работать при проверке простых
чисел?
Объясните.

Я думаю, что права, поскольку fast-expt работает по тому же механизму, что оригинальная
expod. Я думаю, что у обоих алгоритмов рост O(log n).
