#+STARTUP: showall indent hidestars

* Chapter 2

** Fourth element of list

С помощью car и cdr определите функцию, возвращающую 4ый элемент
списка.

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car(cdr(cdr(cdr lst)))))
#+END_SRC

[COMMENT:gmm] Пробелы облегчают понимание:

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car (cdr (cdr (cdr lst)))))
#+END_SRC

** Bigger elt

Определите функцию, принимающую два аргумента и возвращающую
наибольший.

#+BEGIN_SRC lisp
  (defun bigger (x y)
    (if (> x y)
        x
        y))
#+END_SRC

** What is X

Что может быть на месте X в следующих выражениях?

#+BEGIN_SRC lisp
  (car (X (cdr '(a (b c) d))))
  => B
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (car (cdr '(a (b c) d))))
#+END_SRC



#+BEGIN_SRC lisp
  (x 13 (/ 1 0))
  => 13
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (or 13 (/ 1 0))
#+END_SRC


#+BEGIN_SRC lisp
  (x #'list 1 nil)
  =>(1)
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (funcall #'list 1 nil))
#+END_SRC

[COMMENT:gmm] - Только без ведущего CAR

** Check list

Определите функцию, проверяющую, является ли списком хотя бы один
аргумент в списке.

[COMMENT:gmm] - Ты спрашивала, как писать тесты - вот тебе пример. Он кстати
показывает, что второй тест не проходит :)

#+BEGIN_SRC lisp
  (defun checker(lst)
    (and t (listp (car lst))))

  (assert (equal nil (checker (list 1 2 3))))

  (assert (equal t (checker '(1 (2 3) 4))))
#+END_SRC

** Dot print

Напишите итеративную и рекурсивную версию функции, которая:

*** печатает количество точек, равное заданному положительному целому числу

К сожалению, точку вывести не удалось. Вместо нее печатается слово "dot".

[COMMENT:gmm] - я поправил, обрати внимание на опциональный аргумент в рекурсивной
версии.

Итеративная версия:

#+BEGIN_SRC lisp
  (defun point (num)
    (do ((i num ( - i 1)))
        ((= i 0) 'done)
      (format t "."))
    (format t "~%"))

  (point 3)
#+END_SRC

Рекурсивная версия:

#+BEGIN_SRC lisp
  (defun point (num &optional (new t))
    (when new
      (format t "~%"))
    (format t ".")
    (if (> num 1)
        (point ( - num 1) nil)
        nil))

  (point 3)
#+END_SRC

*** возвращает количество символов "а" в заданном списке

Итерация:

#+BEGIN_SRC lisp
  (defun counter (lst obj num count)
    (let (lst2))
    (setf lst2 lst)
    (do ((i num (- i 1)))
        ((= i 0) count)
      (and (eql(car lst2) obj) (setf count(+ count 1)))
      (setf lst2 (cdr lst2))))

  (counter '(a b c a) 'a 4 0)
#+END_SRC

Рекурсия:

#+BEGIN_SRC lisp
  (defun counter (lst obj num count)
    (and (eql (car lst) obj)
         (setf count (+ count 1)))
    (setf num (- num 1))
    (if (> num 0)
        (counter (cdr lst) obj num count)
        (format t "~a ~&" count)))

  (counter '(a b c a) 'a 4 0)
#+END_SRC

Обе функции принимают списки из любого количества элементов. Нужно
только задать количество элементов аргументом num. Count в обоих
случаях - увеличивающийся счетчик, должен быть равен нулю на старте.

Пример вызова: (counter '(a b c) 'a 3 0)

[COMMENT:gmm] - а как сделать так, чтобы не задавать кол-во аргументов ~num~?


** Summing list without nil

Дано: написать функцию, суммирующую все элементы списка кроме nil.
"Некто" написал 2 функции, ни одна из которых не работает. Объяснить
причину и предложить своб версию.

а)
#+BEGIN_SRC lisp

(defun summit (lst)
(remove nil lst)
(apply #’+ lst))
#+END_SRC

Проблема в том, что remove не удаляет элемент из списка, а
формирует новый список без указанного элемента.
Поэтому nil как был в lst, так и остался.


б)
#+BEGIN_SRC lisp
 (defun summit (lst)
(let ((x (car lst)))
(if (null x)
(summit (cdr lst))
(+ x (summit (cdr lst))))))
#+END_SRC

Здесь сразу несколько проблем. Null проверяет, является ли элемент
пустым списком. Лучше бы заменить его на not. Далее меня смущает
(+ x (summit (cdr lst))). Получается, что я сначала рекурсивно вызываю
функцию только без первого элемента списка, а потом прибавляю первый
элемент. Только вот прибавляю я его ко всему списку сразу. А список -
это не число. Соответственно, получаем ошибку.

Корректная версия:

#+BEGIN_SRC lisp
(defun summit (lst)
   (let(lst2))
   (setf lst2 (remove nil lst))
 (apply #' + lst2))
#+END_SRC

* Chapter 3
** Occurrences

Напишите функцию, определяющую количество повторений (с
точки зрения eql) каждого элемента в заданном списке и
сортирующую их по убыванию встречаемости:

> (occurrences ’(a b a d a c d c a))
((A . 4) (C . 2) (D . 2) (B . 1))

Вижу два возможных решения:
a) взять каждый элемент и сравнить с каждым элементом. Если равны,
то увеличить переменную-счетчик, и так пока список не кончится.
Затем вернуть отсортированный по убываемости список.

б) Воспользоваться remove и length. Убрать, например, все элементы
A из списка, затем получить длину нового списка, сравнить со
старым. Разность длин покажет, сколько повторяющихся элементов
исчезло. Записать разность в переменную. Повторять до тех пор,
пора список не станет пустым. Вернуть новый отсортированный
список

- Устанавливаем цикл. (Проблема здесь.
Я хочу установить цикл вида: " счетчик = длина списка,
на каждой итерации счетчику приравнивается новая длина,
выполнять до тех пор, пока счетчик != 0).

- Убираем элементы.
- Сравниваем длины списка "до" и "после" remove.
- Записываем результат в переменную.
- Создаем точечную пару "элемент.количество повторений".
- Присоединяем пару к имеющемся списку пар

#+BEGIN_SRC lisp

  (defun check (lst)
    (let (lst2))
    (let (lst3))
    (let (len))
    (setf lst2 lst)
    (len (counter))
    (do (counter (length lst2))
        (setf counter (length lst2))
      ((= counter 0) 'done)
      (setf lst2 lst3)
      (setf lst2 (remove (nth 0 lst2) lst2))
      (setf len (- (length lst3) (length lst2)))))

#+END_SRC

** Member key

Почему (member ’(a) ’((a) (b))) возвращает nil?

Member должен найти элемент в списке и вернуть часть списка, которая
начинается с искомого аргумента. Если ничего найти не удалось,
возвращается nil. В основе member лежит eql, который вернет t только
в случае, если объекты соответствуют одному значению в памяти лиспа.

Но проблема в том, что в данном случае мы ищем список в списке. А для
этого нужен ключ equal.

Правильная команда:

(member '(a) '((a) (b)) :test #' equal)

** Pos+
Функция pos+ принимает список и возвращает новый, каждый
элемент которого увеличен по сравнению с исходным на его
положение в списке:

> (pos+ ’(7 5 1 4))
(7 6 3 7)

Опеределить функцию с помощью: рекурсии, итерации, mapcar.

Итак. Функция берет индекс элемента и увеличивает его
ровно на это индекс.

- узнать индекс (nth/nthcdr)
- прибавить индекс к элементу
- повторять эти две оперции, пока список не кончится
(итераия, где количество повторений = количество элементов
в списке)
