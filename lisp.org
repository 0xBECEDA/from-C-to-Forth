#+STARTUP: showall indent hidestars

* Chapter 2

** Fourth element of list

С помощью car и cdr определите функцию, возвращающую 4ый элемент
списка.

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car(cdr(cdr(cdr lst)))))
#+END_SRC

[COMMENT:gmm] Пробелы облегчают понимание:

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car (cdr (cdr (cdr lst)))))
#+END_SRC

** Bigger elt

Определите функцию, принимающую два аргумента и возвращающую
наибольший.

#+BEGIN_SRC lisp
  (defun bigger (x y)
    (if (> x y)
        x
        y))
#+END_SRC

** What is X

Что может быть на месте X в следующих выражениях?

#+BEGIN_SRC lisp
  (car (X (cdr '(a (b c) d))))
  => B
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (car (cdr '(a (b c) d))))
#+END_SRC



#+BEGIN_SRC lisp
  (x 13 (/ 1 0))
  => 13
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (or 13 (/ 1 0))
#+END_SRC


#+BEGIN_SRC lisp
  (x #'list 1 nil)
  =>(1)
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (funcall #'list 1 nil))
#+END_SRC

[COMMENT:gmm] - Только без ведущего CAR

** Check list

Определите функцию, проверяющую, является ли списком хотя бы один
аргумент в списке.

[COMMENT:gmm] - Ты спрашивала, как писать тесты - вот тебе пример. Он кстати
показывает, что второй тест не проходит :)

#+BEGIN_SRC lisp
  (defun checker(lst)
    (and t (listp (car lst))))

  (assert (equal nil (checker (list 1 2 3))))

  (assert (equal t (checker '(1 (2 3) 4))))
#+END_SRC

** Dot print

Напишите итеративную и рекурсивную версию функции, которая:

*** печатает количество точек, равное заданному положительному целому числу

К сожалению, точку вывести не удалось. Вместо нее печатается слово "dot".

[COMMENT:gmm] - я поправил, обрати внимание на опциональный аргумент в рекурсивной
версии.

Итеративная версия:

#+BEGIN_SRC lisp
  (defun point (num)
    (do ((i num ( - i 1)))
        ((= i 0) 'done)
      (format t "."))
    (format t "~%"))

  (point 3)
#+END_SRC

Рекурсивная версия:

#+BEGIN_SRC lisp
  (defun point (num &optional (new t))
    (when new
      (format t "~%"))
    (format t ".")
    (if (> num 1)
        (point ( - num 1) nil)
        nil))

  (point 3)
#+END_SRC

*** возвращает количество символов "а" в заданном списке

Итерация:

#+BEGIN_SRC lisp
  (defun counter (lst obj num count)
    (let (lst2))
    (setf lst2 lst)
    (do ((i num (- i 1)))
        ((= i 0) count)
      (and (eql(car lst2) obj) (setf count(+ count 1)))
      (setf lst2 (cdr lst2))))

  (counter '(a b c a) 'a 4 0)
#+END_SRC

Рекурсия:

#+BEGIN_SRC lisp
  (defun counter (lst obj num count)
    (and (eql (car lst) obj)
         (setf count (+ count 1)))
    (setf num (- num 1))
    (if (> num 0)
        (counter (cdr lst) obj num count)
        (format t "~a ~&" count)))

  (counter '(a b c a) 'a 4 0)
#+END_SRC

Обе функции принимают списки из любого количества элементов. Нужно
только задать количество элементов аргументом num. Count в обоих
случаях - увеличивающийся счетчик, должен быть равен нулю на старте.

Пример вызова: (counter '(a b c) 'a 3 0)

[COMMENT:gmm] - а как сделать так, чтобы не задавать кол-во аргументов ~num~?


** Summing list without nil

Дано: написать функцию, суммирующую все элементы списка кроме nil.
"Некто" написал 2 функции, ни одна из которых не работает. Объяснить
причину и предложить своб версию.

а)
#+BEGIN_SRC lisp

(defun summit (lst)
(remove nil lst)
(apply #’+ lst))
#+END_SRC

Проблема в том, что remove не удаляет элемент из списка, а
формирует новый список без указанного элемента.
Поэтому nil как был в lst, так и остался.


б)
#+BEGIN_SRC lisp
 (defun summit (lst)
(let ((x (car lst)))
(if (null x)
(summit (cdr lst))
(+ x (summit (cdr lst))))))
#+END_SRC

Здесь сразу несколько проблем. Null проверяет, является ли элемент
пустым списком. Лучше бы заменить его на not. Далее меня смущает
(+ x (summit (cdr lst))). Получается, что я сначала рекурсивно вызываю
функцию только без первого элемента списка, а потом прибавляю первый
элемент. Только вот прибавляю я его ко всему списку сразу. А список -
это не число. Соответственно, получаем ошибку.

Корректная версия:

#+BEGIN_SRC lisp
(defun summit (lst)
   (let(lst2))
   (setf lst2 (remove nil lst))
 (apply #' + lst2))
#+END_SRC

* Chapter 3

** cons
Представте следующие списки в виде ячеек:
(я представила алгоритмы их создания)
1. (a b (c d))
(list 'a 'b '(c d))
(list 'a 'b (list 'c 'd))

2. (a (b (c (d))))
(list 'a (list 'b (list 'c (list 'd))))

3. (((a b) c) d)
(list '(a b) 'c 'd)
(list (list 'a 'b) 'c 'd)

4. (a (b . c) . d)
(list 'a (cons (cons 'b 'c) 'd))


** Occurrences

Напишите функцию, определяющую количество повторений (с
точки зрения eql) каждого элемента в заданном списке и
сортирующую их по убыванию встречаемости:

> (occurrences ’(a b a d a c d c a))
((A . 4) (C . 2) (D . 2) (B . 1))

- В occur устанавливаем переменные, чтоб это не происходило
каждый раз при рекурсивном вызове compr (позже будет проверка,
является ли аргумент списком).

+ Убираем элементы (remove) и переопределяем список.
+ Сравниваем длины списка "до" и "после" remove.
+ Записываем результат в переменную.
+ Создаем точечную пару "элемент.количество повторений".
- объединяем в список
+ Сортируем (не получается)

#+BEGIN_SRC lisp

  (defun occur (lst)
    (let ((lst2))
      (setf lst2 lst)
          (let ((final_lst))
      (compr lst2 final_lst))))


  (defun compr (lst final_lst)
    (let ((lst3))
      (setf lst3 lst)
      (setf lst (remove (car lst) lst))
      (let ((len))
        (setf len (- (length lst3) (length lst)))
        (let ((new_lst))
          (setf new_lst (cons (car lst3) len))
          (format t " new list ~a ~& " new_lst)
            (setf final_lst (cons new_lst final_lst))
            (format t " final_lst ~a ~& " final_lst)
            (if (null lst)
                (new_order final_lst)
                (compr lst final_lst))))))

(defun new_order (lst)
(let ((new_lst))
    (do ((i 4 (- i 1)))
        ((= i 0) (my_sort new_lst) )
(setf new_lst (cons (car lst) new_lst))
(setf lst (remove (car lst) lst)))))

(defun my_sort (lst)
(let ((first_elm))
(setf first_elm (car lst))
(remove (car lst) lst)
(let ((final_lst))
(do ((i 3 (- i 1)))
        ((= i 0) final_lst )
(if ( < (cdr first_elm) (cdr (car lst)))
'this_branch_will_never_work
(setf final_lst (cons (car lst) final_lst)))
(setf lst (cdr lst))))))





#+END_SRC

** Member key

Почему (member ’(a) ’((a) (b))) возвращает nil?

Member должен найти элемент в списке и вернуть часть списка, которая
начинается с искомого аргумента. Если ничего найти не удалось,
возвращается nil. В основе member лежит eql, который вернет t только
в случае, если объекты соответствуют одному значению в памяти лиспа.

Но проблема в том, что в данном случае мы ищем список в списке. А для
этого нужен ключ equal.

Правильная команда:

(member '(a) '((a) (b)) :test #' equal)

** Pos+
Функция pos+ принимает список и возвращает новый, каждый
элемент которого увеличен по сравнению с исходным на его
положение в списке:

> (pos+ ’(7 5 1 4))
(7 6 3 7)

Опеределить функцию с помощью: рекурсии, итерации, mapcar.

Итак. Функция берет индекс элемента и увеличивает его
ровно на это индекс.

- узнать индекс (nth/nthcdr)
- прибавить индекс к элементу
- повторять эти две оперции, пока список не кончится
(итераия, где количество повторений = количество элементов
в списке)
