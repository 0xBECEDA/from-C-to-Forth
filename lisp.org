С помощью car и cdr определите функцию, возвращающую 4ый элемент
списка.

(defun forth (lst)
   (car(cdr(cdr(cdr lst)))))

Определите функцию, принимающую два аргумента и возвращающую
наибольший.

(defun bigger (x y)
   (if (> x y)
    x
    y))

Что может быть на месте X в следующих выражениях?
>(car (x (cdr ’(a (b c) d))))
B

> (x 13 (/ 1 0))
13

> (x #’list 1 nil)
(1)

Ответ:
(car (car (cdr '(a (b c) d))))

(or 13 (/ 1 0))

(car(funcall #'list 1 nil))

Определите функцию, проверяющую, является ли списком хотя бы один
аргумент в списке.

(defun checker(lst)
   (and t (listp (car lst))))

Напишите итеративную и рекурсивную версию функции, которая:
а) печатает количество точек, равное заданному положительному целому
    числу
б) возвращает количество символов "а" в заданном списке

а)
К сожалению, точку вывести не удалось.
Вместо нее печатается слово "dot".

Итеративная версия:
(defun point (num)
   (do ((i num ( - i 1)))
       (( = i 0) 'done)
(format t "~a ~&" 'dot)))

Рекурсивная версия:
(defun point (num)
    (format t "~a ~&" 'dot)
    (if (> num 1)
        (point ( - num 1))
        nil))
б)

Итерация:

(defun counter (lst obj num count)
    (let (lst2))
    (setf lst2 lst)
  (do ((i num (- i 1)))
      ((= i 0) count)
   (and (eql(car lst2) obj) (setf count(+ count 1)))
 (setf lst2 (cdr lst2))))

Рекурсия:
(defun counter (lst obj num count)
    (and (eql (car lst) obj) (setf count(+ count 1)))
     (setf num (- num 1))
(if (> num 0)
(counter(cdr lst) obj num count)
(format t "~a ~&" count)))

Обе функции принимают списки из любого количества элементов. Нужно
только задать количество элементов аргументом num. Count в обоих
случаях - увеличивающийся счетчик, должен быть равен нулю на старте.
Пример вызова: (counter '(a b c) 'a 3 0)


Дано: написать функцию, суммирующую все элементы списка кроме nil.
"Некто" написал 2 функции, ни одна из которых не работает. Объяснить
причину и предложить своб версию.

а)

(defun summit (lst)
(remove nil lst)
(apply #’+ lst))

Проблема в том, что remove не удаляет элемент из списка, а формирует
новый список без указанного элемента. Поэтому nil как был в lst, так и
остался.


б) (defun summit (lst)
(let ((x (car lst)))
(if (null x)
(summit (cdr lst))
(+ x (summit (cdr lst))))))

Здесь сразу несколько проблем. Null проверяет, является ли элемент
пустым списком. Лучше бы заменить его на not. Далее меня смущает
(+ x (summit (cdr lst))). Получается, что я сначала рекурсивно вызываю
функцию только без первого элемента списка, а потом прибавляю первый
элемент. Только вот прибавляю я его ко всему списку сразу. А список -
это не число. Соответственно, получаем ошибку.

Корректная версия:
(defun summit (lst)
   (let(lst2))
   (setf lst2 (remove nil lst))
 (apply #' + lst2))
