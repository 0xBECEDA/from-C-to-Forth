#+STARTUP: showall indent hidestars

* Chapter 2

** Fourth element of list

С помощью car и cdr определите функцию, возвращающую 4ый элемент
списка.

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car(cdr(cdr(cdr lst)))))
#+END_SRC

[COMMENT:gmm] Пробелы облегчают понимание:

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car (cdr (cdr (cdr lst)))))
#+END_SRC

** Bigger elt

Определите функцию, принимающую два аргумента и возвращающую
наибольший.

#+BEGIN_SRC lisp
  (defun bigger (x y)
    (if (> x y)
        x
        y))
#+END_SRC

** What is X

Что может быть на месте X в следующих выражениях?

#+BEGIN_SRC lisp
  (car (X (cdr '(a (b c) d))))
  => B
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (car (cdr '(a (b c) d))))
#+END_SRC



#+BEGIN_SRC lisp
  (x 13 (/ 1 0))
  => 13
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (or 13 (/ 1 0))
#+END_SRC


#+BEGIN_SRC lisp
  (x #'list 1 nil)
  =>(1)
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (funcall #'list 1 nil))
#+END_SRC

[COMMENT:gmm] - Только без ведущего CAR

** Check list

Определите функцию, проверяющую, является ли списком хотя бы один
аргумент в списке.

[COMMENT:gmm] - Ты спрашивала, как писать тесты - вот тебе пример. Он кстати
показывает, что второй тест не проходит :)

#+BEGIN_SRC lisp
  (defun checker(lst)
    (and t (listp (car lst))))

  (assert (equal nil (checker (list 1 2 3))))

  (assert (equal t (checker '(1 (2 3) 4))))
#+END_SRC

** Dot print

Напишите итеративную и рекурсивную версию функции, которая:

*** печатает количество точек, равное заданному положительному целому числу

К сожалению, точку вывести не удалось. Вместо нее печатается слово "dot".

[COMMENT:gmm] - я поправил, обрати внимание на опциональный аргумент в рекурсивной
версии.

Итеративная версия:

#+BEGIN_SRC lisp
  (defun point (num)
    (do ((i num ( - i 1)))
        ((= i 0) 'done)
      (format t "."))
    (format t "~%"))

  (point 3)
#+END_SRC

Рекурсивная версия:

#+BEGIN_SRC lisp
  (defun point (num &optional (new t))
    (when new
      (format t "~%"))
    (format t ".")
    (if (> num 1)
        (point ( - num 1) nil)
        nil))

  (point 3)
#+END_SRC

*** возвращает количество символов "а" в заданном списке

Итерация:

#+BEGIN_SRC lisp
  (defun counter (lst obj num count)
    (let (lst2))
    (setf lst2 lst)
    (do ((i num (- i 1)))
        ((= i 0) count)
      (and (eql(car lst2) obj) (setf count(+ count 1)))
      (setf lst2 (cdr lst2))))

  (counter '(a b c a) 'a 4 0)
#+END_SRC

Рекурсия:

#+BEGIN_SRC lisp
  (defun counter (lst obj num count)
    (and (eql (car lst) obj)
         (setf count (+ count 1)))
    (setf num (- num 1))
    (if (> num 0)
        (counter (cdr lst) obj num count)
        (format t "~a ~&" count)))

  (counter '(a b c a) 'a 4 0)
#+END_SRC

Обе функции принимают списки из любого количества элементов. Нужно
только задать количество элементов аргументом num. Count в обоих
случаях - увеличивающийся счетчик, должен быть равен нулю на старте.

Пример вызова: (counter '(a b c) 'a 3 0)

[COMMENT:gmm] - а как сделать так, чтобы не задавать кол-во аргументов ~num~?


** Summing list without nil

Дано: написать функцию, суммирующую все элементы списка кроме nil.
"Некто" написал 2 функции, ни одна из которых не работает. Объяснить
причину и предложить своб версию.

а)
#+BEGIN_SRC lisp

(defun summit (lst)
(remove nil lst)
(apply #’+ lst))
#+END_SRC

Проблема в том, что remove не удаляет элемент из списка, а
формирует новый список без указанного элемента.
Поэтому nil как был в lst, так и остался.


б)
#+BEGIN_SRC lisp
 (defun summit (lst)
(let ((x (car lst)))
(if (null x)
(summit (cdr lst))
(+ x (summit (cdr lst))))))
#+END_SRC

Здесь сразу несколько проблем. Null проверяет, является ли элемент
пустым списком. Лучше бы заменить его на not. Далее меня смущает
(+ x (summit (cdr lst))). Получается, что я сначала рекурсивно вызываю
функцию только без первого элемента списка, а потом прибавляю первый
элемент. Только вот прибавляю я его ко всему списку сразу. А список -
это не число. Соответственно, получаем ошибку.

Корректная версия:

#+BEGIN_SRC lisp
(defun summit (lst)
   (let(lst2))
   (setf lst2 (remove nil lst))
 (apply #' + lst2))
#+END_SRC

* Chapter 3

** cons
Представте следующие списки в виде ячеек:
(я представила алгоритмы их создания)
1. (a b (c d))
(list 'a 'b '(c d))
(list 'a 'b (list 'c 'd))

2. (a (b (c (d))))
(list 'a (list 'b (list 'c (list 'd))))

3. (((a b) c) d)
(list '(a b) 'c 'd)
(list (list 'a 'b) 'c 'd)

4. (a (b . c) . d)
(list 'a (cons (cons 'b 'c) 'd))

** new_union

Напишите свой вариант функции union, который сохраняет
порядок следования элементов согласно исходным спискам:

> (new-union ’(a b c) ’(b a d))
(A B C D)

Встроенный union объединяет неповторяющиеся элементы в двух
списках и при этом меняет их порядок.

- добавить элементы, которых еще нет
- сформировать список, не трогая порядок в исходном.

- new-union принимает 2 аргмента: 2 списка
- берем (car lst2) и сравниваем со всем списком (adjoin)
- добавляем элемент в список
- повторяем до тех пор, пока элементы во втором списке
не кончатся (рекурсия?)
- сортируем новый список
проблема во внешнем виде списка,
если использовать list, выглядит:
(A (B (C D)))
если использовать cons, выглядит:
(A B C . D)
если использовать list или cons в зависимости от условия,
выдает ошибку " D не последовательность "

#+BEGIN_SRC lisp

  (defun new_union (lst1 lst2)
    (setf lst1 (adjoin (car lst2) lst1))
    (setf lst2 (remove (car lst2) lst2))
    (if (null lst2)
        (new_union_sort lst1)
        (new_union lst1 lst2)))

  (defun new_union_sort (lst1)
    (let ((new_lst))
      (setf new_lst (car lst1))
      (setf lst1 (remove (car lst1) lst1))
      (let ((help_lst))
        (do ((i (length lst1) (- i 1)))
            ((= i 0) (new_union_sort_second new_lst help_lst))
          (setf help_lst (cons (car lst1) help_lst))
          (setf lst1 (cdr lst1))))))

  (defun new_union_sort_second (new_lst help_lst)
    (do ((i (length help_lst) (- i 1)))
        ((= i 0) new_lst)
          (setf new_lst (cons (car help_lst) new_lst))
      (setf help_lst (cdr help_lst))))

#+END_SRC

** Occurrences

Напишите функцию, определяющую количество повторений (с
точки зрения eql) каждого элемента в заданном списке и
сортирующую их по убыванию встречаемости:

> (occurrences ’(a b a d a c d c a))
((A . 4) (C . 2) (D . 2) (B . 1))

- В occur устанавливаем переменные, чтоб это не происходило
каждый раз при рекурсивном вызове compr (позже будет проверка,
является ли аргумент списком).

+ Убираем элементы (remove) и переопределяем список.
+ Сравниваем длины списка "до" и "после" remove.
+ Записываем результат в переменную.
+ Создаем точечную пару "элемент.количество повторений".
- объединяем в список
+ Сортируем (не получается)

#+BEGIN_SRC lisp

  (defun occur (lst)
    (let ((lst2))
      (setf lst2 lst)
          (let ((final_lst))
      (compr lst2 final_lst))))


  (defun compr (lst final_lst)
    (let ((lst3))
      (setf lst3 lst)
      (setf lst (remove (car lst) lst))
      (let ((len))
        (setf len (- (length lst3) (length lst)))
        (let ((new_lst))
          (setf new_lst (cons (car lst3) len))
          (format t " new list ~a ~& " new_lst)
            (setf final_lst (cons new_lst final_lst))
            (format t " final_lst ~a ~& " final_lst)
            (if (null lst)
                (new_order final_lst)
                (compr lst final_lst))))))

(defun new_order (lst)
(let ((new_lst))
    (do ((i 4 (- i 1)))
        ((= i 0) (my_sort new_lst) )
(setf new_lst (cons (car lst) new_lst))
(setf lst (remove (car lst) lst)))))

(defun my_sort (lst)
(let ((first_elm))
(setf first_elm (car lst))
(remove (car lst) lst)
(let ((final_lst))
(do ((i 3 (- i 1)))
        ((= i 0) final_lst )
(if ( < (cdr first_elm) (cdr (car lst)))
'this_branch_will_never_work
(setf final_lst (cons (car lst) final_lst)))
(setf lst (cdr lst))))))





#+END_SRC

** Member key

Почему (member ’(a) ’((a) (b))) возвращает nil?

Member должен найти элемент в списке и вернуть часть списка, которая
начинается с искомого аргумента. Если ничего найти не удалось,
возвращается nil. В основе member лежит eql, который вернет t только
в случае, если объекты соответствуют одному значению в памяти лиспа.

Но проблема в том, что в данном случае мы ищем список в списке. А для
этого нужен ключ equal.

Правильная команда:

(member '(a) '((a) (b)) :test #' equal)

** Pos+
Функция pos+ принимает список и возвращает новый, каждый
элемент которого увеличен по сравнению с исходным на его
положение в списке:

> (pos+ ’(7 5 1 4))
(7 6 3 7)

Опеределить функцию с помощью: рекурсии, итерации, mapcar.

Итеративная версия:

#+BEGIN_SRC lisp

  (defun pos+ (lst)
    (let ((indx))
      (setf indx 0)
      (let ((new_lst))
        (do ((i (length lst) (- i 1)))
            ((= i 0) (pos_sort new_lst))
          (setf new_lst (cons (+ indx (car lst)) new_lst ))
          (setf lst (cdr lst))
          (setf indx (+ indx 1))))))

  (defun pos_sort (lst)
    (let ((final_lst))
      (do ((i (length lst) (- i 1)))
          ((= i 0) final_lst)
        (setf final_lst (cons (car lst) final_lst))
        (setf lst (cdr lst)))))

#+END_SRC

Версия с mapcar:

#+BEGIN_SRC lisp
  (defun indx+ (num)
    (let ((indx_lst))
      (setf num (- num 1))
      (do ((i num  (- i 1)))
          ((< i 0) indx_lst)
        (setf indx_lst (cons num indx_lst))
        (setf num (- num 1)))))

  (defun mapcar_pos+ (lst)
    (let ((indx_lst))
      (setf indx_lst (indx+ (length lst)))
      (mapcar #' + lst indx_lst)))

#+END_SRC
