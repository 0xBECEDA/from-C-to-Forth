#+STARTUP: showall indent hidestars


* Chapter 2

** Fourth element of list

С помощью car и cdr определите функцию, возвращающую 4ый элемент
списка.

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car(cdr(cdr(cdr lst)))))
#+END_SRC

[COMMENT:gmm] Пробелы облегчают понимание:

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car (cdr (cdr (cdr lst)))))
#+END_SRC

** Bigger elt

Определите функцию, принимающую два аргумента и возвращающую
наибольший.

#+BEGIN_SRC lisp
  (defun bigger (x y)
    (if (> x y)
        x
        y))
#+END_SRC

** What is X

Что может быть на месте X в следующих выражениях?

#+BEGIN_SRC lisp
  (car (X (cdr '(a (b c) d))))
  => B
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (car (cdr '(a (b c) d))))
#+END_SRC



#+BEGIN_SRC lisp
  (x 13 (/ 1 0))
  => 13
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (or 13 (/ 1 0))
#+END_SRC


#+BEGIN_SRC lisp
  (x #'list 1 nil)
  =>(1)
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (funcall #'list 1 nil))
#+END_SRC

[COMMENT:gmm] - Только без ведущего CAR

** Check list

Определите функцию, проверяющую, является ли списком хотя бы один
аргумент в списке.

[COMMENT:gmm] - Ты спрашивала, как писать тесты - вот тебе пример. Он кстати
показывает, что второй тест не проходит :)

#+BEGIN_SRC lisp
  (defun checker(lst)
    (and t (listp (car lst))))

  (assert (equal nil (checker (list 1 2 3))))

  (assert (equal t (checker '(1 (2 3) 4))))
#+END_SRC

** Dot print

Напишите итеративную и рекурсивную версию функции, которая:

*** печатает количество точек, равное заданному положительному целому числу

К сожалению, точку вывести не удалось. Вместо нее печатается слово "dot".

[COMMENT:gmm] - я поправил, обрати внимание на опциональный аргумент в рекурсивной
версии.

Итеративная версия:

#+BEGIN_SRC lisp
  (defun point (num)
    (do ((i num ( - i 1)))
        ((= i 0) 'done)
      (format t "."))
    (format t "~%"))

  (point 3)
#+END_SRC

Рекурсивная версия:

#+BEGIN_SRC lisp
  (defun point (num &optional (new t))
    (when new
      (format t "~%"))
    (format t ".")
    (if (> num 1)
        (point ( - num 1) nil)
        nil))

  (point 3)
#+END_SRC

*** возвращает количество символов "а" в заданном списке

Итерация:

#+BEGIN_SRC lisp
  (defun counter (lst obj num count)
    (let (lst2))
    (setf lst2 lst)
    (do ((i num (- i 1)))
        ((= i 0) count)
      (and (eql(car lst2) obj) (setf count(+ count 1)))
      (setf lst2 (cdr lst2))))

  (counter '(a b c a) 'a 4 0)
#+END_SRC

Рекурсия:

#+BEGIN_SRC lisp
  (defun counter (lst obj num count)
    (and (eql (car lst) obj)
         (setf count (+ count 1)))
    (setf num (- num 1))
    (if (> num 0)
        (counter (cdr lst) obj num count)
        (format t "~a ~&" count)))

  (counter '(a b c a) 'a 4 0)
#+END_SRC

Обе функции принимают списки из любого количества элементов. Нужно
только задать количество элементов аргументом num. Count в обоих
случаях - увеличивающийся счетчик, должен быть равен нулю на старте.

Пример вызова: (counter '(a b c) 'a 3 0)

[COMMENT:gmm] - а как сделать так, чтобы не задавать кол-во аргументов ~num~?


** Summing list without nil

Дано: написать функцию, суммирующую все элементы списка кроме nil.
"Некто" написал 2 функции, ни одна из которых не работает. Объяснить
причину и предложить своб версию.

а)
#+BEGIN_SRC lisp

(defun summit (lst)
(remove nil lst)
(apply #’+ lst))
#+END_SRC

Проблема в том, что remove не удаляет элемент из списка, а
формирует новый список без указанного элемента.
Поэтому nil как был в lst, так и остался.


б)
#+BEGIN_SRC lisp
 (defun summit (lst)
(let ((x (car lst)))
(if (null x)
(summit (cdr lst))
(+ x (summit (cdr lst))))))
#+END_SRC

Здесь сразу несколько проблем. Null проверяет, является ли элемент
пустым списком. Лучше бы заменить его на not. Далее меня смущает
(+ x (summit (cdr lst))). Получается, что я сначала рекурсивно вызываю
функцию только без первого элемента списка, а потом прибавляю первый
элемент. Только вот прибавляю я его ко всему списку сразу. А список -
это не число. Соответственно, получаем ошибку.

Корректная версия:

#+BEGIN_SRC lisp
(defun summit (lst)
   (let(lst2))
   (setf lst2 (remove nil lst))
 (apply #' + lst2))
#+END_SRC

* Chapter 3

** cons
Представте следующие списки в виде ячеек:
(я представила алгоритмы их создания)
1. (a b (c d))
(list 'a 'b '(c d))
(list 'a 'b (list 'c 'd))

2. (a (b (c (d))))
(list 'a (list 'b (list 'c (list 'd))))

3. (((a b) c) d)
(list '(a b) 'c 'd)
(list (list 'a 'b) 'c 'd)

4. (a (b . c) . d)
(list 'a (cons (cons 'b 'c) 'd))

** new_union

Напишите свой вариант функции union, который сохраняет
порядок следования элементов согласно исходным спискам:

> (new-union ’(a b c) ’(b a d))
(A B C D)

Встроенный union объединяет неповторяющиеся элементы в двух
списках и при этом меняет их порядок.

- добавить элементы, которых еще нет
- сформировать список, не трогая порядок в исходном.

- new-union принимает 2 аргмента: 2 списка
- берем (car lst2) и сравниваем со всем списком
- добавляем элемент в список
- повторяем до тех пор, пока элементы во втором списке
не кончатся

#+BEGIN_SRC lisp

  (defun new_union (lst1 lst2)
    (let ((new_lst))
      (let ((double_lst))
        (setf double_lst lst1)
        (do ((i (length lst2) (- i 1)))
            ((= i 0) (append double_lst new_lst))
          (if (not (member (car lst2) lst1))
              (setf new_lst ( append new_lst (list(car lst2))))
              nil)
          (setf lst2 (cdr lst2))))))


#+END_SRC

** Occurrences

Напишите функцию, определяющую количество повторений (с
точки зрения eql) каждого элемента в заданном списке и
сортирующую их по убыванию встречаемости:

> (occurrences ’(a b a d a c d c a))
((A . 4) (C . 2) (D . 2) (B . 1))

- В occur устанавливаем переменные, чтоб это не происходило
каждый раз при рекурсивном вызове compr (позже будет проверка,
является ли аргумент списком).

+ Убираем элементы (remove) и переопределяем список.
+ Сравниваем длины списка "до" и "после" remove.
+ Записываем результат в переменную.
+ Создаем точечную пару "элемент.количество повторений".
- объединяем в список
+ Сортируем

#+BEGIN_SRC lisp

  (defun occur (lst)
    (let ((lst2))
      (setf lst2 lst)
      (let ((final_lst))
        (compr lst2 final_lst))))


  (defun compr (lst final_lst)
    (let ((lst3))
      (setf lst3 lst)
      (setf lst (remove (car lst) lst))
      (let ((len))
        (setf len (- (length lst3) (length lst)))
        (let ((new_lst))
          (setf new_lst (cons (car lst3) len))
          (setf final_lst (cons new_lst final_lst))
          (if (null lst)
              (new_order final_lst)
              (compr lst final_lst))))))

  (defun new_order (lst)
    (let ((new_lst))
      (do ((i 4 (- i 1)))
          ((= i 0) (my_sort new_lst ))
        (setf new_lst (cons (car lst) new_lst))
        (setf lst (cdr lst)))))

  (defun my_sort (lst)
    (let ((first_elm))
      (let ((final_lst))
        (setf first_elm (car lst))
        (setf lst (cdr lst))
        (do ((i 3 (- i 1)))
            ((= i 0) (cons first_elm final_lst ))
          (if ( < (cdr first_elm) (cdr (car lst)))
              nil
              (setf final_lst (cons (car lst) final_lst)))
          (setf lst (cdr lst))))))


#+END_SRC

** Member key

Почему (member ’(a) ’((a) (b))) возвращает nil?

Member должен найти элемент в списке и вернуть часть списка, которая
начинается с искомого аргумента. Если ничего найти не удалось,
возвращается nil. В основе member лежит eql, который вернет t только
в случае, если объекты соответствуют одному значению в памяти лиспа.

Но проблема в том, что в данном случае мы ищем список в списке. А для
этого нужен ключ equal.

Правильная команда:

(member '(a) '((a) (b)) :test #' equal)

** Pos+
Функция pos+ принимает список и возвращает новый, каждый
элемент которого увеличен по сравнению с исходным на его
положение в списке:

> (pos+ ’(7 5 1 4))
(7 6 3 7)

Опеределить функцию с помощью: рекурсии, итерации, mapcar.

Итеративная версия:

#+BEGIN_SRC lisp

  (defun pos+ (lst)
    (let ((indx))
      (setf indx 0)
      (let ((new_lst))
        (do ((i (length lst) (- i 1)))
            ((= i 0) (pos_sort new_lst))
          (setf new_lst (cons (+ indx (car lst)) new_lst ))
          (setf lst (cdr lst))
          (setf indx (+ indx 1))))))

  (defun pos_sort (lst)
    (let ((final_lst))
      (do ((i (length lst) (- i 1)))
          ((= i 0) final_lst)
        (setf final_lst (cons (car lst) final_lst))
        (setf lst (cdr lst)))))

#+END_SRC

Версия с mapcar:

#+BEGIN_SRC lisp
  (defun indx+ (num)
    (let ((indx_lst))
      (setf num (- num 1))
      (do ((i num  (- i 1)))
          ((< i 0) indx_lst)
        (setf indx_lst (cons num indx_lst))
        (setf num (- num 1)))))

  (defun mapcar_pos+ (lst)
    (let ((indx_lst))
      (setf indx_lst (indx+ (length lst)))
      (mapcar #' + lst indx_lst)))

#+END_SRC

Рекурсивная версия:

#+BEGIN_SRC lisp
  (defun rec_pos+ (lst)
    (let ((indx))
      (setf indx 0)
      (let ((new_lst))
        (rec lst indx new_lst))))

  (defun rec (lst indx new_lst)
    (setf new_lst (cons (+ indx (car lst)) new_lst))
    (setf indx (+ indx 1))
    (setf lst (cdr lst))
    (if (> (length lst) 0)
        (rec lst indx new_lst)
        (rec_pos_sort new_lst)))

  (defun rec_pos_sort (lst)
    (let ((final_lst))
      (do ((i (length lst) (- i 1)))
          ((= i 0) final_lst)
        (setf final_lst (cons (car lst) final_lst))
        (setf lst (cdr lst)))))

#+END_SRC


** show dots

Определите функцию, печатающую заданный список в точечной
нотации:

(showdots ’(a b c))
(A . (B . (C . NIL)))
NIL

- невозможно объединить "с" и nil в точечную пару.

#+BEGIN_SRC lisp
  (defun showdots (lst)
    (if (null lst)
        "NIL"
        (format nil "(~A . ~A)"
                (car lst)
                (showdots (cdr lst)))))

#+END_SRC

** new car and cdr
Определить cons, length и member без ключей, для списков, исходя
из аксиомы, что car указывает на остаток списка, а cdr - на его
начало.

#+BEGIN_SRC lisp
  (defun my-cons (a b)
    (cons a b))

  (assert (equal (cons 'a 'b) (my-cons 'a 'b)))

  (defun my-length (lst)
    (if (null lst)
        0
        (+ 1 (my-length (cdr lst)))))

  (assert (equal 3 (my-length '(a b c))))

  (defun my-member (elt lst)
    (if (equal elt (car lst))
        lst
        (if (null lst)
            nil
            (my-member elt (cdr lst)))))

  (assert (equal '(a b) (my-member 'a '(c d a b))))
  (assert (equal nil (my-member 'a '(c d b))))
#+END_SRC

#+BEGIN_SRC lisp

(defun my_car (lst)
(cdr lst))

#+END_SRC

CONS:

#+BEGIN_SRC c


  # define TRUE FALSE
#+END_SRC

** my_compress
Измените программу на рисунке 3.6 (стр. книги 54) так, чтоб она
создавала меньшее количество ячеек.
Подсказка: используйте точечные пары.

- дублиурем исходный список
- берем первый элемент и удаляем его из всего списка (remove)
- сравниваем длины списка-дубля и текущего списка
- записываем разность в len
- формируем точечную пару из текущего элемента и len
- заносим пару в список

Фактически это то же самое, что я делаю в задании "occurrences".
Только без сортировки списка.

#+BEGIN_SRC lisp

  (defun my_compress (lst)
    (let ((final_lst))
      (my_compr lst final_lst)))

  (defun my_compr (lst final_lst)
    (let ((lst2))
      (setf lst2 lst)
      (setf lst (remove (car lst) lst))
      (let ((len))
        (setf len (- (length lst2) (length lst)))
        (let ((new_lst))
          (setf new_lst (cons (car lst2) len))
          (setf final_lst (cons new_lst final_lst))
          (if (null lst)
              final_lst
              (my_compr lst final_lst))))))

#+END_SRC
** long path

Напишите программу, которая ищет самый длинный путь в сети,
не содержащий повторений. Подсказка: можно использовать циклы.

Дана сеть: '((a b c) (b c) (c d))

Итак, самый длинный путь - это путь, при котором проходится каждый
узел до искомого. То есть, если мне нужен узел "d",
то вместо того, чтоб идти "a -> c -> d", я пойду
"a -> b -> c -> d".

Предположим, мы используем (рекурсию). Проходим по каждому узлу
сети, пока не встретим искомый. Пройденные узлы сохраняем в путь.
Если узел уже встречался, значит, не включаем его в путь.

Функция принимает 3 параметра: начальную конечную точку и сеть.
Здесь мы создаем пустой список, чтоб хранить наш путь
и оборачиваем начальную точку в список. Затем вызываем фунцию bfs.

#+BEGIN_SRC lisp

(defun longest-path (start end net)
(let ((final_path))
(bfs end (list (list start)) net final_path)))

#+END_SRC

Здесь мы будем искать нашу конечную точку и сохранять все
пройденные узлы в final_lst, при условии, что они не повторяются.

#+BEGIN_SRC lisp

  (defun bfs (end queue net final_lst)
    (format t " BFS end ~a queue ~a  net ~a ~&" end queue net)
    (if (null queue)
        nil
        (let ((path (car queue)))
          (let ((node (car path)))
            (format t " BFS path ~a ~& " path)
            (if (eql node end)
                (reverse final_lst)
                (format t " final_lst ~a ~&"
            (check-list node final_lst)))
            (bfs end
                 (append (cdr queue)
                         (new-paths path node net))
                 net final_lst)))))

#+END_SRC

#+BEGIN_SRC lisp

(defun check-list (node final_lst)
 (format t " CHECK_LIST node ~a final_lst ~a ~& " node final_lst)
(let ((local_lst))
(setf local_lst final_lst)
(if (not(member node final_lst))
(setf local_lst (cons node final_lst))
nil)
(format t "local_lst check ~a ~&" local_lst ))

#+END_SRC

#+BEGIN_SRC lisp

  (defun new-paths (path node net)
(format t "NEW-PATHS path ~a node ~a net ~a ~&" path node net)
    (mapcar #'(lambda (n)
                (cons n path))
              (cdr (assoc node net))))

#+END_SRC

* chapter 4

**  turn array

Определите функцию, поворачивающую квадратный массив
(массив с размерност­ми (n n)) на 90 градусов по часовой стрелке.


Итак, функция принимает квадратный двухмерный массив.
При этом мы не знаем, будет это квадрат 2x2 или 100x100. Значит, нам
нужно выяснить сначала размер размерностей.

Для этого понадобится array-dimensions с нашим массивом в качестве
аргумента. Array-demensions вернет список целых чисел, представляющих
все размерности массива. Эти значения станут счетчиками для наших
циклов.

В циклах мы будет проходить по массиву и копировать его значения в
другой массив, пересчитывая координаты. ВОт второй массив мы и
вернем.

Внешний цикл отвечает за проход по горизонтали и перезапуск
внутреннего цикла, который отвечает за проход по вертикали. Это
обеспечит проход по новому массиву.

Вопрос! как получить координаты элементов старого массива?

- возможный вариант: пройти по старому массиву, создать список из его
  элементов, и уже из него переносить элементы в новый массив

Запуск:

(turn_arr (make-array '(2 2) :initial-contents '((a b) (c d))))

#+BEGIN_SRC lisp

  (defun turn_arr (array)
    (let ((lst_dim (array-dimensions array)))
      (let ((new_arr (make-array lst_dim :initial-element nil)))
        (format t "new _arr ~a ~&" new_arr)
        (let ((arr_lst))
          (do ((hor 0 (+ hor 1)))
              ((>= hor (nth 0 lst_dim)))
            (do ((ver 0 (+ ver 1)))
                ((>= ver (nth 0 lst_dim)) arr_lst)
              (setf arr_lst (cons (aref array hor ver) arr_lst))))
          (setf arr_lst (reverse arr_lst))
          (format t "~a ~&" arr_lst)
          (let ((indx 0))
            (do ((ver (- (nth 0 lst_dim) 1) (- ver 1)))
                ((< ver 0) new_arr)
              (format t " ver ~a ~& " ver)
              (do ((hor 0 (+ hor 1)))
                  ((>= hor (nth 0 lst_dim)))
                (format t "new_arr ~a ~&" new_arr)
                (setf (aref new_arr hor ver) (nth indx arr_lst))
                (format t "~a | ~a | ~a ~& " indx (nth indx arr_lst) hor)
                (setf indx (+ indx 1))
                (format t "new_arr ~a ~&" new_arr)
                )))))))


  (assert (equal '(a b c d)
                 (turn_arr (make-array '(2 2) :initial-contents '((a b) (c d))))))
#+END_SRC

** new copy-list and reverse

Copy-list

Написать свой copy-list и reverse для списков с помощью reduce.
Сначала я превращаю обычный список в список списков
'(a b c) -> ((A) (B) (C)), а затем использую append, чтоб скопировать
список, придав ему изначальный вид.

Проблема в том, что данный метод не работает для ассоциативных
списков. Список вида '((1. 2) (3. 4)) становится ((1 2) (3 4)),
а список вида '((1 . 2) . 3) вызывает ошибку
" 3 не является последовательностью ".

Запускать как (my_copy_list '(a b c))

#+BEGIN_SRC lisp

  (defun my_copy_list (lst)
    (let ((new_lst))
      (do ((i (length lst)  (- i 1)))
          ((= i 0) new_lst)
        (setf new_lst (cons (list (car lst)) new_lst))
        (setf lst (cdr lst)))
      (setf new_lst (reverse new_lst))
        (reduce #'(lambda (a b)
                     (append a b))
                     new_lst)))

#+END_SRC


My-reverse абсолютно аналогичен my_copy_list, за исключением того, что
после выполнения цикла do список не переворачивается с помощью
reverse. Для ассоциативных списоков эта функция так же не годится.

#+BEGIN_SRC lisp

  (defun my_reverse (lst)
    (let ((new_lst))
      (do ((i (length lst)  (- i 1)))
          ((= i 0) new_lst)
        (setf new_lst (cons (list (car lst)) new_lst))
        (setf lst (cdr lst)))
      (reduce #'(lambda (a b)
                  (append a b))
              new_lst)))

#+END_SRC
** tree

Определите структуру для дерева, каждый узел котоого помимо некоторых
данных имеет трех потомков.

Опеределите функцию, которая копирует такое дерево.
Опеределите функцию, которая принимает такое дерево и объект и
возвращает истину, если объект встречается хотя бы в одном узле
дерева.

Для начала определяем структуру узла. Затем пишем функцию, которая
создаст нам такое дерево.

Элементы нашего дерева - цвета. Цвет - это список из 3х значений
RGB. Цвета деляется на ветки по преобладанию одного из трех цветов в
них.

Проверяем, пустое ли дерево. Если пустое, то создаем узел. Если же
нет, то выгружаем поле color из корня (там хранятся все три значения
rgb), выгружаем из объекта и color цвета в соответствующие переменные
(так легче ориентироваться в коде), затем последовательно сравниваем:

1.значение поля r/g b объекта больше значения поля r/g/b корня?
-Да! Тогда двигаемся по выбранной ветке до листа и создаем узел.

Если
сравнили все три поля, но они одно из них не больше, то потом
проверяется кейс
2. значение поля r/g b объекта = значению поля r/g/b корня?

-Да! Тогда двигаемся по выбранной ветке до листа и создаем узел.

3. Если уж и равенство не сработало, тогда просто сравниваем rgb
   объекта между собой. Элемент-победитель определяет ветку.

#+BEGIN_SRC lisp

  (defstruct node
    color (r nil) (g nil) (b nil))

  (defun make_bst (obj bst >)
    (if (null bst)
        (make-node :color obj :r nil :g nil :b nil)
        ; выгружаем необходимые переменные
        (let ((color (node-color bst)))
        ;  (format t " color ~a ~& " color)
          (let ((red_obj (car obj)))
            (let ((red_node))
              (setf red_node (car color))
              (let ((green_obj))
                (setf green_obj (nth 1 obj))
                (let ((green_node))
                  (setf green_node (nth 1 color))
                  (let ((blue_obj))
                    (setf blue_obj (nth 2 obj))
                    (let ((blue_node))
                      (setf blue_node (nth 2 color))
                     ; (format t " Obj: R ~a G ~a B ~a | Node: R ~a G ~a B ~a ~&"
                     ;         red_obj green_obj blue_obj
                     ;         red_node green_node blue_node)
                      ; приступаем к сравнению по принципу ">"
                      (if ( > red_obj red_node)
                          (progn
                        ;    (format t " red_obj  ~a > red_node ~a ~& "
                        ;            red_obj red_node)
                            (make-node
                             :color color
                             :r (make_bst obj (node-r bst) >)
                             :g (node-g bst)
                             :b (node-b bst)))
                          (if (> green_obj green_node)
                              (progn
                            ;  (format t " green_obj ~a > green_node ~a ~& "
                            ;   green_obj green_node)
                                (make-node
                                 :color color
                                 :r (node-r bst)
                                 :g (make_bst obj (node-g bst) >)
                                 :b (node-b bst)))
                              (if (> blue_obj blue_node)
                                  (progn
                            ;  (format t " blue_obj ~a > blue_node ~a ~& "
                            ;   blue_obj blue_node)
                                    (make-node
                                     :color color
                                     :r (node-r bst)
                                     :g (node-g bst)
                                     :b (make_bst obj (node-b bst) >)))
                                          ; если ничего не сработало,
                                          ;приступаем к сравнению по принципу "="
                                  (if ( eql red_obj red_node)
                                      (progn
                                    ;  (format t " red_obj ~a =  red_node ~a ~& "
                                    ;   red_obj red_node)
                                        (make-node
                                         :color color
                                         :r (make_bst obj (node-r bst) >)
                                         :g (node-g bst)
                                         :b (node-b bst)))
                                      (if (eql green_obj green_node)
                                          (progn
                                        ;  (format t " green_obj ~a =  green_node ~a ~& "
                                        ;   green_obj green_node)
                                            (make-node
                                             :color color
                                             :r (node-r bst)
                                             :g (make_bst obj (node-g bst) >)
                                             :b (node-b bst)))
                                          (if (eql blue_obj blue_node)
                                              (progn
                                         ; (format t " blue_obj ~a = blue_node ~a ~& "
                                         ;  blue_obj blue_node)
                                                (make-node
                                                 :color color
                                                 :r (node-r bst)
                                                 :g (node-g bst)
                                                 :b (make_bst obj (node-b bst) >)))
                                          ; если и второй кейс не сработал,
                                          ; то сравниваем элементы объекта между собой и
                                          ; элемент-победитель определяет ветку

                                              (if (> red_obj green_obj)
                                                  (progn
                                                  ;  (format t " red_obj ~a >
                                                  ;   green_obj ~a ~& "
                                                  ;    red_obj green_obj)
                                                    (if (> red_obj blue_obj)
                                                        (progn
                                                   ;  (format t " red_obj ~a >
                                                   ;   blue_obj ~a ~& "
                                                   ;   red_obj blue_obj)
                                                          (make-node
                                                           :color color
                                                           :r (make_bst obj (node-r bst) >)
                                                           :g (node-g bst)
                                                           :b (node-b bst)))
                                                        (progn
                                                     ;  (format t " blue_obj ~a >
                                                     ;   red_obj ~a ~& "
                                                     ;   blue_obj red_obj)
                                                          (make-node
                                                           :color color
                                                           :r (node-r bst)
                                                           :g (node-g bst)
                                                           :b (make_bst obj (node-b bst) >))
                                                          )))
                                                  (if ( > green_obj blue_obj)
                                                      (progn
                                                       ; (format t " green_obj ~a >
                                                       ;  red_obj ~a ~& "
                                                       ;  green_obj red_obj)
                                                        (make-node
                                                         :color color
                                                         :r (node-r bst)
                                                         :g (make_bst obj (node-g bst) >)
                                                         :b (node-b bst)))
                                                      (progn
                                                         ; (format t " blue_obj ~a >
                                                         ;  red_obj ~a ~& "
                                                         ;  blue_obj red_obj)
                                                        (make-node
                                                         :color color
                                                         :r (node-r bst)
                                                         :g (node-g bst)
                                                         :b (make_bst obj (node-b bst) >)))))

                                              )))))))))))))))


    ; Функция для запуска:

  (defun execute_make_tree (lst)
    (let ((tree))
      (do ((i (length lst) (- i 1)))
          ((= i 0) tree)
        (format t " OBJ ~A ~&" (car lst))
        (setf tree (make_bst (car lst) tree #'>))
        (setf lst (cdr lst)))))


  (execute_make_tree '((255 55 30) (38 255 42) (0 44 42) (16 255 0) (13 40 255)))


#+END_SRC

Дерево создано. Теперь необходимо сделать его обход, что в дальнейшем
позволит его копировать и находить нужный элемент.

Поиск по дереву.
Функция принимает дерево и объект. Объект нашего дерева -
цвет.

С помощью and сравниваем последовательно сравниваем rgb объекта и rgb
узла. Если всезначения совпадают, тогда объект считается найденным.

В случае, если хотя бы одно значение не совпадает, приступаем к
проходу по веткам дерева. Осуществляем это сходим образом с проходом
по дереву в функции make_tree.

1. Если какое-то из значений rgb > одного из значений текущего узла,
   двигаемся по выбранной ветке до следующего узла. Затем
   сравниваем значение объекта и нового узла.

2. В случае, если ни один из rgb объекта не оказалася больше одного из
   rgb узла, ищем равное значение. Если нашли, двигаемся по выбранной
   ветке и сравниваем значения объекта и узла.

3. В случае, если и это ничего не дало, сравниваем rgb объекта между
   собой. Затем снова двигаемся по выбранной ветке до следующего
   узла.

4. В случае, если мы дошли до конца, т.к. дерево пустое, но ничего
   найдено не было, возвращаем nil.

Технически задание выполнено. Правктически приходится использовать
много однотипных оперций и вспомогательные функции для
запуска. Возможно, есть более простой путь это делать.

Так же даже в случае если печатается строка "obj .... is found", одна
из вспомогательных функций (форм) возвращает nil.


#+BEGIN_SRC lisp

  (format t "gregre")

  (defun tree_search (bst obj)
    (if (null bst)
        nil
        (let ((color (node-color bst)))
          (if (and (eql (nth 0 obj) (nth 0 color))
                   (eql (nth 1 obj) (nth 1 obj))
                   (eql (nth 2 obj) (nth 2 obj)))
              (progn
                (format t "obj ~a is found ~&" obj)
                obj)
              ;; else
              (if (> (nth 0 obj) (nth 0 color))
                  (tree_search (node-r bst) obj)
                  (if (> (nth 1 obj) (nth 1 color))
                      (tree_search (node-g bst) obj)
                      (if (> (nth 2 obj) (nth 2 color))
                          (tree_search (node-b bst) obj)
                          (if (eql (nth 0 obj) (nth 0 color))
                              (tree_search (node-r bst) obj)
                              (if (eql (nth 1 obj) (nth 1 color))
                                  (tree_search (node-g bst) obj)
                                  (if (eql (nth 2 obj) (nth 2 color))
                                      (tree_search (node-b bst) obj)
                                      (if (> (nth 0 obj) (nth 1 obj))
                                          (if (> (nth 0 obj) (nth 2 obj))
                                              (tree_search (node-r bst) obj)
                                              (tree_search (node-b bst) obj))
                                          (if (> (nth 1 obj) (nth 2 obj))
                                              (tree_search (node-g bst) obj)
                                              (tree_search (node-b bst) obj)))))))))))))

  ;Форма запуска
  (defun execute_tree_search (obj)
    (let ((tree))
      (setf tree (execute_make_tree '((255 55 30) (38 255 42)
                                      (0 44 42) (16 255 0) (13 40 255))))
      (tree_search tree obj)))

  ;obj is found
  (execute_tree_search '(0 40 42))

  ;nil
  (execute_tree_search '(0 66 42))


#+END_SRC

Скопировать дерево.
Чтобы скопировать дерево, надо последовательно обойти все его узлы.

Используем рекурсию. Условие завершения рекурсии - пустое исходное
дерево. Тогда мы возвращаем его копию.

Берем содержимое каждого узла и рекурсивно вызываем его. При этом
значение будет записано при откате рекурсси назад. То есть сначала
будет записан лист, потом то, что было до него и т.д.


#+BEGIN_SRC lisp

  (defun copy_tree (bst)
    (if (and
         (null (node-r bst))
         (null (node-g bst))
         (null (node-b bst)))
        (make-node :color (node-color bst) :r nil :g nil :b nil)
        ;; else
        (make-node
         :color (node-color bst)
         :r (if (null (node-r bst))
                nil
                (copy_tree (node-r bst)))
         :g (if (null (node-g bst))
                nil
                (copy_tree (node-g bst)))
         :b (if (null (node-b bst))
                nil
                (copy_tree (node-b bst)))
         )))

#+END_SRC

** from bst to list

Напишите функцию, которая создаст список из BST, отсортированный от
меньшего к большему.

Сначала создадим бинарное дерево.
Определим структуру узла, функцию, создающую дерево, и функцию
запуска.

#+BEGIN_SRC lisp

    (defstruct node
        elt
        (r nil)
        (l nil)
        )

    (defun bst-insert (obj bst sortfun)
      (if (null bst)
          (make-node :elt obj :r nil :l nil)
          ;; else
          (let ((elt (node-elt bst)))
            (if (eql obj elt)
                bst
                (if (funcall sortfun obj elt)
                    (progn
                      ;; (format t "<")
                      ;; (format t " left true ~a ~&" (node-l bst))
                      ;; (format t " right true ~a ~&" (node-r bst))
                      (make-node
                       :elt elt
                       :l (bst-insert obj (node-l bst) sortfun)
                       :r (node-r bst)))
                    ;; else
                    ;; (format t ">")
                    (make-node
                     :elt elt
                     :r (bst-insert obj (node-r bst) sortfun)
                     ;; (format t "right false ~a ~&" (node-r bst))
                     :l (node-l bst)
                     ;; (format t "left false ~a ~&" (node-l bst)))
                    ))))))

  (defun ex-bst-insert (lst)
    (let ((tree))
      (do ((i (length lst) (- i 1)))
          ((= i 0) tree)
        (setf tree (bst-insert (car lst) tree #'>))
        (setf lst (cdr lst)))))

(ex-bst-insert '(1 3 5 6 9 2 4 8))


#+END_SRC

Теперь напишем функцию, которая создаст из дерева список.

#+BEGIN_SRC lisp

  (defun lst_bst (bst lst)
    (let ((elt (node-elt bst)))
      (format t "elt ~a lst before setf ~a ~&" elt lst)
      (setf lst (cons elt lst))
      (format t "before lst ~a ~&" lst)
      ;; если правая ветка != nil
      (if (node-r bst)
          ;; проверяем ее подветки
          ;; в случае, если  r-подветка = nil
          (if (null (node-r (node-r bst)))
              ;;так же проверяем l-подветку
              (if (null(node-l (node-r bst)))
                  ;; если обе ветки = nil
                  ;; копируем элемент из узла, не заходя в него
                  (progn
                    (setf lst (cons (node-elt(node-r bst)) lst))
                    (format t " node R true ~a ~&" lst))
                  ;; в противном случае заходим в узел
                  (lst_bst (node-r bst) lst))
              (lst_bst (node-r bst) lst))
          nil)

      ;; если левая ветка!= nil
      (if (node-l bst)
          ;; проверяем ее подветки
          (progn
            (format t " node-l ~a ~&" (node-l bst))
            (if (null (node-r (node-l bst)))
                (if (null(node-l (node-l bst)))
                    (progn
                      (setf lst (cons (node-elt(node-l bst)) lst))
                      (format t " node L true ~a ~&" lst))
                    (lst_bst (node-l bst) lst))
                (lst_bst (node-l bst) lst)))
          ;; если обе ветки текущего узла = nil,
          ;; возвращаем полученный список
          (sort lst #'>))))

  (defun ex_lst_bst (lst)
    (let ((tree (ex-bst-insert lst)))
      (let ((new_lst))
        (setf new_lst (lst_bst tree new_lst)))))

  (ex_lst_bst '(1 3 5 6 9 2 4 8))

#+END_SRC
