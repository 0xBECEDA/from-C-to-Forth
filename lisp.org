#+STARTUP: showall indent hidestars


* Chapter 2

** Fourth element of list

С помощью car и cdr определите функцию, возвращающую 4ый элемент
списка.

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car(cdr(cdr(cdr lst)))))
#+END_SRC

[COMMENT:gmm] Пробелы облегчают понимание:

#+BEGIN_SRC lisp
  (defun forth (lst)
     (car (cdr (cdr (cdr lst)))))
#+END_SRC

** Bigger elt

Определите функцию, принимающую два аргумента и возвращающую
наибольший.

#+BEGIN_SRC lisp
  (defun bigger (x y)
    (if (> x y)
        x
        y))
#+END_SRC

** What is X

Что может быть на месте X в следующих выражениях?

#+BEGIN_SRC lisp
  (car (X (cdr '(a (b c) d))))
  => B
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (car (cdr '(a (b c) d))))
#+END_SRC



#+BEGIN_SRC lisp
  (x 13 (/ 1 0))
  => 13
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (or 13 (/ 1 0))
#+END_SRC


#+BEGIN_SRC lisp
  (x #'list 1 nil)
  =>(1)
#+END_SRC

Ответ:

#+BEGIN_SRC lisp
  (car (funcall #'list 1 nil))
#+END_SRC

[COMMENT:gmm] - Только без ведущего CAR

** Check list

Определите функцию, проверяющую, является ли списком хотя бы один
аргумент в списке.

[COMMENT:gmm] - Ты спрашивала, как писать тесты - вот тебе пример. Он кстати
показывает, что второй тест не проходит :)

#+BEGIN_SRC lisp
  (defun checker(lst)
    (and t (listp (car lst))))

  (assert (equal nil (checker (list 1 2 3))))

  (assert (equal t (checker '(1 (2 3) 4))))
#+END_SRC

** Dot print

Напишите итеративную и рекурсивную версию функции, которая:

*** печатает количество точек, равное заданному положительному целому числу

К сожалению, точку вывести не удалось. Вместо нее печатается слово "dot".

[COMMENT:gmm] - я поправил, обрати внимание на опциональный аргумент в рекурсивной
версии.

Итеративная версия:

#+BEGIN_SRC lisp
  (defun point (num)
    (do ((i num ( - i 1)))
        ((= i 0) 'done)
      (format t "."))
    (format t "~%"))

  (point 3)
#+END_SRC

Рекурсивная версия:

#+BEGIN_SRC lisp
  (defun point (num &optional (new t))
    (when new
      (format t "~%"))
    (format t ".")
    (if (> num 1)
        (point ( - num 1) nil)
        nil))

  (point 3)
#+END_SRC

*** возвращает количество символов "а" в заданном списке

Итерация:

#+BEGIN_SRC lisp
  (defun counter (lst obj count)
    (let ((lst2))
      (setf lst2 lst)
      (do ((i (length lst) (- i 1)))
          ((= i 0) count)
        (and (eql (car lst2) obj) (setf count(+ count 1)))
        (setf lst2 (cdr lst2)))))

  (counter '(a b c a) 'a 0)

#+END_SRC

Рекурсия:

#+BEGIN_SRC lisp

  (defun counter (lst obj count)
    (and (eql (car lst) obj)
         (setf count (+ count 1)))
    (if (null (cdr lst))
        count
        (counter (cdr lst) obj count)))

  (counter '(a b c a) 'a 0)
#+END_SRC

Обе функции принимают списки из любого количества элементов. Count в обоих
случаях - увеличивающийся счетчик, должен быть равен нулю на старте.

Пример вызова: (counter '(a b c) 'a 3 0)

** Summing list without nil

Дано: написать функцию, суммирующую все элементы списка кроме nil.
"Некто" написал 2 функции, ни одна из которых не работает. Объяснить
причину и предложить свою версию.

а)
#+BEGIN_SRC lisp

  (defun summit (lst)
    (remove nil lst)
    (apply #’+ lst))

#+END_SRC

Проблема в том, что remove не удаляет элемент из списка, а
формирует новый список без указанного элемента.
Поэтому nil как был в lst, так и остался.


б)
#+BEGIN_SRC lisp

  (defun summit (lst)
    (let ((x (car lst)))
      (if (null x)
          (summit (cdr lst))
          (+ x (summit (cdr lst))))))

  ;; (trace summit)

  ;; (summit '(1 2 nil 3))
#+END_SRC

Проблема одна: проверяется только первый элемент списка. То есть если
nil будет в "хвосте списка", то проверка его никак не заметит. Вывод:
пройти по всему списку сначала, найти nil, избавиться от него, только
затем прибавлять.



Корректная версия:

#+BEGIN_SRC lisp

(defun summit (lst)
   (let(lst2))
   (setf lst2 (remove nil lst))
 (apply #' + lst2))

#+END_SRC

Да, кооректная версия должна быть одна. А не на каждую функцию.

* Chapter 3

** cons
Представте следующие списки в виде ячеек:
(я представила алгоритмы их создания)
1. (a b (c d))
(list 'a 'b '(c d))
(list 'a 'b (list 'c 'd))

2. (a (b (c (d))))
(list 'a (list 'b (list 'c (list 'd))))

3. (((a b) c) d)
(list '(a b) 'c 'd)
(list (list 'a 'b) 'c 'd)

4. (a (b . c) . d)
(list 'a (cons (cons 'b 'c) 'd))

[COMMENT:gmm] - Полагаю задание было про нарисовать квадратики на листочке.

** new_union

Напишите свой вариант функции union, который сохраняет
порядок следования элементов согласно исходным спискам:

> (new-union ’(a b c) ’(b a d))
(A B C D)

Встроенный union объединяет неповторяющиеся элементы в двух
списках и при этом меняет их порядок.

- добавить элементы, которых еще нет
- сформировать список, не трогая порядок в исходном.

- new-union принимает 2 аргмента: 2 списка
- берем (car lst2) и сравниваем со всем списком
- добавляем элемент в список
- повторяем до тех пор, пока элементы во втором списке
не кончатся

#+BEGIN_SRC lisp

  (defun new-union (lst1 lst2)
    (let ((new_lst))
      (let ((double_lst))
        (setf double_lst lst1) ;; Почему не обьединить декларацию в let и инициализацию?
        (do ((i (length lst2) (- i 1)))
            ((= i 0) (append double_lst new_lst))
          (if (not (member (car lst2) lst1))
              (setf new_lst ( append new_lst (list(car lst2)))) ;; вижу пробелы после открывающей
              nil) ;; скобки где они не нужны, но не вижу после list где они нужны - неряшливо
          (setf lst2 (cdr lst2))))))

  ;; Два нижеприведенных примера работают неодинаково

  ;; (new-union '(b c f) '(b a d))

  ;; (union '(b c f) '(b a d))
#+END_SRC

Наверное, функции работают не одинаково, потому что union деструктивна
и не соблюдает порядок элементов в заданных списках, а задание звучало
"напишите функцию с соблюдением порядка элементов в заданных списках?"

** Occurrences

Напишите функцию, определяющую количество повторений (с
точки зрения eql) каждого элемента в заданном списке и
сортирующую их по убыванию встречаемости:

> (occurrences ’(a b a d a c d c a))
((A . 4) (C . 2) (D . 2) (B . 1))

- В occur устанавливаем переменные, чтоб это не происходило
каждый раз при рекурсивном вызове compr (позже будет проверка,
является ли аргумент списком).

+ Убираем элементы (remove) и переопределяем список.
+ Сравниваем длины списка "до" и "после" remove.
+ Записываем результат в переменную.
+ Создаем точечную пару "элемент.количество повторений".
- объединяем в список
+ Сортируем

#+BEGIN_SRC lisp

  (defun occur (lst)
    (let ((lst2))
      (setf lst2 lst)
      (let ((final_lst))
        (compr lst2 final_lst)))) ;; Если я правильно понимаю final_lst всегда nil
  ;; тогда всю функцию можно заменить просто на вызов (compr lst nil) ?


  (defun compr (lst final_lst)
    (let ((lst3))
      (setf lst3 lst)
      (setf lst (remove (car lst) lst))
      (let ((len))
        (setf len (- (length lst3) (length lst))) ;; хм, оригинальный способ подчета
        (let ((new_lst))                          ;; но очень неэффективный (2 прохода по спискам)
          (setf new_lst (cons (car lst3) len))
          (setf final_lst (cons new_lst final_lst))
          (if (null lst)
              (new_order final_lst)
              (compr lst final_lst))))))

  (defun new_order (lst)
    (let ((new_lst))
      (do ((i 4 (- i 1)))
          ((= i 0) (my_sort new_lst ))
        (setf new_lst (cons (car lst) new_lst))
        (setf lst (cdr lst)))))

  (defun my_sort (lst)
    (let ((first_elm))
      (let ((final_lst))
        (setf first_elm (car lst))
        (setf lst (cdr lst))
        (do ((i 3 (- i 1)))
            ((= i 0) (cons first_elm final_lst ))
          (if ( < (cdr first_elm) (cdr (car lst)))
              nil
              (setf final_lst (cons (car lst) final_lst)))
          (setf lst (cdr lst))))))

  ;; (occur '(a b a d a c d c a))

#+END_SRC

** Member key

Почему (member ’(a) ’((a) (b))) возвращает nil?

Member должен найти элемент в списке и вернуть часть списка, которая
начинается с искомого аргумента. Если ничего найти не удалось,
возвращается nil. В основе member лежит eql, который вернет t только
в случае, если объекты соответствуют одному значению в памяти лиспа.

Но проблема в том, что в данном случае мы ищем список в списке. А для
этого нужен ключ equal.

Правильная команда:

(member '(a) '((a) (b)) :test #' equal)

** Pos+
Функция pos+ принимает список и возвращает новый, каждый
элемент которого увеличен по сравнению с исходным на его
положение в списке:

> (pos+ ’(7 5 1 4))
(7 6 3 7)

Опеределить функцию с помощью: рекурсии, итерации, mapcar.

Итеративная версия:

#+BEGIN_SRC lisp

  (defun pos+ (lst)
    (let ((indx))
      (setf indx 0)
      (let ((new_lst))
        (do ((i (length lst) (- i 1)))
            ((= i 0) (pos_sort new_lst))
          (setf new_lst (cons (+ indx (car lst)) new_lst ))
          (setf lst (cdr lst))
          (setf indx (+ indx 1))))))

  (defun pos_sort (lst)
    (let ((final_lst))
      (do ((i (length lst) (- i 1)))
          ((= i 0) final_lst)
        (setf final_lst (cons (car lst) final_lst))
        (setf lst (cdr lst)))))

#+END_SRC

Версия с mapcar:

#+BEGIN_SRC lisp
  (defun indx+ (num)
    (let ((indx_lst))
      (setf num (- num 1))
      (do ((i num  (- i 1)))
          ((< i 0) indx_lst)
        (setf indx_lst (cons num indx_lst))
        (setf num (- num 1)))))

  (defun mapcar_pos+ (lst)
    (let ((indx_lst))
      (setf indx_lst (indx+ (length lst)))
      (mapcar #' + lst indx_lst)))

#+END_SRC

Рекурсивная версия:

#+BEGIN_SRC lisp
  (defun rec_pos+ (lst)
    (let ((indx))
      (setf indx 0)
      (let ((new_lst))
        (rec lst indx new_lst))))

  (defun rec (lst indx new_lst)
    (setf new_lst (cons (+ indx (car lst)) new_lst))
    (setf indx (+ indx 1))
    (setf lst (cdr lst))
    (if (> (length lst) 0)
        (rec lst indx new_lst)
        (rec_pos_sort new_lst)))

  (defun rec_pos_sort (lst)
    (let ((final_lst))
      (do ((i (length lst) (- i 1)))
          ((= i 0) final_lst)
        (setf final_lst (cons (car lst) final_lst))
        (setf lst (cdr lst)))))

#+END_SRC


** show dots

Определите функцию, печатающую заданный список в точечной
нотации:

(showdots ’(a b c))
(A . (B . (C . NIL)))
NIL

- невозможно объединить "с" и nil в точечную пару.

#+BEGIN_SRC lisp
  (defun showdots (lst)
    (if (null lst)
        "NIL"
        (format nil "(~A . ~A)"
                (car lst)
                (showdots (cdr lst)))))

#+END_SRC

** new car and cdr
Определить cons, length и member без ключей, для списков, исходя
из аксиомы, что car указывает на остаток списка, а cdr - на его
начало.

#+BEGIN_SRC lisp
  (defun my-cons (a b)
    (cons a b))

  (assert (equal (cons 'a 'b) (my-cons 'a 'b)))

  (defun my-length (lst)
    (if (null lst)
        0
        (+ 1 (my-length (cdr lst)))))

  (assert (equal 3 (my-length '(a b c))))

  (defun my-member (elt lst)
    (if (equal elt (car lst))
        lst
        (if (null lst)
            nil
            (my-member elt (cdr lst)))))

  (assert (equal '(a b) (my-member 'a '(c d a b))))
  (assert (equal nil (my-member 'a '(c d b))))
#+END_SRC

#+BEGIN_SRC lisp

(defun my_car (lst)
(cdr lst))

#+END_SRC

CONS:

#+BEGIN_SRC c


  # define TRUE FALSE
#+END_SRC

** my_compress
Измените программу на рисунке 3.6 (стр. книги 54) так, чтоб она
создавала меньшее количество ячеек.
Подсказка: используйте точечные пары.

- дублиурем исходный список
- берем первый элемент и удаляем его из всего списка (remove)
- сравниваем длины списка-дубля и текущего списка
- записываем разность в len
- формируем точечную пару из текущего элемента и len
- заносим пару в список

Фактически это то же самое, что я делаю в задании "occurrences".
Только без сортировки списка.

#+BEGIN_SRC lisp

  (defun my_compress (lst)
    (let ((final_lst))
      (my_compr lst final_lst)))

  (defun my_compr (lst final_lst)
    (let ((lst2))
      (setf lst2 lst)
      (setf lst (remove (car lst) lst))
      (let ((len))
        (setf len (- (length lst2) (length lst)))
        (let ((new_lst))
          (setf new_lst (cons (car lst2) len))
          (setf final_lst (cons new_lst final_lst))
          (if (null lst)
              final_lst
              (my_compr lst final_lst))))))

#+END_SRC
** long path

Напишите программу, которая ищет самый длинный путь в сети,
не содержащий повторений. Подсказка: можно использовать циклы.

Дана сеть: '((a b c) (b c) (c d))

Итак, самый длинный путь - это путь, при котором проходится каждый
узел до искомого. То есть, если мне нужен узел "d",
то вместо того, чтоб идти "a -> c -> d", я пойду
"a -> b -> c -> d".

Предположим, мы используем (рекурсию). Проходим по каждому узлу
сети, пока не встретим искомый. Пройденные узлы сохраняем в путь.
Если узел уже встречался, значит, не включаем его в путь.

Функция принимает 3 параметра: начальную конечную точку и сеть.
Здесь мы создаем пустой список, чтоб хранить наш путь
и оборачиваем начальную точку в список. Затем вызываем фунцию bfs.

#+BEGIN_SRC lisp

(defun longest-path (start end net)
(let ((final_path))
(bfs end (list (list start)) net final_path)))

#+END_SRC

Здесь мы будем искать нашу конечную точку и сохранять все
пройденные узлы в final_lst, при условии, что они не повторяются.

#+BEGIN_SRC lisp

  (defun bfs (end queue net final_lst)
    (format t " BFS end ~a queue ~a  net ~a ~&" end queue net)
    (if (null queue)
        nil
        (let ((path (car queue)))
          (let ((node (car path)))
            (format t " BFS path ~a ~& " path)
            (if (eql node end)
                (reverse final_lst)
                (format t " final_lst ~a ~&"
            (check-list node final_lst)))
            (bfs end
                 (append (cdr queue)
                         (new-paths path node net))
                 net final_lst)))))

#+END_SRC

#+BEGIN_SRC lisp

(defun check-list (node final_lst)
 (format t " CHECK_LIST node ~a final_lst ~a ~& " node final_lst)
(let ((local_lst))
(setf local_lst final_lst)
(if (not(member node final_lst))
(setf local_lst (cons node final_lst))
nil)
(format t "local_lst check ~a ~&" local_lst ))

#+END_SRC

#+BEGIN_SRC lisp

  (defun new-paths (path node net)
(format t "NEW-PATHS path ~a node ~a net ~a ~&" path node net)
    (mapcar #'(lambda (n)
                (cons n path))
              (cdr (assoc node net))))

#+END_SRC

* Chapter 4

**  turn array

Определите функцию, поворачивающую квадратный массив
(массив с размерност­ми (n n)) на 90 градусов по часовой стрелке.


Итак, функция принимает квадратный двухмерный массив.
При этом мы не знаем, будет это квадрат 2x2 или 100x100. Значит, нам
нужно выяснить сначала размер размерностей.

Для этого понадобится array-dimensions с нашим массивом в качестве
аргумента. Array-demensions вернет список целых чисел, представляющих
все размерности массива. Эти значения станут счетчиками для наших
циклов.

В циклах мы будет проходить по массиву и копировать его значения в
другой массив, пересчитывая координаты. ВОт второй массив мы и
вернем.

Внешний цикл отвечает за проход по горизонтали и перезапуск
внутреннего цикла, который отвечает за проход по вертикали. Это
обеспечит проход по новому массиву.

Вопрос! как получить координаты элементов старого массива?

- возможный вариант: пройти по старому массиву, создать список из его
  элементов, и уже из него переносить элементы в новый массив

Запуск:

(turn_arr (make-array '(2 2) :initial-contents '((a b) (c d))))

#+BEGIN_SRC lisp

  (defun turn_arr (array)
    (let ((lst_dim (array-dimensions array)))
      (let ((new_arr (make-array lst_dim :initial-element nil)))
        (format t "new _arr ~a ~&" new_arr)
        (let ((arr_lst))
          (do ((hor 0 (+ hor 1)))
              ((>= hor (nth 0 lst_dim)))
            (do ((ver 0 (+ ver 1)))
                ((>= ver (nth 0 lst_dim)) arr_lst)
              (setf arr_lst (cons (aref array hor ver) arr_lst))))
          (setf arr_lst (reverse arr_lst))
          (format t "~a ~&" arr_lst)
          (let ((indx 0))
            (do ((ver (- (nth 0 lst_dim) 1) (- ver 1)))
                ((< ver 0) new_arr)
              (format t " ver ~a ~& " ver)
              (do ((hor 0 (+ hor 1)))
                  ((>= hor (nth 0 lst_dim)))
                (format t "new_arr ~a ~&" new_arr)
                (setf (aref new_arr hor ver) (nth indx arr_lst))
                (format t "~a | ~a | ~a ~& " indx (nth indx arr_lst) hor)
                (setf indx (+ indx 1))
                (format t "new_arr ~a ~&" new_arr)
                )))))))


  (assert (equal '(a b c d)
                 (turn_arr (make-array '(2 2) :initial-contents '((a b) (c d))))))
#+END_SRC

** new copy-list and reverse

Copy-list

Написать свой copy-list и reverse для списков с помощью reduce.
Сначала я превращаю обычный список в список списков
'(a b c) -> ((A) (B) (C)), а затем использую append, чтоб скопировать
список, придав ему изначальный вид.

Проблема в том, что данный метод не работает для ассоциативных
списков. Список вида '((1. 2) (3. 4)) становится ((1 2) (3 4)),
а список вида '((1 . 2) . 3) вызывает ошибку
" 3 не является последовательностью ".

Запускать как (my_copy_list '(a b c))

#+BEGIN_SRC lisp

  (defun my_copy_list (lst)
    (let ((new_lst))
      (do ((i (length lst)  (- i 1)))
          ((= i 0) new_lst)
        (setf new_lst (cons (list (car lst)) new_lst))
        (setf lst (cdr lst)))
      (setf new_lst (reverse new_lst))
        (reduce #'(lambda (a b)
                     (append a b))
                     new_lst)))

#+END_SRC


My-reverse абсолютно аналогичен my_copy_list, за исключением того, что
после выполнения цикла do список не переворачивается с помощью
reverse. Для ассоциативных списоков эта функция так же не годится.

#+BEGIN_SRC lisp

  (defun my_reverse (lst)
    (let ((new_lst))
      (do ((i (length lst)  (- i 1)))
          ((= i 0) new_lst)
        (setf new_lst (cons (list (car lst)) new_lst))
        (setf lst (cdr lst)))
      (reduce #'(lambda (a b)
                  (append a b))
              new_lst)))

#+END_SRC
** tree

Определите структуру для дерева, каждый узел котоого помимо некоторых
данных имеет трех потомков.

Опеределите функцию, которая копирует такое дерево.
Опеределите функцию, которая принимает такое дерево и объект и
возвращает истину, если объект встречается хотя бы в одном узле
дерева.

Для начала определяем структуру узла. Затем пишем функцию, которая
создаст нам такое дерево.

Элементы нашего дерева - цвета. Цвет - это список из 3х значений
RGB. Цвета деляется на ветки по преобладанию одного из трех цветов в
них.

Проверяем, пустое ли дерево. Если пустое, то создаем узел. Если же
нет, то выгружаем поле color из корня (там хранятся все три значения
rgb), выгружаем из объекта и color цвета в соответствующие переменные
(так легче ориентироваться в коде), затем последовательно сравниваем:

1.значение поля r/g b объекта больше значения поля r/g/b корня?
-Да! Тогда двигаемся по выбранной ветке до листа и создаем узел.

Если
сравнили все три поля, но они одно из них не больше, то потом
проверяется кейс
2. значение поля r/g b объекта = значению поля r/g/b корня?

-Да! Тогда двигаемся по выбранной ветке до листа и создаем узел.

3. Если уж и равенство не сработало, тогда просто сравниваем rgb
   объекта между собой. Элемент-победитель определяет ветку.

#+BEGIN_SRC lisp

  (defstruct node
    color (r nil) (g nil) (b nil))

  (defun make_bst (obj bst >)
    (if (null bst)
        (make-node :color obj :r nil :g nil :b nil)
        ; выгружаем необходимые переменные
        (let ((color (node-color bst)))
        ;  (format t " color ~a ~& " color)
          (let ((red_obj (car obj)))
            (let ((red_node))
              (setf red_node (car color))
              (let ((green_obj))
                (setf green_obj (nth 1 obj))
                (let ((green_node))
                  (setf green_node (nth 1 color))
                  (let ((blue_obj))
                    (setf blue_obj (nth 2 obj))
                    (let ((blue_node))
                      (setf blue_node (nth 2 color))
                     ; (format t " Obj: R ~a G ~a B ~a | Node: R ~a G ~a B ~a ~&"
                     ;         red_obj green_obj blue_obj
                     ;         red_node green_node blue_node)
                      ; приступаем к сравнению по принципу ">"
                      (if ( > red_obj red_node)
                          (progn
                        ;    (format t " red_obj  ~a > red_node ~a ~& "
                        ;            red_obj red_node)
                            (make-node
                             :color color
                             :r (make_bst obj (node-r bst) >)
                             :g (node-g bst)
                             :b (node-b bst)))
                          (if (> green_obj green_node)
                              (progn
                            ;  (format t " green_obj ~a > green_node ~a ~& "
                            ;   green_obj green_node)
                                (make-node
                                 :color color
                                 :r (node-r bst)
                                 :g (make_bst obj (node-g bst) >)
                                 :b (node-b bst)))
                              (if (> blue_obj blue_node)
                                  (progn
                            ;  (format t " blue_obj ~a > blue_node ~a ~& "
                            ;   blue_obj blue_node)
                                    (make-node
                                     :color color
                                     :r (node-r bst)
                                     :g (node-g bst)
                                     :b (make_bst obj (node-b bst) >)))
                                          ; если ничего не сработало,
                                          ;приступаем к сравнению по принципу "="
                                  (if ( eql red_obj red_node)
                                      (progn
                                    ;  (format t " red_obj ~a =  red_node ~a ~& "
                                    ;   red_obj red_node)
                                        (make-node
                                         :color color
                                         :r (make_bst obj (node-r bst) >)
                                         :g (node-g bst)
                                         :b (node-b bst)))
                                      (if (eql green_obj green_node)
                                          (progn
                                        ;  (format t " green_obj ~a =  green_node ~a ~& "
                                        ;   green_obj green_node)
                                            (make-node
                                             :color color
                                             :r (node-r bst)
                                             :g (make_bst obj (node-g bst) >)
                                             :b (node-b bst)))
                                          (if (eql blue_obj blue_node)
                                              (progn
                                         ; (format t " blue_obj ~a = blue_node ~a ~& "
                                         ;  blue_obj blue_node)
                                                (make-node
                                                 :color color
                                                 :r (node-r bst)
                                                 :g (node-g bst)
                                                 :b (make_bst obj (node-b bst) >)))
                                          ; если и второй кейс не сработал,
                                          ; то сравниваем элементы объекта между собой и
                                          ; элемент-победитель определяет ветку

                                              (if (> red_obj green_obj)
                                                  (progn
                                                  ;  (format t " red_obj ~a >
                                                  ;   green_obj ~a ~& "
                                                  ;    red_obj green_obj)
                                                    (if (> red_obj blue_obj)
                                                        (progn
                                                   ;  (format t " red_obj ~a >
                                                   ;   blue_obj ~a ~& "
                                                   ;   red_obj blue_obj)
                                                          (make-node
                                                           :color color
                                                           :r (make_bst obj (node-r bst) >)
                                                           :g (node-g bst)
                                                           :b (node-b bst)))
                                                        (progn
                                                     ;  (format t " blue_obj ~a >
                                                     ;   red_obj ~a ~& "
                                                     ;   blue_obj red_obj)
                                                          (make-node
                                                           :color color
                                                           :r (node-r bst)
                                                           :g (node-g bst)
                                                           :b (make_bst obj (node-b bst) >))
                                                          )))
                                                  (if ( > green_obj blue_obj)
                                                      (progn
                                                       ; (format t " green_obj ~a >
                                                       ;  red_obj ~a ~& "
                                                       ;  green_obj red_obj)
                                                        (make-node
                                                         :color color
                                                         :r (node-r bst)
                                                         :g (make_bst obj (node-g bst) >)
                                                         :b (node-b bst)))
                                                      (progn
                                                         ; (format t " blue_obj ~a >
                                                         ;  red_obj ~a ~& "
                                                         ;  blue_obj red_obj)
                                                        (make-node
                                                         :color color
                                                         :r (node-r bst)
                                                         :g (node-g bst)
                                                         :b (make_bst obj (node-b bst) >)))))

                                              )))))))))))))))


    ; Функция для запуска:

  (defun execute_make_tree (lst)
    (let ((tree))
      (do ((i (length lst) (- i 1)))
          ((= i 0) tree)
        (format t " OBJ ~A ~&" (car lst))
        (setf tree (make_bst (car lst) tree #'>))
        (setf lst (cdr lst)))))


  (execute_make_tree '((255 55 30) (38 255 42) (0 44 42) (16 255 0) (13 40 255)))


#+END_SRC

Дерево создано. Теперь необходимо сделать его обход, что в дальнейшем
позволит его копировать и находить нужный элемент.

Поиск по дереву.
Функция принимает дерево и объект. Объект нашего дерева -
цвет.

С помощью and сравниваем последовательно сравниваем rgb объекта и rgb
узла. Если всезначения совпадают, тогда объект считается найденным.

В случае, если хотя бы одно значение не совпадает, приступаем к
проходу по веткам дерева. Осуществляем это сходим образом с проходом
по дереву в функции make_tree.

1. Если какое-то из значений rgb > одного из значений текущего узла,
   двигаемся по выбранной ветке до следующего узла. Затем
   сравниваем значение объекта и нового узла.

2. В случае, если ни один из rgb объекта не оказалася больше одного из
   rgb узла, ищем равное значение. Если нашли, двигаемся по выбранной
   ветке и сравниваем значения объекта и узла.

3. В случае, если и это ничего не дало, сравниваем rgb объекта между
   собой. Затем снова двигаемся по выбранной ветке до следующего
   узла.

4. В случае, если мы дошли до конца, т.к. дерево пустое, но ничего
   найдено не было, возвращаем nil.

Технически задание выполнено. Правктически приходится использовать
много однотипных оперций и вспомогательные функции для
запуска. Возможно, есть более простой путь это делать.

Так же даже в случае если печатается строка "obj .... is found", одна
из вспомогательных функций (форм) возвращает nil.


#+BEGIN_SRC lisp

  (format t "gregre")

  (defun tree_search (bst obj)
    (if (null bst)
        nil
        (let ((color (node-color bst)))
          (if (and (eql (nth 0 obj) (nth 0 color))
                   (eql (nth 1 obj) (nth 1 obj))
                   (eql (nth 2 obj) (nth 2 obj)))
              (progn
                (format t "obj ~a is found ~&" obj)
                obj)
              ;; else
              (if (> (nth 0 obj) (nth 0 color))
                  (tree_search (node-r bst) obj)
                  (if (> (nth 1 obj) (nth 1 color))
                      (tree_search (node-g bst) obj)
                      (if (> (nth 2 obj) (nth 2 color))
                          (tree_search (node-b bst) obj)
                          (if (eql (nth 0 obj) (nth 0 color))
                              (tree_search (node-r bst) obj)
                              (if (eql (nth 1 obj) (nth 1 color))
                                  (tree_search (node-g bst) obj)
                                  (if (eql (nth 2 obj) (nth 2 color))
                                      (tree_search (node-b bst) obj)
                                      (if (> (nth 0 obj) (nth 1 obj))
                                          (if (> (nth 0 obj) (nth 2 obj))
                                              (tree_search (node-r bst) obj)
                                              (tree_search (node-b bst) obj))
                                          (if (> (nth 1 obj) (nth 2 obj))
                                              (tree_search (node-g bst) obj)
                                              (tree_search (node-b bst) obj)))))))))))))

  ;Форма запуска
  (defun execute_tree_search (obj)
    (let ((tree))
      (setf tree (execute_make_tree '((255 55 30) (38 255 42)
                                      (0 44 42) (16 255 0) (13 40 255))))
      (tree_search tree obj)))

  ;obj is found
  (execute_tree_search '(0 40 42))

  ;nil
  (execute_tree_search '(0 66 42))


#+END_SRC

Скопировать дерево.
Чтобы скопировать дерево, надо последовательно обойти все его узлы.

Используем рекурсию. Условие завершения рекурсии - пустое исходное
дерево. Тогда мы возвращаем его копию.

Берем содержимое каждого узла и рекурсивно вызываем его. При этом
значение будет записано при откате рекурсси назад. То есть сначала
будет записан лист, потом то, что было до него и т.д.


#+BEGIN_SRC lisp

  (defun copy_tree (bst)
    (if (and
         (null (node-r bst))
         (null (node-g bst))
         (null (node-b bst)))
        (make-node :color (node-color bst) :r nil :g nil :b nil)
        ;; else
        (make-node
         :color (node-color bst)
         :r (if (null (node-r bst))
                nil
                (copy_tree (node-r bst)))
         :g (if (null (node-g bst))
                nil
                (copy_tree (node-g bst)))
         :b (if (null (node-b bst))
                nil
                (copy_tree (node-b bst)))
         )))

#+END_SRC

** from bst to list

Напишите функцию, которая создаст список из BST, отсортированный от
меньшего к большему.

Сначала создадим бинарное дерево.
Определим структуру узла, функцию, создающую дерево, и функцию
запуска.

#+BEGIN_SRC lisp

    (defstruct node
        elt
        (r nil)
        (l nil)
        )

    (defun bst-insert (obj bst sortfun)
      (if (null bst)
          (make-node :elt obj :r nil :l nil)
          ;; else
          (let ((elt (node-elt bst)))
            (if (eql obj elt)
                bst
                (if (funcall sortfun obj elt)
                    (progn
                      ;; (format t "<")
                      ;; (format t " left true ~a ~&" (node-l bst))
                      ;; (format t " right true ~a ~&" (node-r bst))
                      (make-node
                       :elt elt
                       :l (bst-insert obj (node-l bst) sortfun)
                       :r (node-r bst)))
                    ;; else
                    ;; (format t ">")
                    (make-node
                     :elt elt
                     :r (bst-insert obj (node-r bst) sortfun)
                     ;; (format t "right false ~a ~&" (node-r bst))
                     :l (node-l bst)
                     ;; (format t "left false ~a ~&" (node-l bst)))
                    ))))))

  (defun ex-bst-insert (lst)
    (let ((tree))
      (do ((i (length lst) (- i 1)))
          ((= i 0) tree)
        (setf tree (bst-insert (car lst) tree #'>))
        (setf lst (cdr lst)))))

(ex-bst-insert '(1 3 5 6 9 2 4 8))


#+END_SRC

Теперь напишем функцию, которая создаст из дерева список.

#+BEGIN_SRC lisp

  (defun lst_bst (bst lst)
    (let ((elt (node-elt bst)))
      (format t "elt ~a lst before setf ~a ~&" elt lst)
      (setf lst (cons elt lst))
      (format t "before lst ~a ~&" lst)
      ;; если правая ветка != nil
      (if (node-r bst)
          ;; проверяем ее подветки
          ;; в случае, если  r-подветка = nil
          (if (null (node-r (node-r bst)))
              ;;так же проверяем l-подветку
              (if (null(node-l (node-r bst)))
                  ;; если обе ветки = nil
                  ;; копируем элемент из узла, не заходя в него
                  (progn
                    (setf lst (cons (node-elt(node-r bst)) lst))
                    (format t " node R true ~a ~&" lst))
                  ;; в противном случае заходим в узел
                  (lst_bst (node-r bst) lst))
              (lst_bst (node-r bst) lst))
          nil)

      ;; если левая ветка!= nil
      (if (node-l bst)
          ;; проверяем ее подветки
          (progn
            (format t " node-l ~a ~&" (node-l bst))
            (if (null (node-r (node-l bst)))
                (if (null(node-l (node-l bst)))
                    (progn
                      (setf lst (cons (node-elt(node-l bst)) lst))
                      (format t " node L true ~a ~&" lst))
                    (lst_bst (node-l bst) lst))
                (lst_bst (node-l bst) lst)))
          ;; если обе ветки текущего узла = nil,
          ;; возвращаем полученный список
          (sort lst #'>))))

  (defun ex_lst_bst (lst)
    (let ((tree (ex-bst-insert lst)))
      (let ((new_lst))
        (setf new_lst (lst_bst tree new_lst)))))

  (ex_lst_bst '(1 3 5 6 9 2 4 8))

#+END_SRC
** last task

Определить функцию, строящую:
- хэш-таблицу по ассоциативному списку
- ассоциативный список по хэш-таблице

Таблица по списку:

Функция принимает один аргумент - ассоциативный список. УЗнаем длинну
списка и создаем хэш-таблицу соответствующего размера.
Проходим по списку и устанавливаем значения в таблицу с помощью
(setf (gethash 'element nt-table) 'value_of_element). После выхода из
цикла печатаем хэш-таблицу.

#+BEGIN_SRC lisp

    (defun lst_hash (lst)
      (let ((len (length lst)))
        (let ((ht (make-hash-table :size len)))
          (do ((i len (- i 1)))
              ((= i 0) ht)
            (let ((cell (car lst)))
              (setf (gethash (car cell) ht) (cdr cell))
              (setf lst (cdr lst)))))))


          (maphash #' (lambda (a b)
                        (format t "~a = ~a ~&" a b))
                      ht))))


  ;; Запуск:

  (lst_hash '((a . 1) (b . 2) ( c . 3)))

#+END_SRC

Список по таблице:

#+BEGIN_SRC lisp

  (defun hash_lst (ht)
    (let ((lst))
      (maphash #' (lambda (a b)
                    (setf lst (cons (cons a b) lst)))
                  ht)
      (reverse lst)))

  ;;Запуск
  (let ((new_ht
         (lst_hash '((a . 1) (b . 2) ( c . 3)))))
    (hash_lst new_ht))


#+END_SRC

* Chapter 5

** let and let*

Запишите следующие выражения без let и let*
Выражения не должны вычисляться дважды.

#+BEGIN_SRC lisp

  (let ((x (car y)))
    (cons x x))

  (let* ((w (car x))
         (y (+ w z)))
    (cons w y))

#+END_SRC

Решение:

#+BEGIN_SRC lisp

   ((lambda (x)
      (setf x (cons x x)))
    (car y))

  ((lambda (w y z)
     (setf y (+ w z))
     (setf w (cons w y)))
   (car x) a b)

#+END_SRC

** quadrate of number

Определите функцию, которая возвращающую квадрат своего аргумента,
если это положительное число меньшее или равное пяти


#+BEGIN_SRC lisp

  (defun quadrate (num)
    (if (> num 0)
        (if (<= num 5)
            (progn
              (let ((new_num 0))
            (do ((i num (- i 1)))
                ((= i 0) new_num)
              (setf new_num (+ num new_num)))))
            nil)
        nil))

#+END_SRC

** mystery

Перепишьте функцию mystery с использованием cond.

Исходная функция:

Принимает 2 аргумента. Выполняется поиск в списке: в случае, если
элемент найден, возвращается его индекс в массиве, если дошли до конца
списка и ничего не нашли, возвращается nil.

Проверяем, пуст ли Y. Если пуст, возвращаем nil. Если нет, то
сравниваем, искомый объект икс с первым элементов списка Y. В случае
равенства возвращаем 0. В противном случае в переменную z записываем
результат вызова mystery с объектом и хвостом списка.

#+BEGIN_SRC lisp

  (defun mystery (x y)
    (format t " x ~a y ~a ~&" x y)
    (if (null y)
        nil
        (if (eql (car y) x)
            (progn
              (format t "obj found")
              0)
            (let ((z (mystery x (cdr y))))
              (format t " Z ~a ~&" z)
              (and z (+ z 1))))))

#+END_SRC

Переписанный вариант:

#+BEGIN_SRC lisp

  (defun new_mystery (x y)
      (format t " x ~a y ~a ~&" x y)
      (cond ((null y) nil)
             ((eql (car y) x)
              (progn
                (format t "obj found")
                0))
              ( t (let ((z (new_mystery x (cdr y))))
                (format t " Z ~a ~&" z)
                (and z (+ z 1))))))
;; запуск:
(new_mystery 1 '(2 3 5 7 8 1))

#+END_SRC

** month-num

Перепишите month-num, используя case вместо svref

Исходная функция:

Принимает номер месяца, отнимает от него 1 (потому что svref начинает
считать от нуля), ищет в списке констант, если год високосный, то прибавляет к
месяцу 1, если нет, то 0.

#+BEGIN_SRC lisp

  ;; константы и функция leap? нужны, чтоб запустить month-num

  (defconstant month
    #(0 31 59 90 120 151 181 212 243 273 304 334 365))

  (defconstant yzero 2000)

  (defun leap? (y)
    (and (zerop (mod y 4))
         (or (zerop (mod y 400))
             (not (zerop (mod y 100))))))

  (defun month-num (m y)
    (+ (svref month ( - m 1))
       (if (and (> m 2) (leap? y))
           1
           0)))

#+END_SRC
Svref получает доступ по индексу к константе из списка констант. Как
заменить ее на case?

Переписанный вариант:

#+BEGIN_SRC lisp

    (defconstant month
      #(0 31 59 90 120 151 181 212 243 273 304 334 365))

  (defun my_month-num (m y)
    (case m
      ((3 4 5 6 7 8 9 10 11 12)
       (if (leap? y)
           (+ (svref month ( - m 1)) 1)
           (+ (svref month ( - m 1)) 0)))
       ((1 2) (svref month ( - m 1)))))

#+END_SRC

** intersperse

Опеределите функцию, которая поместит заданный объект между всеми
элементами списка. Определить надо итеративно и рекурсивно.
Например:
(intersperse ’- ’(a b c d))
(A - B - C - D)

Итеративная версия:

Функция принимает два аргумента: объект и список.
Устанавливаем цикл, который отработает на 1 раз меньше, чем элементов
в списке.
В цикле мы будем брать элемент из исходного списка, соединять с
объектом, затем уменьшать исходный список. Последний элемент списка
будет добавлен вручную.

#+BEGIN_SRC lisp

  (defun mix (obj lst)
    (let ((new_lst))
      (do ((i (- (length lst) 1) (- i 1)))
          ((= i 0) new_lst)

        (setf new_lst (append (list obj)
                              (list (car lst))
                              new_lst ))
        (format t "~a ~&" new_lst)
        (setf lst (cdr lst)))
      (setf new_lst (reverse (append (list (car lst)) new_lst)))))

#+END_SRC

Рекурсивная версия:

Добавляем объект между элементами списка до тех пор, пока исходный
список не опустеет.

#+BEGIN_SRC lisp

  (defun mix-rec (obj lst lst2)
    (setf lst2 (append (list (car lst)) lst2))
    (format t "append ~a ~&" lst2)
    (setf lst (cdr lst))
    (if (null lst)
        (reverse lst2)
        (progn
          (setf lst2 (append (list obj)
                             lst2 ))
          (format t " in progn ~a ~&" lst2)
          (mix-rec obj lst lst2))))

#+END_SRC

** pair

Определите функцию, которая принимает списк чисел и возвращает истину,
если между каждой парой чисел разница равна единице. Определить
функцию с помощью:
- рекурсии
- return
- mapc
- do

Рекурсивная версия:

Проход по списку, сравниваем первый элемент и второй, второй и третий
и т.д. Условие окончания рекурсии: конец списка или выбивающаяся из
условия пара.

Возвращаем Т , если дошли до конца списка

#+BEGIN_SRC lisp

  (defun check_pair_rec (lst)
    (let ((diff))
      (if (< (nth 0 lst) (nth 1 lst))
          (setf diff (- (nth 1 lst) (nth 0 lst)))
          (setf diff (- (nth 0 lst) (nth 1 lst))))
      (if (eql diff 1)
          (if (null (cdr(cdr lst)))
              t
              (check_pair_rec (cdr lst)))
          nil)))

#+END_SRC

RETURN-FROM:

#+BEGIN_SRC lisp

  (defun check_pair (lst)
    (let (( diffr))
      (tagbody
       top
         (if (< (nth 0 lst) (nth 1 lst))
             (setf diffr ( - (nth 1 lst) (nth 0 lst)))
             (setf diffr ( - (nth 0 lst) (nth 1 lst))))
         (setf lst (cdr lst))
         (if (eql diffr 1)
             (if (null (cdr lst))
                 (return-from check_pair t)
                 (go top))
             (return-from check_pair nil)))))

#+END_SRC

MAPC:

#+BEGIN_SRC lisp

  (defun check_pair_map (lst)
    (let ((diff))
      (let ((double_lst (cdr lst)))
        (mapc #' (lambda (a b)
                   (if (< a b)
                      (setf diff (- b a))
                      (setf diff (- a b)))
                   (if (not(eql diff 1))
                       (return-from check_pair_map nil))) lst double_lst) t)))

#+END_SRC

Итеративная версия:

#+BEGIN_SRC lisp

  (defun check_pair_do (lst)
    (let ((diffr))
      (do ((i (-(length lst) 1) (- i 1)))
          ((= i 0) t)
        (if (< (nth 0 lst) (nth 1 lst))
            (setf diffr ( - (nth 1 lst) (nth 0 lst)))
            (setf diffr ( - (nth 0 lst) (nth 1 lst))))
        (setf lst (cdr lst))
        (if (not (eql diffr 1))
            (return-from check_pair_do nil)))))

#+END_SRC

** search in vector

Определите функцию от объекта и вектора, которая возвратит элементы
вектора, следующие непосредственно перед объектом. Выполнить с помощью
рекурсии и итерации.

Пример:
(precedes #\a "abracadabra")
(#\c #\d #\r)

Функция принимает 2 аргумента: объект и вектор.

Проходим по вектору и сравниваем объект с каждым
элементом. Если элемент и объект совпали, то возвращаемся на один
элемент назад и добавляем его в список найденных элементов.

Итеративная версия:

#+BEGIN_SRC lisp

  (defun vec_search (obj vec)
    (let ((new_lst))
      (let ((indx 1))
        (do ((i (- (length vec) 1) (- i 1)))
            ((= i 0) (reverse new_lst))
          (if (eql (svref vec indx) obj)
              (setf new_lst(cons (svref vec (- indx 1)) new_lst))
              nil)
          (setf indx (+ 1 indx))))))

;; Запуск:

(vec_search 'a (vector 'a 'b 'a 'd 'a 'c 'f 'a))

#+END_SRC

Рекурсивная:

Условие завершения рекурсии: индекс = (длина вектора - 1) (мы дошли до конца)

#+BEGIN_SRC lisp

  (defun vec_search_rec (obj vec indx lst)
    (if (eql indx (- (length vec) 1))
        (return-from vec_search_rec (reverse lst))
        (if (eql (svref vec indx) obj)
            (setf lst(cons (svref vec (- indx 1)) lst))
            nil))
    (vec_search_rec obj vec (+ indx 1) lst))


  ;; Запуск:

  (vec_search_rec 'a (vector 'a 'b 'a 'd 'a 'c 'f 'a) 1 '())

#+END_SRC

** min and max

Определите одиночную рекурсивную функцию, возвращающую минимальный и
максимальный элемент вектора

#+BEGIN_SRC lisp

  (defun min_max (vec sortfun lst)
    (if (< (length vec) 2)
        nil
        (let ((indx 0))
          (let (( elt (svref vec indx)))
            (do ((i (- (length vec) 1) (- i 1))
                 (indx 1 (+ indx 1)))
                ((= i 0) (setf lst (cons elt lst)))
              (format t "~%i=~A" i)
              (format t "~%indx=~A" indx)
              (if (not (funcall sortfun elt (svref vec indx)))
                  ;; true
                  (setf elt (svref vec indx))))
            (if (eql (length lst) 1)
                (min_max vec #'< lst)
                lst)))))

  ;; Запуск:

  (min_max (vector 1 3 5 0 8 4 10) #'> '())



#+END_SRC

В случае если в векторе меньше 2х элементов, возвращаем nil.

** network

Исходная программа продолжает поиск после того, как найден первый
подходящий путь. Используя catch и throw перепишите программу так,
чтоб она возвращала путь сразу после того, как он найден. Сделайте то
же самое без catch и throw.

Исходная программа:

Shortest-path принимает три аргумента: начальную точку, конечную и
саму сеть. Затемпросто вызывает bfs с "очередью", конечной точкой и
сетью.

BFS проверяет очередь. Если она пуста, значит, мы ничего не нашли
(искомого элемента нет в сети или же путь от начальной точки к нему
проложить невозможно) и тогда возвращаем nil.
В противном случае загружаем в path первый элемент очереди, а в node
(узел) первый элемент path. Если искомый элемент и node равны, то мы
возвращаем перевернутый список узлов (потому что в противном случае
порядок будет обратный: от конечной точки до начальной).
Если же узел и элемент !=, то мы рекурсивно вызываем bfs с конечной
точкой, результатом вызова new-paths и остатком прежней очереди, и
самой сетью.

New-paths принимает текущий путь, узел и сеть. Mapcar последовательно
применит функцию к каждому элементу от (cdr (assoc node net)). То есть
соединит путь и элемент n из переданного параметра лямбды.

(Assoc вернет нам список узлов, в которые можно попать из узла node).

Вопрос! Как программа может продолжать поиск по сети, даже если путь
найден, если в случае нахождения пути возвращается список узлов, это
является условием завершения рекурсии и мы выходим из функции?

Видимо, нужно чтоб выход был мгновенный, без возвращения по
рекурсивному стеку.

#+BEGIN_SRC lisp

    (defun shortest-path (start end net)
      (bfs end (list (list start)) net))

    (defun bfs (end queue net)
      (format t " BFS end ~a queue ~a  net ~a ~&" end queue net)
      (if (null queue)
          nil
          (let ((path (car queue)))
            (let ((node (car path)))
              (format t " BFS path ~a ~& " path)
              (if (eql node end)
                  (format t " reverse path ~a ~&" (reverse path))
                  (bfs end
                       (append (cdr queue)
                               (new-paths path node net))
                       net))))))


    (defun new-paths (path node net)
      (format t " NEW-PATHS path ~a node  ~a  net ~a ~&" path node net)
      (format t " nodes ~a ~&" (assoc node net))
      (mapcar #'(lambda (n)
                  (cons n path))
              (cdr (assoc node net))))

  ;; Запуск:

  (let ((min '((a b c) (b c) (c d))))
      (shortest-path 'a 'd min))


#+END_SRC

Изменения коснулись только функции bfs. Переписанный вариант без catch
и throw:

Использован return-from, который обеспечивает немедленное прерывание
выполнения и возвращает путь.

#+BEGIN_SRC lisp

  (defun bfs (end queue net)
    (format t " BFS end ~a queue ~a  net ~a ~&" end queue net)
    (if (null queue)
        nil
        (let ((path (car queue)))
          (let ((node (car path)))
            (format t " BFS path ~a ~& " path)
            (if (eql node end)
                (return-from bfs (reverse path))
                (bfs end
                     (append (cdr queue)
                             (new-paths path node net))
                     net))))))

#+END_SRC

Вариант с catch и throw:

#+BEGIN_SRC lisp

  (defun bfs (end queue net)
    (format t " BFS end ~a queue ~a  net ~a ~&" end queue net)
    (if (null queue)
        nil
        (catch 'end
          (let ((path (car queue)))
            (let ((node (car path)))
              (format t " BFS path ~a ~& " path)
              (if (eql node end)
                  (throw 'end (reverse path))
                  (bfs end
                       (append (cdr queue)
                               (new-paths path node net))
                       net)))))))

#+END_SRC

* Chapter 6

** Num of args

Определите функцию, принимающую любое количество аргументов и
возвращающую их количество

#+BEGIN_SRC lisp

  (defun param (&rest args)
    (length args))

#+END_SRC

** remove-if

Опеределите remove-if без аргументов по ключу с помощью filter.
Это функция filter. Она принимает функцию и список и с помощью функции
проводит над ним операции.

#+BEGIN_SRC lisp

  (filter #'(lambda (x)
              (and (evenp x) (+ x 10)))
            '(1 2 3 4 5 6 7))
#+END_SRC

remove-if:
принимает два аргумента: последовательность и предикат
нужно:
- проход по списку
- проверка, соответствует ли текущий элемент списка предикату
- если соответствует, то не помещать его в новый список
- если не соответствует, то проигнорироватьи пойти дальше

Вопрос! Предкаты бывают разные, как унифицировать работу функции для
разных предикатов?

#+BEGIN_SRC lisp

  (defun myremove-if (fn lst)
    (let ((new_lst))
      (do (( i (length lst) (- i 1))
           (indx 0 (+ indx 1)))
          ((= i 0) (reverse new_lst))
          (if (not(funcall fn (nth indx lst)))
              (setf new_lst(cons (nth indx lst) new_lst))))))

#+END_SRC

** most

Определите функцию most так, чтоб она возвращала 2 значения -
элемента, которые имеют наибольший вес

Итак, это исходная функция.

#+BEGIN_SRC lisp

    ;; принимает 2 аргумента: функцию и список
    (defun most (fn lst)
      ;; если список пустой
      (if (null lst)
          ;; возвращаем nil
          (values nil nil)
          ;; в противном случае устанавливаем переменную wins,
          ;; щаписываем в нее первый элемент списка,
          ;; узнаем ее длину (в нашем случае) и записываем в max
          (let* ((wins (car lst))
                 (max (funcall fn wins)))
            ;; затем устанавливаем проход по остатку списка
            (dolist (obj (cdr lst))
              ;; записываем в переменную score результат от вызова функции-параметра и объекта
              (let ((score (funcall fn obj)))
                ;; в случае если score больше max
                (when (> score max)
                  ;; то мы устновим в wins значение объекта
                  (progn
                    (setf wins obj
                          max score)
                    (format t" wins ~a obj ~a score ~a max ~a ~&" wins obj score max)))))
            ;; после того, как цикл отработает, мы возвращаем два начения
            (values wins max))))


  (most #'length '((a b) (a b c) (a)))

#+END_SRC lisp

Мой вариант:

#+BEGIN_SRC lisp

  ;;запуск
  (my_most #'length '((a b) (a b c d) (a b c d e)  (a b c) (a)))


  (defun my_most (fn lst)
    (if (null lst)
        (values nil nil)
        (let ((win1 (search_elt fn lst)))
          ( setf lst (remove win1 lst :test #'equal))
          (let ((win2 (search_elt fn lst)))
            (values win1 win2)))))

  (defun search_elt (fn lst)
    (format t "lst ~a ~&" lst)
    (let* ((wins (car lst))
           (max (funcall fn wins)))
      (do ((i ( - (length lst) 1) (- i 1))
           (indx 1 (+ indx 1)))
          ((= i 0) wins)
        (format t " i ~a ~&" i)
        (let* ((obj (nth indx lst))
               (score (funcall fn obj)))
          (if (> score max)
              (progn
                (setf wins obj)
                (setf max (funcall fn wins))))))))

#+END_SRC

** improved bin-search

Определите версию bin-search, иcпользующую
ключи :key, :test, :start и :end, имеющие обычные для них значения по
умолчанию.

Исходная функция:

#+BEGIN_SRC lisp

  (defun bin-search (obj vec)
    (let ((len (length vec)))
      (and (not (zerop len))
           (finder obj vec 0 (- len 1)))))

  (defun finder (obj vec start end)
    (let ((range (- end start)))
      (if (zerop range)
          (if (eql obj (aref vec start))
              obj
              nil)
          (let ((mid (+ start (round (/ range 2)))))
            (let ((obj2 (aref vec mid)))
              (if (< obj obj2)
                  (finder obj vec start (- mid 1))
                  (if (> obj obj2)
                      (finder obj vec (+ mid 1) end)
                      obj)))))))
#+END_SRC

Мой вариант:

#+BEGIN_SRC lisp


    (defun bin-search (obj vec &key (start 0) (end (- (length vec) 1)) (test #'> )
                                 (key nil key-supplied-p))
      (let ((len (length vec)))
        (format t " end ~a ~&" end)
        (if (zerop len)
            nil
            (tagbody
             top
               (format t "start ~a end ~a ~&" start end)
               (let ((range (- end start)))
                 (if (zerop range)
                     (if (and t key-supplied-p)
                         (and(eql obj (funcall key (aref vec start)))
                             (return-from bin-search obj))
                         (and(eql obj (aref vec start))
                             (return-from bin-search obj)))
                     (let ((mid (+ start (round (/ range 2)))))
                       (let ((obj2))
                         (if (and t key-supplied-p)
                             (progn
                               (setf obj2 (funcall key (aref vec mid)))
                               (format t "mid with key ~a ~&" mid))
                             (progn
                               (setf obj2 (aref vec mid))
                               (format t "mid ~a ~&" mid)))
                         (if (eql obj obj2)
                             (progn
                               (format t "obj ~a ~&" obj)
                               (return-from bin-search obj))
                             (if (funcall test obj obj2)
                                 (progn
                                   (format t "bigger ~&")
                                   (setf start (+ mid 1))
                                   (go top))
                                 (progn
                                   (format t "smaller ~&")
                                   (setf end (- mid 1))
                                   (go top))))))))))))

  ;;варианты запуска
  (let ((vec (vector 1 2 3 4 5 6 7 8)))
    (bin-search 3 vec))

  (let ((vec (vector '(8 7) '(6 5) '(4 3) '(2 1))))
    (bin-search 2 vec :test #'< :key #'car))

#+END_SRC

** TODO Improved tokens

Определите версию tokens, которая использует
ключи :test и :start, по умолчанию равные #’constituent и 0
соответственно.

Исходная версия:
Принимает строку и предикат. Возвращает все подстроки, соответствующие
этому предикату.

#+BEGIN_SRC lisp

  (defun tokens (str test start)
    (let ((p1 (position-if test str :start start)))
      (if p1
          (let ((p2 (position-if #'(lambda (c)
                                     (not (funcall test c)))
                                 str :start p1)))
            (cons (subseq str p1 p2)
                  (if p2
                      (tokens str test p2)
                      nil)))
          nil)))

  (defun constituent (c)
    (and (graphic-char-p c)
         (not (char= c #\ ))))

  ;; запуск

  (tokens "ab12 3cde.fgh" #'constituent 0)

#+END_SRC

Моя версия:
Не распознает ключ :test
Возможно, проблема в том, что position-if не принимает
ключ :test. Значит, надо каким-то образом передать функции предикант,
но не с помощью ключа :test

Не распознанный &key constituent.
#+BEGIN_SRC lisp
  (defun constituent (c)
    (and (graphic-char-p c)
         (not (char= c #\Space))))

  (defun tokens (str &key (test nil param-exist) (start 0))
    (let ((test (if (null param-exist)
                    #'constituent
                    test)))
      (let ((p1 (position-if test str :start start)))
        (if p1
            (let ((p2 (position-if #'(lambda (c)
                                       (not (funcall test c)))
                                   str :start p1)))
              ;; (subseq str p1 p2)
              (cons (subseq str p1 p2)
                    (if p2
                        (tokens str :test test :start p2)
                        nil)))
            nil)
        )))

  ;; (tokens " ab12 3cde.fgh" :test #'constituent)

  ;; (tokens "ab12 3cde.fgh")


  (tokens "ab12 3cde.fgh")

#+END_SRC

** bigger_num

Определите функцию, которая принимает число и возвращает его же, если
в предыдущем вызове функции число было меньше текущего числа. При этом
первый вызов должен вернуть nil.


#+BEGIN_SRC lisp

  (let ((num))
    (defun fn (x)
      (if (null num)
          (progn
            (setf num x)
            nil)
          (if ( > x num)
              x
              nil))))

  ;; запуск (запустить оба по очереди)
  ;; (fn 1) (fn 3)

#+END_SRC

** bigger_num 2

Определите функцию, принимающую число и возвращающую наибольшее число
из когда-либо принятых ею.

*** style-warning: The return value of STABLE-SORT-LIST should not be discarded,
*** но функция стабильно работает

#+BEGIN_SRC lisp

  (let ((lst))
    (defun fn (x)
      (if (null lst)
          (progn
            (setf lst (cons x lst))
            x)
          (progn
            (setf lst (cons x lst))
            (sort lst #'>)
            (car lst)))))
  ;; запуск
  ;; (fn 1) (fn 2) (fn 3) (fn 2) и т.д.

#+END_SRC
** expensive

Предположим, что функция expensive принимает числа от 0 до 100 и
проводит над ними дорогостоящие вычисления. Определите функцию frugal,
возвращающую тот же ответ, что и expensive, но при этом она передает
аргумент expensive только в том случае, если он не встречался ранее.

В мане нет никакой функции expensive, поэтому я определю ее
самостоятельно.

#+BEGIN_SRC lisp

  (defun expensive (x)
    (+ x 1))

  (let ((args))
    (defun frugal (num)
      (if (member num args)
          nil
          (progn
            (setf args (cons num args))
            (expensive num)))))

#+END_SRC

** new_apply

Определите функцию на подобие apply, но где все числа, которые могут
быть напечатаны, выводятся в восьмиричной системе.

Apply принимает сколько угодно аргументов, но последний из них должен
быть список. А еще apply принимает функцию и выполняет действия над
остальными аргументами, согласно этой функции.

Мой вариант будет принимать список чисел и функцию. Возвращаемое
значение будет печататься в восьмиричной системе.

* Chapter 7

** list of str

Напишите функцию, которая возвратит список из строк, прочитанных из
файла.

- создать путь к файлу
- открыть файл (with-open-file)
- установить цикл (читать построчно и записывать в список, пока файл
  не кончится)
- вернуть список

#+BEGIN_SRC lisp

  (defun read_file (file)
    (let ((path (make-pathname :name file)))
      (let ((pipe (open path :direction :input)))
        (let ((lst))
        (do ((line (read-line pipe nil 'eof)
                   (read-line pipe nil 'eof)))
            ((eql line 'eof))
          (setf lst (append (list line) lst)))
        (close pipe)
        (return-from read_file (reverse lst))))))


  ;; запуск (read_file "test.txt")

#+END_SRC

** list of expr

Определите функцию, возвращающую список выражений, прочитанных из
заданного файла.

#+BEGIN_SRC lisp

  (defun read_expr (file)
    (let ((path (make-pathname :name file)))
      (let ((pipe (open path :direction :input)))
        (let ((lst))
        (do ((expr (read pipe nil 'eof)
                   (read pipe nil 'eof)))
            ((eql expr 'eof))
          (setf lst (append (list expr) lst)))
        (close pipe)
        (return-from read_expr (reverse lst))))))


  ;; запуск (read_expr "expr_test.txt")

#+END_SRC

** from-to

В файле некоторого формата комментарии обозначаются знаком
~%~. Содержимое между знаками комментария игнориуется. Напишите функцию,
принимающую два файла, которая перепишет содержимое первого файла во
второй, вырезав комментарии.

- функция принимает два файла
- определить два пути
- определить два потока: один на чтение, другой на запись
- определить цикл, который посимвольно будет читать из первого файла
- внутри цикла определить if: если встречен знак ~%~, то не записываем
  во второй файл, пока не встретим второй ~%~.
- вернуть второй файл

Использовать read-char.

Запись производится, но с комментами. Не срабатывает проверка в ифе!

#+BEGIN_SRC lisp

  (defun new_file (file1 file2)
    (let ((path1 (make-pathname :name file1)))
      (let ((path2 (make-pathname :name file2)))
        ;;чтение
        (let ((pipe1 (open path1 :direction :input)))
          ;; запись
          (let ((pipe2 (open path2 :direction :output
                             :if-exists :supersede)))
            (let ((check 0))
              ;; запись посимвольно во второй файл
              (do ((chr (read-char pipe1 nil :eof)
                        (read-char pipe1 nil :eof)))
                  ((eql chr :eof))
                (if (and (zerop check) (not (eql chr #\%)))
                    (format pipe2 "~a" chr)
                    (if (eql chr #\%)
                        (progn
                          (setf check (+ check 1))
                          (if (eql check 2)
                              (setf check 0))))))
              (close pipe1)
              (close pipe2)
              ;; чтение из второго файла (проверяем, что там оказалось после записи)
              (let ((pipe2 (open path2 :direction :input)))
                (do ((line (read-line pipe2 nil 'eof)
                           (read-line pipe2 nil 'eof)))
                    ((eql line 'eof))
                  (format t "~a" line)))))))))

#+END_SRC

** print array

Определите функцию, принимающую двухмерный массив числе с плавающей
точкой. Отобразите массив в виде аккуратных колонок. Каждый элемент
должен печататься с двумя знаками после запятой на пространстве 10 знаков.


#+BEGIN_SRC lisp

  (defun print_array (arr)
    (let ((lst_dim (array-dimensions arr)))
        (do ((ver 0 (+ ver 1)))
            ((>= ver (nth 1 lst_dim)))
          (format t "~10,2,0,'*,' F ~10,2,0,'*,' F ~&"
                  (aref arr 0 ver) (aref arr 1 ver)))))

  ;; запуск
  (print_array(make-array '(2 3) :initial-contents
                          '((1.2234 3.111 4.111) (1.222 3.555 6.678))))

#+END_SRC

** new stream-subst

Измените функцию stream-subst так, чтобы шаблон мог содержать
элемент, соответствующий: любой цифре, любой цифре и
букве, любому знаку. Шаблон должен уметь распознавать любые читаемые
знаки. (Подсказка: old теперь не обязательно должен быть строкой.)

Перед нами исхоная версия приложения по замене строк.
Я так понимаю, что теперь нужно сделать так, чтоб шаблон old мог быть
чем угодно: любым знаком, любой цифре, цифре и букве и т.д. То есть на
данный момент распознаются только буквы (строки).


#+BEGIN_SRC lisp

  ;; file-subst принимает на вход 4 аргумента:
  ;; строку, подлежащую замене, строку, которая заменит старую, файл,
  ;; входной и выходной файлы.
  (defun file-subst (old new file1 file2)
    ;; открываем потоки между файлами: читаем из  file1, пишем в file2
    (with-open-file (in file1 :direction :input)
      (with-open-file (out file2 :direction :output
                           :if-exists :supersede)
        ;; вызываем алгоритм замены строк
        (stream-subst old new in out))))

  (defun stream-subst (old new in out)
    ;; устанавливаем переменные: позицию, длину старой строки, новый буфер,
    ;; и from-buf (в эту переменную будут читаться чимволы из промежуточного буфера)
    (let* ((pos 0)
           (len (length old))
           (buf (new-buf len))
           (from-buf nil))

      ;; в переменную цикла "с" записывается символ из файла in,
      ;; условие завершения цикла - конец файла. На каждой итерации в переменную
      ;; "с" попадет либо содержимое from-buf (т.e следующий символ из буфера),
      ;;  либо следующий символ из файла (смотря, что окажется истинным)

      (do ((c (read-char in nil :eof)
              (or (setf from-buf (buf-next buf))
                  (read-char in nil :eof))))
          ((eql c :eof))

        ;; "с" = символу из строки old с заданным индексом?
        (cond ((char= c (char old pos))
               ;; Да!
               ;; инкрементируем pos
               (incf pos)
               ;; pos = len?
               (cond ((= pos len)
                      ;; Да! (строки совпали!)  ; 3
                      ;; печатаем новую строку в выходной файл
                      (princ new out)
                      ;; устанавливаем индекс в 0 снова
                      (setf pos 0)
                      ;; очищаем промежуточный буфер
                      (buf-clear buf))

                     ;; pos != len (продолжаем сравнивать строки)
                     ;; если from-buf пустой (?)
                     ((not from-buf)             ;2
                       ;; добавляем текщий элемент в промежуточный буфер
                      (buf-insert c buf))))

              ;; "с" != символу из старой строки
              ;; проверяем pos на 0 (вдруг раньше символы совпадали?)
              ((zerop pos)    ;; 1
               ;; pos = 0!
               ;; сразу печатаем символ в выходной файл
               (princ c out)
               ;; если в from-buf что-то было
               ;; все очищаем
               ;;(иначе при следующих проверках и печатях будут
               ;; печататься и проверяться старые, ненужные символы)
               (when from-buf
                 (buf-pop buf)
                 (buf-reset buf)))

              (t                 ;;4
               ;; если в from-buf нет ничего
               (unless from-buf
                 ;; добавляем символ в буфер
                 (buf-insert c buf))
               ;; эм, что?
               (princ (buf-pop buf) out)
               ;; очищаем буфер
               (buf-reset buf)
               ;; устанавливаем индекс в 0
               (setf pos 0))))
      ;; после того как цикл отработал, сливаем остаток из буфера в выходной файл
      (buf-flush buf out)))


(file-subst "new4" "new" "stream-test.txt" "right-pattern.txt")

#+END_SRC

Блок дочерних функций, необходимых для stream-subst
#+BEGIN_SRC lisp

    ;; создаем структуру buf
    ;; ее поля - это ветор и его индексы (поэтому все значения - 1, индекс начинается с нуля)
    (defstruct buf
      vec (start -1) (used -1) (new -1) (end -1))

    ;; bref позволяет получить значение по заданному индексу
    (defun bref (buf n)
      ;; получаем вектор из поля структуры и индекс, поделив заданный индекс на размер буфера
      ;; зачем делить?), и все это передаем svref, что  вернет элемент
      (svref (buf-vec buf)
             (mod n (length (buf-vec buf)))))

    ;; обратная операция: кладем элемент по индексу
    (defun (setf bref) (val buf n)
      (setf (svref (buf-vec buf)
                   (mod n (length (buf-vec buf))))
            val))
    ;; создаем кольцевой буфер заданного размера
    (defun new-buf (len)
      (make-buf :vec (make-array len)))

    ;; функция добавляет элемент к буферу, аргументы: элемент и буфер
    ;; сначала передаем функции bref буфер и инкрементированный индекс end, затем setf запишет
    ;; по этому индексу значение x
    (defun buf-insert (x b)
      (setf (bref b (incf (buf-end b))) x))

    ;; обратная операция: стираем элемент из вектора
    (defun buf-pop (b)
      (prog1
          (bref b (incf (buf-start b)))
        (setf (buf-used b) (buf-start b)
              (buf-new b) (buf-end b))))

    ;; чтение следующего элемента из буфера без его извлечения
    (defun buf-next (b)
      (when (< (buf-used b) (buf-new b))
        (bref b (incf (buf-used b)))))

  (defun buf-reset (b)
    (setf (buf-used b) (buf-start b)
          (buf-new b) (buf-end b)))

  (defun buf-clear (b)
    (setf (buf-start b) -1 (buf-used b) -1
          (buf-new b) -1 (buf-end b) -1))

  (defun buf-flush (b str)
    (do ((i (1+ (buf-used b)) (1+ i)))
        ((> i (buf-end b)))
      (princ (bref b i) str)))

#+END_SRC

Не понятен смысл задания, т.к. и с цифрами, и с буквами функция
работает корректно, если ввести шаблоны в виде строк.

* Сhapter 8

** File and Ring

Поместите в программу на рисунке 7.1 код, который помещает ее содержимое в пакет
"Ring", аналогично для кода на рисунке 7.2 создайте пакет "FILE". Уже
имеющийся код должен остаться без изменений.

СНАЧАЛА ЗАЛИТЬ RING, ПОТОМ FILE!

#+BEGIN_SRC lisp

  (defpackage "FILE"
    (:use "COMMON-LISP" "RING")
    (:nicknames "FILE"))

  (in-package file)

    ;; file-subst принимает на вход 4 аргумента:
    ;; строку, подлежащую замене, строку, которая заменит старую, файл,
    ;; входной и выходной файлы.
    (defun file-subst (old new file1 file2)
      ;; открываем потоки между файлами: читаем из  file1, пишем в file2
      (with-open-file (in file1 :direction :input)
        (with-open-file (out file2 :direction :output
                             :if-exists :supersede)
          ;; вызываем алгоритм замены строк
          (stream-subst old new in out))))

    (defun stream-subst (old new in out)
      ;; устанавливаем переменные: позицию, длину старой строки, новый буфер,
      ;; и from-buf (в эту переменную будут читаться чимволы из промежуточного буфера)
      (let* ((pos 0)
             (len (length old))
             (buf (new-buf len))
             (from-buf nil))

        ;; в переменную цикла "с" записывается символ из файла in,
        ;; условие завершения цикла - конец файла. На каждой итерации в переменную
        ;; "с" попадет либо содержимое from-buf (т.e следующий символ из буфера),
        ;;  либо следующий символ из файла (смотря, что окажется истинным)

        (do ((c (read-char in nil :eof)
                (or (setf from-buf (buf-next buf))
                    (read-char in nil :eof))))
            ((eql c :eof))

          ;; "с" = символу из строки old с заданным индексом?
          (cond ((char= c (char old pos))
                 ;; Да!
                 ;; инкрементируем pos
                 (incf pos)
                 ;; pos = len?
                 (cond ((= pos len)
                        ;; Да! (строки совпали!)  ; 3
                        ;; печатаем новую строку в выходной файл
                        (princ new out)
                        ;; устанавливаем индекс в 0 снова
                        (setf pos 0)
                        ;; очищаем промежуточный буфер
                        (buf-clear buf))

                       ;; pos != len (продолжаем сравнивать строки)
                       ;; если from-buf пустой (?)
                       ((not from-buf)             ;2
                         ;; добавляем текщий элемент в промежуточный буфер
                        (buf-insert c buf))))

                ;; "с" != символу из старой строки
                ;; проверяем pos на 0 (вдруг раньше символы совпадали?)
                ((zerop pos)    ;; 1
                 ;; pos = 0!
                 ;; сразу печатаем символ в выходной файл
                 (princ c out)
                 ;; если в from-buf что-то было
                 ;; все очищаем
                 ;;(иначе при следующих проверках и печатях будут
                 ;; печататься и проверяться старые, ненужные символы)
                 (when from-buf
                   (buf-pop buf)
                   (buf-reset buf)))

                (t                 ;;4
                 ;; если в from-buf нет ничего
                 (unless from-buf
                   ;; добавляем символ в буфер
                   (buf-insert c buf))
                 ;; эм, что?
                 (princ (buf-pop buf) out)
                 ;; очищаем буфер
                 (buf-reset buf)
                 ;; устанавливаем индекс в 0
                 (setf pos 0))))
        ;; после того как цикл отработал, сливаем остаток из буфера в выходной файл
        (buf-flush buf out)))


  (file-subst "new4" "new" "stream-test.txt" "right-pattern.txt")

#+END_SRC


Блок дочерних функций, необходимых для stream-subst
#+BEGIN_SRC lisp
  (defpackage "RING"
    (:use "COMMON-LISP")
    (:nicknames "RING")
    (:export "BUF" "BREF" "SETF BREF" "NEW-BUF" "BUF-INSERT" "BUF-POP"
             "BUF-NEXT" "BUF-RESET" "BUF-CLEAR" "BUF-FLUSH"))

  (in-package ring)

    ;; создаем структуру buf
    ;; ее поля - это ветор и его индексы (поэтому все значения - 1, индекс начинается с нуля)
    (defstruct buf
      vec (start -1) (used -1) (new -1) (end -1))

    ;; bref позволяет получить значение по заданному индексу
    (defun bref (buf n)
      ;; получаем вектор из поля структуры и индекс, поделив заданный индекс на размер буфера
      ;; зачем делить?), и все это передаем svref, что  вернет элемент
      (svref (buf-vec buf)
             (mod n (length (buf-vec buf)))))

    ;; обратная операция: кладем элемент по индексу
    (defun (setf bref) (val buf n)
      (setf (svref (buf-vec buf)
                   (mod n (length (buf-vec buf))))
            val))
    ;; создаем кольцевой буфер заданного размера
    (defun new-buf (len)
      (make-buf :vec (make-array len)))

    ;; функция добавляет элемент к буферу, аргументы: элемент и буфер
    ;; сначала передаем функции bref буфер и инкрементированный индекс end, затем setf запишет
    ;; по этому индексу значение x
    (defun buf-insert (x b)
      (setf (bref b (incf (buf-end b))) x))

    ;; обратная операция: стираем элемент из вектора
    (defun buf-pop (b)
      (prog1
          (bref b (incf (buf-start b)))
        (setf (buf-used b) (buf-start b)
              (buf-new b) (buf-end b))))

    ;; чтение следующего элемента из буфера без его извлечения
    (defun buf-next (b)
      (when (< (buf-used b) (buf-new b))
        (bref b (incf (buf-used b)))))

  (defun buf-reset (b)
    (setf (buf-used b) (buf-start b)
          (buf-new b) (buf-end b)))

  (defun buf-clear (b)
    (setf (buf-start b) -1 (buf-used b) -1
          (buf-new b) -1 (buf-end b) -1))

  (defun buf-flush (b str)
    (do ((i (1+ (buf-used b)) (1+ i)))
        ((> i (buf-end b)))
      (princ (bref b i) str)))

#+END_SRC

** Henley

Напишите программу, проверяющую, была ли заданная цитата
произведена с помощью Henley (см. исходный код в shpargalka.org).

Вижу только один способ проверки:
если хэш-таблица с прочитанным абзацом пуста, значит, строка была
сгенерирована не HENLEY, т.к. программа даже не запускалась

#+BEGIN_SRC lisp



#+END_SRC

** Henley2

Модифицируйте Henley так, чтобы она принимала слово и генерировала
предложение, где это слово используется в середине.

Henley исходном коде принимает абзац, который разбирает, а затем
пересобирает.

- вычислить длину предложения, разделить на 2
- присвоить полученную середину индексу
- присвоить каждому слову в предложении позицию
- когда позиция слова в предложении совпадет с индексом, напечатать
  слово-параметр
- продолжить печать предложения


Первая часть Henley останется без изменений: по-прежнему принимает
абзац и возвращает хэш-таблицу, заполненную словами.

#+BEGIN_SRC lisp

  ;; хэш-таблица для прочитанного абзаца
  (defparameter *words* (make-hash-table :size 10000))

  ;; максимум в абзаце может быть 100 слов
  (defconstant maxword 100)

  ;;чтение текста
  (defun read-text (file)
    (let ((pathname (make-pathname :name file)))
    ;; открываем файл на чтение
    (with-open-file (s pathname :direction :input)
      ;; создаем буфер исходя из идеи, что в обзаце 100 слов
      (let ((buffer (make-string maxword))
            ;; устанавливаем индекс
            (pos 0))
        ;; цикл обеспечит чтение текст посимвольно (не путать символы-буквами
        ;; с символами-идентификаторами, видимо, недоработка переводчика)
        ;; условие конца цткла - конец файла
        (do ((c (read-char s nil :eof)
                (read-char s nil :eof)))
            ((eql c :eof))
          ;; если считанный знак буква или апостроф
          (if (or (alpha-char-p c) (char= c #\'))
              ;; записываем его в буфер и инкрементируем индекс
              (progn
                (setf (aref buffer pos) c)
                (incf pos))
              ;; считанный знак != буква или апостроф, слово кончилось
              ;; pos = 0?
              (progn
                (unless (zerop pos)
                  ;; нет
                  ;; накопленное слово превращаем в символ (тот, что заглавными буквами
                  ;; пишется, символ-идентификатор)
                  (see (intern (string-downcase
                                (subseq buffer 0 pos))))
                  ;; устанавливаем индекс в 0
                  (setf pos 0))
                ;; если символ = знак пунктупции, то punc выдаст нам его как есть
                (let ((p (punc c)))
                  ;; что значит этот иф?
                  (if p (see p))))))))))

  (defun punc (c)
    (case c
      (#\. '|.|) (#\, '|,|) (#\; '|;|)
      (#\! '|!|) (#\? '|?|) ))
  ;; фнукция see полученный символ запишет в таблицу слов
  ;; так же она "помнит" предыдущее слово с помощью prev. По умолчанию prev - это точка.

  (let ((prev '|.|))
    ;; получаем на вход символ
    (defun see (symb)
      ;; устанавливаем пару символ-ключ.В нашем варианте это предудыщее слово - текущее слово
      ;; устанавливаем пару
      (let ((pair (assoc symb (gethash prev *words*))))
        ;; пара пустая?
        (if (null pair)
            ;; зачит, это первое слово в таблице, таки запишем (слово. 1)
            (push (cons symb 1) (gethash prev *words*))
            ;; в противном случае инкрементируем cdr образовавшейся пары
            ;; (получилось (слово . 2)
            (incf (cdr pair))))
      ;; устанавливаем текущий символ в prev
      (setf prev symb)))



#+END_SRC

Вторая часть

#+BEGIN_SRC lisp

  ;; середина предложения
  (let ((mid))
    ;; принимает на вход количество слов в новом тексте и последнее слово (необязательно)
    (defun generate-text (n word &optional (prev '|.|))
      ;; если количество слов 0
      (if (zerop n)
          ;; печатаем пустую строку
          (terpri)
          ;; если mid пуста, вычислим ее
          (progn
          (if (null mid)
              (setf mid (floor(/ n 2))))
          ;; если дошли до середины предложения, вставляем слово
          (if (eql mid n)
              (format t "~A " word))
          (let ((next (random-next prev)))
            ;; выводим его
            (format t "~A " next)
            ;; и вызываем генерацию текста снова
            (generate-text (1- n) word next))))))

  ;; принимает на вход последний символ
  (defun random-next (prev)
    ;; получаем в choises пару, связанную с prev
    (let* ((choices (gethash prev *words*))
           ;; получаем рандомное слово
           (i (random (reduce #'+ choices
                              :key #'cdr))))
      (dolist (pair choices)
        (if (minusp (decf i (cdr pair)))
            (return (car pair))))))


  ;; запуск: зарузить все из первой части HENLEY, все из второй части. Затем вызвать
  ;; (read-text "test.txt") (generate-text 10 'dog)

#+END_SRC

* Chapter 9

** list pf floats

Напишите функцию, принимающую список действительных чисел, и
возвращающую истину, если числа расположены в порядке неубывания.

Формально должно быть выражение (> число число число). Только так
передать параметры в функцию нельзя, а применить > к списку невозможно

#+BEGIN_SRC lisp

  (defun floats (lst)
    (do ((i (- (length lst) 1) (- i 1)))
        ((= i 0) t)
      (if (> (nth 0 lst) (nth 1 lst))
          (return-from floats nil)
          (setf lst (cdr lst)))))

  ;;запуск
  (floats '(1.222 2.222 3.333 4.444 5.555))

#+END_SRC

** cents

Определите функцию, принимающую целочисленную величину
(количество центов) и  возвращающую четыре значения,
показывающие, как собрать заданную сумму с помощью монет стоимостью
25, 10, 5 и 1 цент, используя наименьшее их количество

- для возврата 4х значений понадобится value в формате (25 . 2) - 25
  центов по 2 раза
- проверяем, насколько бльшое число. Во сколько раз оно больше 25.
- если меньше, то то же самое проверяем с помощью 10, 2 и 1 цента

(float (/ 100 27))

#+BEGIN_SRC lisp

  (defun cents (num)
    (let ((tf (cons 25  0))
          (ten (cons 10 0))
          (one (cons 1 0))
          (two (cons 2 0))
          (result))
      (tagbody
         top
         (if (>= num 25)
             (progn
               (setf result (floor (/ num 25)))
               ;;(format t " tf ~a ~&" result)
               (setf (cdr tf) (+ (cdr tf) result))
               (setf num (- num (* result 25)))
               ;;(format t "tf num ~a ~&" num)
               (go top))
             (if (>= num 10)
                 (progn
                   (setf result (floor (/ num 10)))
                   ;;(format t " ten ~a ~&" result)
                   (setf (cdr ten) (+ (cdr ten) result))
                   (setf num (- num (* result 10)))
                   ;;(format t "tf num ~a ~&" num)
                   (go top))
                 (if (>= num 2)
                     (progn
                       (setf result (floor (/ num 2)))
                       ;;(format t " two ~a ~&" result)
                       (setf (cdr two) (+ (cdr two) result))
                       (setf num (- num (* result 2)))
                       ;;(format t "tf num ~a ~&" num)
                       (go top))
                     (if (eql num 1)
                         (progn
                           (setf (cdr one) (+ 1 (cdr one)))
                           (setf num (- 1 num))
                           (go top))
                         (if (not (eql num 0))
                             (go top)
                             ;;(progn
                            ;; (format t "~a ~a ~A ~A ~&" tf ten two one)
                             (return-from cents (values tf ten two one))))))))))



#+END_SRC

** vectors

Напишите функцию, принимающую 8 действительных чисел, прдставляющих
собой два ветора в двухмерном пространстве. Если отрезки не
пересекаются, функция вернет nil, в противном случае вернет коорднаты
точки пересечения.

Не могу найти закономерность, по которой можно определить, есть точка
пересечения или нет.

#+BEGIN_SRC lisp


#+END_SRC

* Chapter 10

** comma

Пусть x = a, y = b, z = (c d). Запишите выражения с обратной
кавычкой, содержащие только заданные переменные (x, y и z) и
приводящие к следующим результатам:

(a) ((C D) A Z)
(b) (X B C D)
(c) ((C D A) Z)

Не читает обратную кавычку.
a)

#+BEGIN_SRC lisp

  (let ((x 'a)
       (y 'b)
       (z (list 'c 'd)))
   (list (z 'a 'z)))

#+END_SRC

b)

#+BEGIN_SRC lisp

   (let ((x 'a)
        (y 'b)
        (z (list 'c 'd)))
    (append (list 'x y) z))

#+END_SRC


** my_if

Определите if через cond.

Мой иф должен быть макросом. Будет принимать одно выражение по
обязательно и одно опционально. Выражение будет вставляться в макрос и
раскрываться там

#+BEGIN_SRC lisp

  (defmacro my_if (expr_true true_part &optional expr_false false_part)
    (cond ((@,expr_true) true_part)
          ((@,expr_false) false_part)))

#+END_SRC
