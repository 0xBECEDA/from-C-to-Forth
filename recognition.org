#+STARTUP: showall indent hidestars

* План
** Введение
Цель данного проекта - распознавание текста с картинки без использования
нейросетей вроде сети Tesseract, поскольку точность такого распознавания
недостаточно высока.

Как человек читает текст? Мы не думаем о проблах между словами, строчками
и абзацами, а фокусируемся исключительно на тексте. В нашей программе мы
будем поступать так же. В качестве основной технологии будем использовать
~клеточные автоматы~. Они будут "отсекать" ненужные, фоновые участки
картинки и распознавать шаблоны букв.

Справка: пометки ~TO DO~ означает, что в пункте много неясностей или нет
вообще ничего. Пока пункт не имеет статус ~DONE~, он не считается
завершенным, значит, там ее есть над чем работать.

** План действий
*** Получить блоки чистого текста.

Под блоками "чистого текста" понимаются прямоугольники абзацев без пробелов между ними.
Для достижения этого результата мы:

- делим картинку на сегменты единого размера
- в каждом сегменте запускаем по клеточному автомату
- ждем, пока клеточные автоматы пометят все ненужное

*** TODO Внутреннее устройство клеточного автомата, как автоматы общаются между собой
Для общения объектов программы между собой предлагаю модель передачи
сообщений.

Каждый клеточный автомат представляет собой самостоятельный объект,
который содержит:
- свой уникальный ~id~
- структуру для хранения пикселей
- диспетчер для управления внутренними процедурами

**** Механизм работы клеточного автомата при поиске блоков с фоном
Итак, мы запустили в каждом сегменте по клеточному автомату. Предположим,
что клеточные автоматы начинают анализировать сегменты с середины - так
удобнее длядальнейшей работы (?)

Каждому клеточному автомату присваиваем ~id~ - идентификационный номер -
чтоб можно было отличить один автомат от другого.

***** Механизм работы клеточного автомата в его сегменте.
1. Проверяем текущий пиксель.
Нам нужно понять, фоновый фоновой ли это пиксель, и если да, то "свободен"
ли он. Вдруг его уже пометил другой клеточный автомат?

Действуем по следующему алгоритму:
1.1 пиксель цвета фона?
 ~Нет!~ - что делать тогда?
 ~Да!~:
1.2 пиксель помечен?
 ~Нет!~:
 Помечаем пиксель как принадлежащий текущему клеточному автомату:
 - записываем в альфаканал пикселя ~id~ нашедшего его автомата
 - записываем координаты пикселя (куда?). Варианты: список,
   массив, хэш-таблица, бинарное дерево поиска. У каждого автомата своя
   область памяти для записи координат.
Проверяем соседние пиксели с 4х сторон: повторить алгоритм, начиная с пункта 1.1.
 ~Да!~:
 Мы столкнулись с другим клеточным автоматом.

***** Что делать при столкновении с другим клеточным автоматом.
Наши автоматы работают не только в пределах своих сегментов. Нам нужно,
чтоб они выходили за пределы своих изначальных зон и "сливались" друг с
другом, пока не кончится все непомеченное фоновое пространство на
картинке.

Как мы понимаем, что столкнулись с зоной другого автомата?
Мы нашли фоновый пиксель, который уже кем-то помечен. У нас есть
несколько проблем:

1. Нам нужно, чтоб "сливающиеся" зоны, обработанные клеточными
   автоматами, были прямоугольными или квадратными, поскольку мы хотим
   сохранить фоновое пространство между строками абзаца и буквами.
   Отсюда вытекает проблема 2.

2. Как клеточные автоматы поделят между собой пиксели, чтоб в итоге у нас
   получился именно прямоугольник?
   Надо перебрать все варианты и выбрать наилучший.


   (кстати, а клеточным автоматам, которые будут искать шаблоны
   букв, не пофиг ли на пространство между строчками и словами? Они же
   анализируют только сами буквы. И если это действительно неважно, то
   зачем нам отсекать фон? Можно сразу искать буквы и анализировать их)

~Вариант решения проблемы №2~.

1. Определиться со структурой, в которую мы будем писать координаты
   пикселей, пока будем их "метить". Из адекватных вариантов хэш-таблица
   и бинарное дерево поиска, они быстрее итерации по списку или массиву.
   Построение бинарного дерева:
   - определить, какая координата будет "ведущей", поскольку у нас есть
     значение координат ~x~ и ~y~, т.е. что мы будем
     сравнивать, чтоб понять, в какую ветку дерева писать новый узел.
     Например, у нас есть координаты 3;5 6;8 2;9. Если ориентируемся по
     координате икс, то 3;5 будет корнем, 6;8 - правой веткой, 2;9 -
     левой. Если по игреку, то 3;5 и 6;8 останутся на тех же местах в
     дереве, а вот 2;9 станет новым листом правой ветки.
  - в ситуации когда "ведущая" координата меняться не будет,
    например, координаты будут выглядеть как 3;3 3;4 3;5 3;6 и т.д. Как
    понять, куда писать новые листы? В этом случае можно: сравнить
    дополнительно вторую координату у текущего узла и нового
    листа. Т.е. если координата ~x~ ведущая, и они одинаковые у текущего
    узла и будущего узла, мы сравним их ~y~-координаты, чтоб правильно
    выбрать ветку.
2. создать заголовок у бинарного дерева, куда будет помещен ~id~
   клеточного автомата, которому принадлежит это дерево.
   Таким образом при слиянии зон нам не придется переписывать альфаканалы
   пикселей, чтоб указать остальным, что их "хозяин" изменился.

~Алгоритм слияния зон при описанном выше решении проблемы №2~

У нас есть 2 клеточных автомата. Доя удобства назовем их "синий" и
"красный". Красный автомат натыкается на фоновый пиксель, который помечен
как "принадлежащий синему". В этом случае красный автомат должен:

1. Послать сообщение хозяину текущего пикселя сообщение о слиянии.
2. Получить ответ, который содержит в себе ~id~ из заголовка нашего
   дерева с пикселями.

Зачем нам этот ~id~ из заголовка, если мы его еще из альфаканала пикселя прочитали?
Да, у нас в альфаканале найденных пикселей написан ~id~ синего
автомата. Но мы помним, что при слиянии мы только поменяем заголовок у
дерева с координатами пикселей, вместо того, чтоб переписать значение
~id~ в альфаканае каждого пикселя. То есть то, что мы вот сейчас в
альфаканале чужих помеченных пикселей прочитали ~id~ синего автомата,
вообще не значит, что пиксели все еще принадлежат ему. Вдруг они уже
перехвачены каким-нибудь "зеленым" автоматом? Поэтому чтоб окончатльено
понять, чьи это пиксели, мы должны получить ~id~из заголовка их дерева.

Это наталкивает на 2 мысли:
а) даже если у текущего автомата пикселей больше не осталось и
разрастаться ему некуда, умереть он не может: он должен отвечать на
сообщения о слиянии и выдавать ~id~ текущего держателя дерева пикселей
б) не очень эффективный механизм получается: сначала надо обратиться к
одному автомату, потом к другому. А если слияний было уже штук десять, то
нам вообще всю цепочку от первого хозяина до последнего проходить?

Вариант решения: при каждом новом слиянии зон новый хозяин посылает прежним хозяевам
пикселей свой ~id~. Но тогда нужно как-то хранить, какие пиксели кому
принадлежали, что тоже геморройно и не очень эффективно.

3. Каким-то образом найти пограничные пиксели у новой предполагаемой зоны
   и сформировать из нее прямоугольник.

Пограничные пиксели  - это те пиксели, которые находятся на границе с
чужими зонами или текстом. Надо определить, отдать ли все пиксели новому
хозяину или часть оставить себе.

4. Каким-то образом объединить свое дерево с деревом синего автомата.
- Если отдаем все пиксели целиком:
Вариант 1:
Все узлы красного дерева встраиваются в синее дерево, т.е. мы сливаем
деревья. Если после этого не удалить красное дерево как самостоятельный
объект, то при последующих слияниях кол-во требуемой памяти будет расти
экспоненциально. Поскольку все деревья всех автоматов и их слияния будут
копироваться снова и снова. Значит, после слияния, дерево, которое
присоединяют (в нашем случае оно красное), надо бы удалить.
Но при этом надо куда-то записать ~id~ нового собственника дерева
пикселей.
Еще варианты?
- Если отдаем часть пикселей:
  Нужно удалить слитые узлы из красного дерева, чтоб память не засорять и
  включить новые узлы в синее дерево.
Записать ~id~ нового хозяина части пиксеелй?...
При поледующих слияниях будет дикий гемор.

***** TODO Что делать при столкноверии с текстом

Возникающие проблемы:
1. Фон может быть разного цвета. В вк он голубой и белый,
   например. Т.е. тот факт, что цвет пикселя отличается от текущего
   фонового, еще не означает, что мы встретили текст.
2. Текст тоже может быть разного цвета.
3. Если мы все-таки как-то определили, что встретились с текстом, то это
   означает, что фоновое пространство рядом с текстом уже помечено,
   сожрано клеточными автоматами. Оно нам вроде было зачем-то
   нужно(?). Как это предотвратить?
4. Работа автомата не должна прекращаться, как только мы встретились с
   текстом. Например, текст может быть сверху, а снизу его нет. Значит,
   надо как-то обозначить, что наверху нам больше искать нечего, будем
   искать по оставшимся 3 сторонам.

*** TODO Запустить распознавание букв
