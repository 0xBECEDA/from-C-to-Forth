#+STARTUP: showall indent hidestars

* Для чего?

Я задумала написать игрушку, чтоб более-менее разобраться с сетевым
программированием и си в частности. Плюс написание игры - это своего
рода интерактив. Сам пишешь, сам наблюдаешь, как код видимо,
материально меняет происходящее, сам играешь.

* Геймплей

Это многопользовательская сетевая игра.

Игроки управляют ~квадратиками~, которые перемещаются на двухмерном поле, заполненом
пикселями ~еды~, которую можно есть. ~Квадратик~ игрока увеличивается, когда сьедает
достаточно ~пикселей~.

Игрок заинтересован в увеличении своего ~квадратика~, потому что больший ~квадратик~
при столкновении с меньшим сьедает его.

Таким образом, цель игры в том, чтобы стать большим и сьесть всех противников.

* Компоненты

Игра состоит из ~Сервера~ и ~клиентов~. ~Клиентам~ желательно подключиться к серверу
при старте, т.к. тот кто играет дольше, получает преимущество в размере ~квадратика~.

** Сервер

За геймплей отвечает ~Сервер~. Он создает ~пиксели еды~, подсчитывает съеденные пиксели
путем сопоставления их координат с координатами героя и врага, увеличение квадратики и
пересылает пакеты от клиента к клиенту.

Сервер хранит состояние поля игры и принимает от игроков сообщения, которые содержат
информацию о перемещении квадратиков.

Состояние игры на сервере представляет собой:
- размер поля по горизотали и вертикали
- массив ~пикселей еды~, которую можно есть
- массив структур игроков

#+NAME: srv_game
#+BEGIN_SRC forth :tangle game_server.cpp :noweb tangle :exports code :padline no :comments none
  <<srv_libs>>
  <<field_constants>>
  <<srv_constants>>
  <<srv_globals>>
  <<srv_pixel_array>>

  <<srv_main>>
#+END_SRC

*** Размер поля

Размер поля - это константы, которые должны быть общими для клиентов и сервера. Но раз
уж мы начинаем с сервера, то объявим их тут:

#+NAME: field_constants
#+BEGIN_SRC cpp

  /* Размер поля по горизонтали */
  #define MAX_SIZE_X 500

  /* Размер поля по вертикали */
  #define MAX_SIZE_Y 500
#+END_SRC

*** Пиксели еды

Чтобы за едой пришлось побегать, я ограничиваю количество пикселей константой
~MAX_PIXELS~ и объявляю глобальный массив пикселей ~pixels~:

#+NAME: srv_constants
#+BEGIN_SRC cpp

  /* максимальное кол-во пикселей еды на поле */
  #define MAX_PIXELS 100
#+END_SRC

Каждый пиксель из массива ~пикселей еды~ имеет координаты и поле ~alive~, которое
показывает, сьеден ли он:

#+NAME: srv_globals
#+BEGIN_SRC cpp

  /* объявление структуры и массива пикселей */
  struct pixel {
      char alive;
      int c;
      int d;
  } pixels[MAX_PIXELS]
#+END_SRC

Теперь можно сгенерировать еду для игроков.

Я хочу перебрать массив структур пикселей, и для каждой структуры проверить поле
~alive~. Если оно содержит ~ноль~ - это значит, что пиксель был сьеден, а значит мы
можем воспользоваться его местом в массиве, чтобы сгенерировать новый пиксель и сразу
выйти из цикла. Таким образом мы генерируем один новый пиксель за раз, если для него
есть свободное место в массиве пикселей.

#+NAME: pixel_array_loop
#+BEGIN_SRC cpp
  for (i=0; i<=MAX_PIXELS; i++) {
      if (0 == pixels[i].alive) {
          /* сгенерируем один новый пиксель */
          <<generate_new_pixel>>
          /* выход из цикла */
          break;
      }
  }
#+END_SRC

Генерация нового пикселя не так проста, как кажется. Наивный способ сделать новый
пиксель - это взять случайные значения координат. Но что если там уже есть живой
(alive) пиксель? В этом случае мы должны получить новые случайные значения:

#+NAME: generate_new_pixel
#+BEGIN_SRC cpp
  generate_new_pixel:

  a = rand() % MAX_SIZE_X;
  b = rand() % MAX_SIZE_Y;

  for (int j=0; j<=MAX_PIXELS; j++) {
      if ((a == pixels[j].c &&) && (b == pixels[j].d)) {
          goto generate_new_pixel;
      }
  }

  pixels[i].c = a;
  pixels[i].d = b;
  pixels[i].alive = 1;
#+END_SRC

Теперь обернем полученное в функцию:

#+NAME: srv_pixel_array
#+BEGIN_SRC cpp

  /* процедура генерации одного нового пикселя еды */
  int PixelArray (struct * pixels[])
  {
      /* счетчик цикла, объявляется вне цикла, чтобы проанализировать пройден ли весь массив */
      int i;

      <<pixel_array_loop>>

      /* Если после окончания цикла i равен максимальному значению
         переменной цикла - значит весь массив перебрали,
         но не нашли свободной структуры */
      if ( MAX_PIXELS >= i ) {
          return -1;
      } else {
          return 0;
      }
  }
#+END_SRC

*** Структуры игроков

Также, как и с пикселями, я ограничиваю кол-во клиентов константой ~MAX_CLIENTS~:

#+NAME: srv_constants
#+BEGIN_SRC cpp

  /* максимальное кол-во подключенных клиентов */
  #define MAX_CLIENTS 2
#+END_SRC

Для каждого ~клиента~ я определяю структуру ~connection~, которая содержит:
- Идентификатор потока, в котором будет обрабатываться клиент
- Идентификатор соединения, чтобы отличать одно соединение от другого при получении данных
- Указатель на структуру ~sockaddr_in~ клиента
- Буфер для обмена данными

Используя эту структуру я объявляю глобальный массив клиентов:

#+NAME: srv_globals
#+BEGIN_SRC cpp

  /* объявление структуры и массива клиентов */
  struct connection
  {
      int thread;
      int ident;
      struct sockaddr_in *p;
      char *buf;
  } clients[MAX_CLIENTS];
#+END_SRC

*** TODO Сервер подключений

Теперь, когда есть куда поместить клиентов, можно написать код, который будет принимать
подключения. Сервер и клиенты будут общаться по UDP.

Мне понадобится:
- Счетчик в массиве структур клиентов
- Процедура записи нового клиента в массив клиентов
- Сокет, который будет слушать сервер
- Процедуры сериализации и десериализации принимаемых пакетов
- Код, который принимает UDP-датаграммы и разбирает их

Для начала нужен счетчик, чтобы заполнить следующую ячейку массива клиентов, если мы
обнаружили датаграмму с идентификатором нового клиента. Я назову его ~client_idx~ и
сначала он будет указывать на первый элемент массива:

#+NAME: srv_globals
#+BEGIN_SRC cpp

  /* индекс следующего клиента */
  int new_client_idx = 0;
#+END_SRC

Во-избежание всяких проблем, стоит также определить функцию, которая будет заполнять
следующий элемент массива клиентов, если в этом массиве еще осталось место. Она будет
принимать структуру клиента и возвращать ~false~ если массив исчерпан (ошибка) или
~true~ если все прошло успешно:

#+NAME: set_new_client
#+BEGIN_SRC cpp
  /* регистрация нового клиента */
  int set_new_client (struct connection client)
  {
      if (MAX_CLIENTS >= new_client_idx) {
          return 0; // error
      } else {
          clients[new_client_idx] = client;
          new_client_idx++;
          return 1; // success
      }
  }
#+END_SRC

Теперь можно приступить к созданию сокета, но сначала определим порт, который будет
слушать сервер:

#+NAME: srv_constants
#+BEGIN_SRC cpp

  /* порт сервера */
  #define PORT     8080
#+END_SRC

Также важно определить максимальный размер датаграммы:

#+NAME: srv_constants
#+BEGIN_SRC cpp

  /* максимальный размер датаграммы */
  #define MAXLINE  1220
#+END_SRC

Мы будем иcпользовать промежуточный буфер размером с максимально возможную датаграмму,
чтобы анализировать полученные из сети данные. Эту переменную в будущем стоит сделать
локальной и передавать явно как параметр (TODO).

#+NAME: srv_globals
#+BEGIN_SRC cpp

  /* объявляем промежуточный буфер */
  char buffer[MAXLINE];
#+END_SRC

Нам также понадобится структура ~sockaddr_in~ для сервера

#+NAME: srv_globals
#+BEGIN_SRC cpp

  /* sockaddr_in сервера */
  struct sockaddr_in servaddr;
#+END_SRC

И такая же структура, в которую функция ~recvfrom~ сохранит данные об отправители
датаграммы:

#+NAME: srv_globals
#+BEGIN_SRC cpp

  /* sockaddr_in клиента */
  struct sockaddr_in cliaddr;
#+END_SRC

Создаем сокет и связываем его с портом:

#+NAME: init_server_socket
#+BEGIN_SRC cpp
  /* Создаем сокет. Должны в случае успеха получить его дескриптор */
  int sockfd;
  if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
      perror("socket creation failed");
      exit(EXIT_FAILURE);
  }

  /* заполняем данные о сервере */
  servaddr.sin_family = AF_INET;
  servaddr.sin_addr.s_addr = INADDR_ANY;
  servaddr.sin_port = htons(PORT);

  /* привязываем сокет к адресу */
  if ( bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0 ) {
      perror("bind failed");
      exit(EXIT_FAILURE);
  }
#+END_SRC

Окей, сокет создан и готов принимать UDP-датаграммы. Теперь мы можем написать
бесконечный цикл, в котором сервер будет:
- пытаться создать новый пиксель еды
- читать из сокета, разбирать полученное и обрабатывать его

#+NAME: srv_loop
#+BEGIN_SRC cpp
  while (1) {
      /* Создаем новый пиксель еды если есть возможность */
      PixelArray(&pixels);
      /* Читаем датаграмму */
      int len = sizeof(cliaddr);
      int n = recvfrom(sockfd, buffer, MAXLINE,
                       MSG_WAITALL, ( struct sockaddr *) &cliaddr,
                       &len);
      /* Разбираем датаграмму и пересылаем изменения остальным клиентам */
      <<datagramm_parse>>
  }
#+END_SRC

Перед тем как погружаться в анализ датаграммы, объединим создание сокета и бесконечный
цикл в функицю ~main~:

#+NAME: srv_main
#+BEGIN_SRC cpp
  void  main()
  {
      <<init_server_socket>>
      <<srv_loop>>
  }
#+END_SRC

Теперь приступим к обработке датаграммы:

#+NAME: datagramm_parse
#+BEGIN_SRC cpp

  /* TODO: тут будет анализ датаграммы и посылка данных остальным клиентам */
  /* Я пока положу сюда код из udp-server.c */

  /* вытаскиваем идентификатор */
  int ident_client = *(int *)buffer;
  //printf("Num of receved bytes %d\n", n);
  printf("in main ident_client is %d\n", ident_client);
  /*проверяем, не новый ди у нас клиент.
    Для этого проверяем идентификаторы клиентов и
    идентификатор из пакета*/

  for(int i = 0; i<=1; i++) {
      /* проверяем идентификатор на совпадение */
      int counter = 0;

      /*если идентификатор совпадает*/
      if( clients[i].ident == ident_client) {
          /*увеличиваем счетчик, переписываем данные и выходим*/
          char *pnt = clients[i].buf;
          printf("char *p, если ident совпал  %X\n", pnt);
          memcpy(pnt, buffer, MAXLINE);
          clients[i].buf = pnt;
          counter++;
          break;
      }
      /*если структура пустая и счетчик нулевой*/
      if( clients[i].ident == 0
          && counter == 0) {
          /* то записываем данные клиента в массив */
          clients[i].ident = ident_client;

          /*выдеяем память по буфер
            и перезаписываем туда данные*/
          char *p = malloc(MAXLINE);
          memcpy(p, buffer, MAXLINE);
          clients[i].buf = p;

          printf("char *p, если ident НЕ совпал  %X\n", p);
          /* зачем нужен pointer?
             - а как я без него создам поток?
             Последний параметр для него -
             нетипизированный указатель.*/
          void* pointer = NULL;

          /* переменная для хранения идентификатора потока */
          pthread_t udp_thread;

          /* создаем поток */
          pthread_create(&udp_thread, NULL,
                         udp_socket, pointer);

          /* кладем идентификатор потока в структуру */
          clients[i].thread = udp_thread;

          /* копируем данные структуру клиента в массив */
          dub_array[cnt] = cliaddr;

          /*печатаем содержимое структур*/
          //print_struct(cnt);

          /*
            - записываем в структуру client указатель
            на конкретную структуру клиента типа sockaddr.
            Так в одной структуре хранятся идентификатор
            потока идентификатор клиента и ссылка
            на структуру клиента, которая заполнена
            данными типа семейства адресов и т.д.*/
          clients[i].p = pnt;
          printf("pnt of struct is %X\n", pnt);
          printf("clients[i].p is %X\n", clients[i].p);
          printf ("clients[i].ident is %d\n", clients[i].ident);
          fflush(stdout);
          pnt += 1;

          /* можно ли обойтись переменной цикла
             - нет, потому что переменная цикла отражает
             проход по массиву вне условий, а cnt должна
             увеличиться только при выполнении If.
             В противном случае данные в dub_array
             могут быть перезаписаны*/
          cnt++;

          break;
      }

  }

#+END_SRC

** Клиент

На клиенте происходит инициализация библиотеки SDL, отрисовка всех визуальных
элементов игры, мониторинг событий, типа, движения мышки, управления
героем и т.д.

Итак, начнем с самого необходимого. Сначала подключим все библиотеки,
которые будут нам нужны.

#+NAME: libraries
#+BEGIN_SRC cpp
  #include <SDL2/SDL.h>
  #include <stdio.h>
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <signal.h>
  #include <stdbool.h>
  #include <time.h>
  #include <unistd.h>
  #include <linux/unistd.h>
  #include <pthread.h>
  #include <errno.h>
  #include <fcntl.h>
  #include <netinet/in.h>
#+END_SRC

Прежде чем работать с SDL надо еe "включить", т.е. в нашем случае
инициализировать.
В игре нам точно понадобится окно, его поверхность, на которой мы и
будем рисовать, и все функции, которые может предложить нам SDL. Зачем
себя ограничивать, в конце концов?

#+NAME: declaration_SDL
#+BEGIN_SRC cpp

  SDL_Window* gWindow = NULL;
  SDL_Surface* surface = NULL;
  SDL_Event event;
  SDL_Keysym keysym;
  int SCREEN_WIDTH = 480;
  int SCREEN_HEIGHT = 520;

  bool init();
  bool create();
  bool surface_create();

  <<declaration_hero>>
#+END_SRC

Итак мы сказали, у нас будет указатель на окно, указатель на
поверхность, объект "event", объект "keysym", а размер нашего будущего
окна будет 480 х 520. Так же нам нужны 3 функции. Init(); "включит"
нам все функции SDL, create(); создаст окно, а surface_create();
создаст поверхность в этом окне.

#+NAME: three_functions_SDL
#+BEGIN_SRC cpp

bool init()
{
if( SDL_Init( SDL_INIT_VIDEO ) < 0 ) {
        printf( "SDL could not initialize! SDL_Error: %s\n", SDL_GetError() );
        return false;
    }
    return true;
}

bool create()
{
    if ( !(gWindow =
           SDL_CreateWindow("SDL Tutorial",
                            SDL_WINDOWPOS_UNDEFINED,
                            SDL_WINDOWPOS_UNDEFINED,
                            SCREEN_WIDTH,
                            SCREEN_HEIGHT,
                            SDL_WINDOW_SHOWN)) ) {
        printf( "SDL_CreateWindow() failed! SDL_Error: %s\n", SDL_GetError() );
        return false;
    }
    return true;
}

bool surface_create ()
{
    if ( !(surface = SDL_GetWindowSurface(gWindow)) ) {
        printf ("Didn't create surface! SDL_Error: %s\n", SDL_GetError());
        return false;
    }
    return true;
}

#+END_SRC
Все три функции должны вернуть true или напечатать сообщение о
возникшей ошибке.

Начало положено. Теперь можно попробовать вывести главного героя на
экран. У него есть координаты X и Y, а так же размер его сторон.

#+NAME: declaration_hero
#+BEGIN_SRC cpp

  int X = 0;
  int Y = 0;

  int pix_y = 10;
  int pix_x = 10;

#+END_SRC

А еще он состоит из пикселей, которые надо отрисовать. Отрисовка
пикселей будет нужна постоянно, поэтому разумно написать для этого
отдельную функцию.

#+NAME: DrawPixel
#+BEGIN_SRC cpp

  void DrawPixel(SDL_Surface *screen, int x, int y,
                 Uint8 R, Uint8 G, Uint8 B)
  {
      Uint32 color = SDL_MapRGB(surface->format, R, G, B);
      int bpp =  surface->format->BytesPerPixel;
      Uint32 ppr = surface->pitch/bpp;

      switch (bpp)
      {
      case 1:
      {

          Uint8 *p = (Uint8 *)surface->pixels + (y * ppr + x )* bpp;
          *p = color;
      }
      break;
      case 2:
      {
          Uint16 *p = (Uint16 *)surface->pixels + (y * ppr + x );
          *p = color;
      }
      break;
      case 3:
      {
          Uint8 *p = (Uint8 *)surface->pixels +
              y*surface->pitch + x * 3;
          if(SDL_BYTEORDER == SDL_LIL_ENDIAN)
          {
              p[0] = color;
              p[1] = color >> 8;
              p[2] = color >> 16;
          } else {
              p[2] = color;
              p[1] = color >> 8;
              p[0] = color >> 16;
          }
      }
      break;
      case 4:
      {
          Uint32 *p = (Uint32 *)surface->pixels + (y * ppr + x );
                 *p = color;
      }
      break;
      }
  }

#+END_SRC
DrawPixel принимает в качетве параметра адрес поверхности, на которой
предстоит рисовать, и координаты пикселя и составляющие его цвета.
Затем она проверят, сколько бит приходится на пиксель и в зависимости
от этого отрисовывает его тем или иным способом.

Теперь мы можем написать функцию, которая будет нам рисовать
квадратик, чтоб не передавать каждый пиксель в Draw_Pixel вручную.

#+NAME: show_box
#+BEGIN_SRC cpp

void show_box(int box_x, int box_y, int red, int green, int blue)
{
    int cnt = 0;
    for ( int j = box_y; j<(box_y + pix_y); j++) {
        for ( int i = box_x; i<(box_x + pix_x); i++) {
            DrawPixel(surface, i, j, red, green, blue);
        }
    }
}

#+END_SRC

Функция принимает координаты квадратика, размер его сторон и
составляющие цвета. Затем вызывает Draw_Pixel в двух циклах, чтоб
получился квадратик.

Теперь самое время это все собрать.

#+NAME: main
#+BEGIN_SRC cpp
void main() {
  if( !init() ) {

      printf( "Failed to initialize SDL!\n" );
  }
  if( !create() ) {

      printf( "Failed to initialize window!\n" );
  }

  if( !surface_create() ) {

      printf( "Failed to initialize surface!\n" );
  }

  SDL_LockSurface(surface);
  srand(time(NULL));
  X = rand() % 500;

  show_box(X, Y, 255, 255, 255);
  SDL_UnlockSurface(surface);
  SDL_UpdateWindowSurface(gWindow);
  sleep(5);
}
#+END_SRC

Мы проинициализировали SDL, создали окно и поверхность, затем
заблокировали проверхность, чтоб пользователь не увидел всю "кухню"
отрисовки, получили рандомно координату X для квадратика, чтоб он
каждй раз появлялся в разном месте, вызвали его отсовку,
разблокировали поверхность и обновили ее. Ну и задержимся на 5 секунд
перед выходом, чтоб увидеть плоды своих трудов.

* Сборка

C-c C-v t

#+NAME: game
#+BEGIN_SRC forth :tangle game.c :noweb tangle :exports code :padline no :comments none
  <<libraries>>

  <<declaration_SDL>>

  <<three_functions_SDL>>

  <<DrawPixel>>

  <<show_box>>

  <<main>>
#+END_SRC
